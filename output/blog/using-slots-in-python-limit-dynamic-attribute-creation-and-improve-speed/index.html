<!doctype html><html lang=en><script async src=https://www.googletagmanager.com/gtag/js?id=G-CYPVPEJ4PK></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date());gtag('config','G-CYPVPEJ4PK')</script><meta charset=utf-8><meta content=width=device-width,initial-scale=1 name=viewport><title>Using slots in Python: limit dynamic attribute creation and improve speed | Python For The Lab</title><meta content="classes, object oriented, dictionary, memory, slots, " name=tags><meta content="Limiting attribute creation in Python can be useful to limit the number of mistakes users of our code can make" name=description><meta content="Aquiles Carattino" name=author><link href=blog/using-slots-in-python-limit-dynamic-attribute-creation-and-improve-speed rel=canonical><meta content="Python for the Lab" property=og:site_name><meta content=article property=og:type><meta content=blog/using-slots-in-python-limit-dynamic-attribute-creation-and-improve-speed property=og:url><meta content="Using slots in Python: limit dynamic attribute creation and improve speed" property=og:title><meta content="Limiting attribute creation in Python can be useful to limit the number of mistakes users of our code can make" property=og:description><meta content=/images/python1-01_gq7Qcbn.width-800.png property=og:image><meta content=summary_large_image property=twitter:card><meta content=blog/using-slots-in-python-limit-dynamic-attribute-creation-and-improve-speed property=twitter:url><meta content="Using slots in Python: limit dynamic attribute creation and improve speed" property=twitter:title><meta content="Limiting attribute creation in Python can be useful to limit the number of mistakes users of our code can make" property=twitter:description><meta content=/images/python1-01_gq7Qcbn.width-800.png property=twitter:image><meta content=@aquicarattino name=twitter:creator><link href=https://pythonforthelab.com/theme/css/favicon/apple-icon-57x57.png rel=apple-touch-icon sizes=57x57><link href=https://pythonforthelab.com/theme/css/favicon/apple-icon-60x60.png rel=apple-touch-icon sizes=60x60><link href=https://pythonforthelab.com/theme/css/favicon/apple-icon-72x72.png rel=apple-touch-icon sizes=72x72><link href=https://pythonforthelab.com/theme/css/favicon/apple-icon-76x76.png rel=apple-touch-icon sizes=76x76><link href=https://pythonforthelab.com/theme/css/favicon/apple-icon-114x114.png rel=apple-touch-icon sizes=114x114><link href=https://pythonforthelab.com/theme/css/favicon/apple-icon-120x120.png rel=apple-touch-icon sizes=120x120><link href=https://pythonforthelab.com/theme/css/favicon/apple-icon-144x144.png rel=apple-touch-icon sizes=144x144><link href=https://pythonforthelab.com/theme/css/favicon/apple-icon-152x152.png rel=apple-touch-icon sizes=152x152><link href=https://pythonforthelab.com/theme/css/favicon/apple-icon-180x180.png rel=apple-touch-icon sizes=180x180><link href=https://pythonforthelab.com/theme/css/favicon/android-icon-192x192.png rel=icon sizes=192x192 type=image/png><link href=https://pythonforthelab.com/theme/css/favicon/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=https://pythonforthelab.com/theme/css/favicon/favicon-96x96.png rel=icon sizes=96x96 type=image/png><link href=https://pythonforthelab.com/theme/css/favicon/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=https://pythonforthelab.com/theme/css/favicon/manifest.json rel=manifest><meta content=#ffffff name=msapplication-TileColor><meta content=https://pythonforthelab.com/theme/css/favicon/ms-icon-144x144.png name=msapplication-TileImage><meta content=#ffffff name=theme-color><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href=https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Poppins:wght@300;400;700&display=swap rel=stylesheet><link href=https://pythonforthelab.com/theme/css/style.css rel=stylesheet><link href=https://files.stork-search.net/basic.css rel=stylesheet><link href=https://https://pythonforthelab.com/feed.rss rel=alternate title=RSS type=application/rss+xml><script src=https://code.jquery.com/jquery-3.4.1.min.js></script><script src=https://pythonforthelab.com/theme/js/jquery-migrate-1.2.1.js></script><script src=https://pythonforthelab.com/theme/js/functions.js></script><link href=https://pythonforthelab.com/theme/css/prism.css rel=stylesheet><body><section class=wrapper><div class="intro blog article"><div class=container><div class=header><a class=logo href=/>Python for the Lab</a><div class=header-dd><div class=navigation><ul><li class=active><a class="nav-item blog" href=https://pythonforthelab.com/blog><span>Blog</span></a><li><a class="nav-item courses" href=https://pythonforthelab.com/courses/><span>Courses</span></a><li><a class="nav-item hire-me" href=https://pythonforthelab.com/hire-me/><span>Hire Me</span></a><li><a class="nav-item forum" href=https://github.com/PFTL/pftl_discussions/discussions target=_blank><span>Forum</span></a><li><a class="nav-item books" href=https://pythonforthelab.com/books><span>Books</span></a><li><a class="nav-item about" href=https://pythonforthelab.com/about><span>About</span></a></ul></div><div class="search field-wp"><form action=#><input placeholder="Type to Search" class=field data-stork=sitesearch><input class=search-btn type=submit></form><div data-stork=sitesearch-output></div></div></div><button class=menu-btn><span>Menu</span></button></div><div class="intro-cnt v-article"><div class=side-text></div><div class="side-form small-sb-form"><div class=sb-form id=mc_embed_signup><h4>Get all the information directly to your inbox</h4><form action=https://pythonforthelab.us21.list-manage.com/subscribe/post?u=f0d9bfa6188cdcc67890a07f6&id=8a0ca536e8&f_id=00dfebe6f0 class=validate id=mc-embedded-subscribe-form method=post name=mc-embedded-subscribe-form novalidate><div class=field-wp id=mc_embed_signup_scroll><input placeholder="Your E-Mail" class=field id=mce-EMAIL name=EMAIL required type=email></div><div aria-hidden=true style=position:absolute;left:-5000px>/* real people should not fill this in and expect good things - do not remove this or risk form bot signups */ <input name=b_f0d9bfa6188cdcc67890a07f6_8a0ca536e8 tabindex=-1></div><input value="Subscribe to the Newsletter" class=send-btn id=mc-embedded-subscribe name=subscribe type=submit><span class=small-text>Get relevant information, unsubscribe at any time.</span></form></div></div></div></div></div><div class=main><div class=container><div class=article-cnt><div class=leftside><div class=article-image><img alt src=https://pythonforthelab.com//images/python1-01_gq7Qcbn.width-800.png width=800></div><h1>Using slots in Python: limit dynamic attribute creation and improve speed</h1><h3>Limiting attribute creation in Python can be useful to limit the number of mistakes users of our code can make</h3><div class=info><span class="item-1 author">by Aquiles Carattino</span><span class="item-1 date">2021-03-21</span><span class="item-tag first">classes</span><span class=item-tag>object oriented</span><span class=item-tag>dictionary</span><span class=item-tag>memory</span><span class=item-tag>slots</span></div><main><p>When we create classes, one of the biggest challenges is understanding how to handle dynamic attribute creation. Slots have the benefit of limiting attribute creation at runtime. In this article, we will explore how slots work, including a quick overview of how classes store attributes internally.<h2>Dynamic attribute creation</h2><p>One of the advantages of objects in Python is that they can store any number of attributes. Moreover, these attributes can be created dynamically when the program runs and not only when the class is defined. Let's start with a simple example to get the gist of it:<pre><code class=language-python>class Person:
    def __init__(self, name):
        self.name = name
</code></pre><p>The class <code>Person</code> can be used like this:<pre><code class=language-pycon>>>> me = Person('Aquiles')
>>> print(me.name)
'Aquiles'
</code></pre><p>The class <code>Person</code> creates an attribute <code>name</code> when we instantiate it, and we assign any value we want. In the example above, we used <code>'Aquiles'</code>. We print the attribute <code>name</code> of the object <code>me</code> to show that it is behaving as expected. Python objects allow us to modify the attribute or to create new attributes:<pre><code class=language-pycon>>>> me.name = 'John'
>>> me.last_name = 'Doe'
>>> print(me.name)
'John'
>>> print(me.last_name)
'Doe'
</code></pre><p>First, we replace the value of <code>name</code> at runtime. Later, we create a new attribute, <code>last_name</code> that is not part of the original design of <code>Person</code>. This pattern can be both handy and dangerous. Imagine we have a complex object, for example, to control a camera. We define an attribute <code>exposure_time</code> when we develop the <code>Camera</code> class. If later on we make a mistake and use <code>exp_time</code> instead, there will be no warning, and the error can go unnoticed until it is too late:<pre><code class=language-pycon>>>> camera = Camera()
>>> camera.exposure_time = '5ms'
>>> camera.exp_time = '10ms'
</code></pre><h2>Quick intro to slots</h2><p>Limiting the creation of attributes at runtime can be a great advantage, and Python offers a straightforward syntax to achieving it:<pre><code class=language-python>class Person:
    __slots__ = 'name'
    def __init__(self, name):
        self.name = name
</code></pre><p>And this time, if we run the same coda we ran earlier, we will get a different outcome:<pre><code class=language-pycon>>>> me = Person('Aquiles')  
>>> print(me.name)  
'Aquiles'
>>> me.name = 'John'  
>>> print(me.name)  
'John'
>>> me.last_name = 'Doe'
Traceback (most recent call last):
  File "/Users/aquiles/Documents/Web/pftl_code/code/_slots/aa.py", line 11, in &LTmodule>
    me.last_name = 'Doe'
AttributeError: 'Person' object has no attribute 'last_name'
</code></pre><p>We could alter the <code>name</code> attribute at runtime, but <code>last_name</code> gave and <code>AttributeError</code>. If we modify the slots to include <code>last_name</code>, then the output would be different:<pre><code class=language-python>class Person:
    __slots__ = 'name', 'last_name'
    def __init__(self, name):
        self.name = name
</code></pre><p>And this time there will be no <code>AttributeError</code>:<pre><code class=language-pycon>>>> me = Person('Aquiles')
>>>me.last_name = 'Doe'
>>> print(me.last_name)
'Doe'
</code></pre><p>In the examples above, it is clear that we can limit the dynamic creation of attributes by using slots. However, it is essential to note that classes tend to get much more sophisticated and store many different attributes. Keeping <code>__slots__</code> up to date can quickly become a hassle.<p>Two things are worth noting. One is that class attributes (i.e., attributes defined at a class level) automatically become read-only:<pre><code class=language-python>class Person:
    __slots__ = 'name', 'last_name'
    age = 35

    def __init__(self, name):
        self.name = name
</code></pre><p>And if we try to change the age after instantiating the class we get the following error:<pre><code class=language-pycon>>>> me = Person('Aquiles')
>>> print(me.age)
35
>>> me.age = 50
Traceback (most recent call last):
  File "/Users/aquiles/Documents/Web/pftl_code/code/_slots/aa.py", line 16, in &LTmodule>
    me.age = 50
AttributeError: 'Person' object attribute 'age' is read-only
</code></pre><p>We'll dive more into the reasons behind this behavior in the following section.<h2>Where are attributes stored, the <strong>dict</strong></h2><p>Objects must remember the attributes to which they have access to retrieve them or give an error if they can't be found. In Python, this is done through a dictionary called <code>__dict__</code>. We can see how it works with the same example we used earlier:<pre><code class=language-python>class Person:
    birth_year = 1986
    def __init__(self, age, name):
        self.age = age
        self.name = name

    def print_name(self):
        print(self.name)
</code></pre><p>We can inspect the dictionary of both the Person class and of one of its instances:<pre><code class=language-pycon>>>> print(Person.__dict__)
{'__module__': '__main__', 'birth_year': 1986, '__init__': &LTfunction Person.__init__ at 0x7fd890028ee0>, 'print_name': &LTfunction Person.print_name at 0x7fd89046ca60>, '__dict__': &LTattribute '__dict__' of 'Person' objects>, '__weakref__': &LTattribute '__weakref__' of 'Person' objects>, '__doc__': None}
>>> me = Person(35, 'Aquiles')
>>> print(me.__dict__)
{'age': 35, 'name': 'Aquiles'}
</code></pre><p>Note, first, that we are not using slots; it is a plain class. The dictionary of the class stores references to its attributes <code>birth_year</code> and the methods <code>__init__</code> and <code>print_name</code>. It has no information about <code>age</code> or <code>name</code> because these attributes get created only <em>after</em> the class is instantiated.<p>On the other hand, the dictionary of the object <code>me</code> has both <code>name</code> and <code>age</code> but nothing else. If we would like to access the value stored in the dictionary, we can do the following:<pre><code class=language-python>me.__dict__['name']
</code></pre><p>If we add slots, however, things will change. Let's what happens to the dictionary in the following example:<pre><code class=language-python>class Person:
    __slots__ = 'age', 'name'
    birth_year = 1986

    def __init__(self, age, name):
        self.age = age
        self.name = name

    def print_name(self):
        print(self.name)
</code></pre><p>We kept the <code>birth_year</code> class attribute, but we added the slots for <code>age</code> and <code>name</code>. If we repeat what we did earlier:<pre><code class=language-pycon>>>> print(Person.__dict__)
{'__module__': '__main__', '__slots__': ('age', 'name'), 'birth_year': 1986, '__init__': &LTfunction Person.__init__ at 0x7ffdf0118ee0>, 'print_name': &LTfunction Person.print_name at 0x7ffde032ba60>, 'age': &LTmember 'age' of 'Person' objects>, 'name': &LTmember 'name' of 'Person' objects>, '__doc__': None}
>>> me = Person(35, 'Aquiles')
>>> print(me.__dict__)
Traceback (most recent call last):
[...]
AttributeError: 'Person' object has no attribute '__dict__'
</code></pre><p>The only difference between the earlier code and this one is that we added the <code>__slots__</code> class attribute. We can notice that the class dictionary is different. Now there are both <code>age': &LTmember 'age' of 'Person' objects></code> and <code>'name': &LTmember 'name' of 'Person' objects></code>. Moreover, if we explore the object <code>me</code>, we see that it has no <code>__dict__</code>. It is fair, therefore, to ask where are these attributes stored, and the answer is close by:<pre><code class=language-pycon>>>> print(me.__slots__)
('age', 'name')
</code></pre><p>To wrap up what we have just seen, when we use slots, we create objects with no <code>__dict__</code> associated with them, but rather a <code>__slots__</code> tuple. It is a significant distinction since tuples are immutable in Python. Moreover, the attributes that we defined in the slots show directly on the class dictionary, and this was not the case before.<p>We can explore a bit more this additions by looking at what their types are. For example, we can do the following:<pre><code class=language-pycon>>>> print(type(Person.__dict__['birth_year']))
&LTclass 'int'>
>>> print(type(Person.__dict__['age']))
&LTclass 'member_descriptor'>
</code></pre><p>And this is the quid of the question regarding slots. When we define them in a class, they are automatically created as descriptors. We have written a <a href=https://www.pythonforthelab.com/blog/data-descriptors-bringing-attributes-next-level/>complete article about descriptors</a> that may be worth checking out to go deeper with the understanding. It is the reason why we get the read-only attributes if we don't specify them in the slots.<h3>Adding the dictionary to the slots</h3><p>We saw that when we define slots for a class, its objects do not have a <code>__dict__</code> to store their attributes. Therefore, we could ask ourselves what would happen if we add the dictionary to the list of slots. Let's try it out:<pre><code class=language-python>class Person:
__slots__ = 'age', 'name', '__dict__'

def __init__(self, age, name):
    self.age = age
    self.name = name
    self.birth_year = 1986
</code></pre><p>And we can now use it as we have always done:<pre><code class=language-pycon>>>> me = Person(35, 'Aquiles')
>>> print(me.__dict__)
{'birth_year': 1986}
>>> me.new_var = 10
>>> print(me.__dict__)
{'birth_year': 1986, 'new_var': 10}
</code></pre><p>We have created a hybrid class in which some attributes are slots, and therefore they do not appear in the dictionary. However, since the class itself has a dictionary, we can dynamically create new attributes. Whether this pattern is useful (or even correct) can be subject to discussion. We are not going to engage with it right now.<h2>Slots and inheritance</h2><p>The final important topic to cover about slots is how they behave with inheritance. Let's start creating a new class that inherits from <code>Person</code> and see what happens:<pre><code class=language-python>class Person:
__slots__ = 'age', 'name'
def __init__(self, age, name):
    self.age = age
    self.name = name

class Student(Person):
    def __init__(self, age, name, course):
        super(Student, self).__init__(age, name)
        self.course = course
</code></pre><p>In the example above, <code>Studen</code> inherits from <code>Person</code> but it does not define new slots. Therefore, it will behave like any other class:<pre><code class=language-pycon>>>> me = Student(35, 'Aquiles', 'Physics')    
>>> print(me.__dict__)
{'course': 'Physics'}
>>> me.new_var = 10
>>> print(me.__dict__)
{'course': 'Physics', 'new_var': 10}
>>> print(me.__slots__)
('age', 'name')
</code></pre><p><code>Student</code> handles dynamic attribute creation, and we still have access to the slots defined in the parent class <code>age</code> and <code>name</code>. This means that if we inherit from a class, we should not worry whether it defined slots or not. The child class will behave precisely as we design it to behave.<p>The other possibility is to define slots in the child class but not in the parent class, like this:<pre><code class=language-python>class Person:
def __init__(self, age, name):
    self.age = age
    self.name = name

class Student(Person):
    __slots__ = 'course'
    def __init__(self, age, name, course):
        super(Student, self).__init__(age, name)
        self.course = course
</code></pre><p>And, surprisingly, the code above still works:<pre><code class=language-pycon>>>> me = Student(35, 'Aquiles', 'Physics')
>>> print(me.__dict__)
{'age': 35, 'name': 'Aquiles'}
>>> me.new_var = 10
>>> print(me.__dict__)
{'age': 35, 'name': 'Aquiles', 'new_var': 10}
>>> print(me.__slots__)
course
</code></pre><p>Therefore, if either the parent or the child defines the <code>__dict__</code>, then the objects will also have a dict and will be able to accept dynamically created attributes. The only way in which can leverage slots is if both parent and child define them:<pre><code class=language-python>class Person:
    __slots__ = 'age', 'name'
    def __init__(self, age, name):
        self.age = age
        self.name = name

class Student(Person):
    __slots__ = 'course'
    def __init__(self, age, name, course):
        super(Student, self).__init__(age, name)
        self.course = course
</code></pre><p>And then we'll see the behavior that would be expected from having slots:<pre><code class=language-pycon>>>> me = Student(35, 'Aquiles', 'Physics')
>>> print(me.__slots__)
course
>>> me.new_var = 10
Traceback (most recent call last):
[...]
AttributeError: 'Student' object has no attribute 'new_var'
</code></pre><h2>Impact of slots on size and speed of code</h2><p>One of the reasons behind adding slots to Python was to have faster attribute access. This was discussed in <a href=https://python-history.blogspot.com/2010/06/inside-story-on-new-style-classes.html>this blog post</a> from 2010, summarizing all the improvements done to classes. Essentially, slots were added to overcome potential impacts in performance. By defining slots, the programs can have a faster lookup of the data stored. Whether an increase of lookup times of around 15% impacts the overall code will depend on how often we perform the task.<p>The other impact of slots is lower memory usage. Since slots prevent creating a dictionary and a <em>weakref</em> (which didn't discuss in this article), each object created will require less memory. For code creating few hundreds of objects, the impact may be negligible. Still, if we are creating millions of objects, the effect can be tremendous. For example, <a href=https://docs.sqlalchemy.org/en/14/changelog/migration_10.html#significant-improvements-in-structural-memory-use>SQLAlchemy has a measurable effect on the use of slots</a>.<h2>Conclusions: Deciding when is worth using slots</h2><p>Slots are a feature worth keeping in mind when developing code and, more importantly, when studying other's code. Using them for speed and memory improvements is likely to be far-fetched for most programs. It is essential to keep in mind that if a program was optimized using slots, we could easily ruin those optimizations by careless inheritance.<p>On the other hand, limiting the attribute creation at runtime can have a broad set of application contexts, even if it was not the original motivation for implementing slots in Python. For example, when developing code to control hardware, such as a camera, users may make mistakes such as using <code>exposure</code> instead of <code>exposure_time</code> to change a parameter. Due to dynamic attribute creation, there won't be any error shown on the screen.<p>Slots are not the only way of solving these issues, but they are straightforward to implement.</main><div class=info-list><span class="item author">Article written by Aquiles Carattino</span></div><div class=similar-posts><h3>Related Articles:</h3><ul><li><a class=item href=https://pythonforthelab.com/blog/singletons-instantiate-objects-only-once> <img alt src=/images/mirrors.width-800.jpg> <span class=date>2021-01-16</span> <span class=name>Singletons: Instantiate objects only once</span> </a></ul></div><div class=bottom-section><h4>Share your thoughts with us!</h4><div class=comments><script async crossorigin issue-term=pathname label=Comment repo=PFTL/pftl_discussions src=https://utteranc.es/client.js theme=github-light></script></div></div></div><div class=rightside><div class=support-box><h3>Support Us</h3><p>If you like the content of this website, consider buying a copy of the book <strong>Python For The Lab</strong></p><a class=button href=https://pythonforthelab.com/books>Check out the book</a></div><div class=latest-posts><h3>Latest Articles</h3><ul><li><a href=https://pythonforthelab.com/blog/instructions-to-build-the-python-for-the-lab-daq/>Instructions to build the Python for the Lab DAQ.</a> <span>by Aquiles Carattino, 2021-03-27</span><li><a href=https://pythonforthelab.com/blog/using-slots-in-python-limit-dynamic-attribute-creation-and-improve-speed>Using slots in Python: limit dynamic attribute creation and improve speed</a> <span>by Aquiles Carattino, 2021-03-21</span><li><a href=https://pythonforthelab.com/blog/getting-started-with-basler-cameras>Acquiring images from Basler Cameras</a> <span>by Aquiles Carattino, 2021-02-27</span><li><a href=https://pythonforthelab.com/blog/singletons-instantiate-objects-only-once>Singletons: Instantiate objects only once</a> <span>by Aquiles Carattino, 2021-01-16</span><li><a href=https://pythonforthelab.com/blog/differences-between-multiprocessing-windows-and-linux>Differences of Multiprocessing on Windows and Linux</a> <span>by Aquiles Carattino, 2020-06-13</span><li><a href=https://pythonforthelab.com/blog/python-tip-using-else-loops>Python Tip: Using Else with Loops</a> <span>by Aquiles Carattino, 2020-05-25</span><li><a href=https://pythonforthelab.com/blog/python-tip-ready-publish-matplotlib-figures>Python Tip: Ready to Publish Matplotlib Figures</a> <span>by Aquiles Carattino, 2020-05-18</span><li><a href=https://pythonforthelab.com/blog/data-descriptors-bringing-attributes-next-level>Data Descriptors: Bringing Attributes to the Next level</a> <span>by Aquiles Carattino, 2020-05-16</span><li><a href=https://pythonforthelab.com/blog/python-tips-using-sets>Python Tips: Using Sets</a> <span>by Aquiles Carattino, 2020-05-11</span><li><a href=https://pythonforthelab.com/blog/generators-iterables-iterators-python-when-and-where>Generators, Iterables, Iterators in Python: When and Where</a> <span>by Aquiles Carattino, 2020-04-10</span></ul></div><div class=subscribe-fixed><button class=action>Never Stop Learning</button><div class=cnt><p>Join over 1000 Python developers and don't miss any updates!<form action=https://pythonforthelab.us21.list-manage.com/subscribe/post?u=f0d9bfa6188cdcc67890a07f6&id=8a0ca536e8&f_id=00dfebe6f0 class=validate id=mc-embedded-subscribe-form method=post name=mc-embedded-subscribe-form novalidate><div class=field-wp id=mc_embed_signup><input class="field required email" placeholder="Your E-Mail" id=mce-EMAIL name=EMAIL required type=email></div><div class="clear foot" id=mce-responses><div class=response id=mce-error-response style=display:none></div><div class=response id=mce-success-response style=display:none></div></div><div aria-hidden=true style=position:absolute;left:-5000px>/* real people should not fill this in and expect good things - do not remove this or risk form bot signups */ <input name=b_f0d9bfa6188cdcc67890a07f6_8a0ca536e8 tabindex=-1></div><input value="Subscribe to the Newsletter" class=send-btn id=mc-embedded-subscribe name=subscribe type=submit></form><p>Or check out our <a href=/books>books</a>! <br> <a href=#>Privacy Policy</a></div></div></div></div><div class=mobile-sb-form><div class=sb-form><h4>Get all the information directly to your inbox</h4><form action=https://pythonforthelab.us21.list-manage.com/subscribe/post?u=f0d9bfa6188cdcc67890a07f6&id=8a0ca536e8&f_id=00dfebe6f0 class=validate id=mc-embedded-subscribe-form method=post name=mc-embedded-subscribe-form novalidate><div class=field-wp id=mc_embed_signup><input class="field required email" placeholder="Your E-Mail" id=mce-EMAIL name=EMAIL required type=email></div><div class="clear foot" id=mce-responses><div class=response id=mce-error-response style=display:none></div><div class=response id=mce-success-response style=display:none></div></div><div aria-hidden=true style=position:absolute;left:-5000px>/* real people should not fill this in and expect good things - do not remove this or risk form bot signups */ <input name=b_f0d9bfa6188cdcc67890a07f6_8a0ca536e8 tabindex=-1></div><input value="Subscribe to the Newsletter" class=send-btn id=mc-embedded-subscribe name=subscribe type=submit></form></div></div></div></div></section><div class=footer><div class=container><div class=footer-cnt><p class=left>Â© Python For The Lab <span class=current-year>2023</span><p class=center><a href=http://creativecommons.org/licenses/by-nc-sa/4.0/ rel=license> <img alt="Creative Commons License" src=https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png style=border:0></a>.<p class=right><a href=https://pythonforthelab.com/cookie-policy>Cookie Policy</a> <a href=https://pythonforthelab.com/privacy-policy>Privacy Policy</a></div></div></div><script src=https://pythonforthelab.com/theme/js/prism.js></script><script src=https://files.stork-search.net/releases/v1.5.0/stork.js></script><script>stork.register("sitesearch","https://pythonforthelab.com/search-index.st")</script>