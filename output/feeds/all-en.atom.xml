<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Python For The Lab</title><link href="https://www.pythonforthelab.com/" rel="alternate"></link><link href="https://www.pythonforthelab.com/feeds/all-en.atom.xml" rel="self"></link><id>https://www.pythonforthelab.com/</id><updated>2021-03-27T00:00:00+01:00</updated><entry><title>Instructions to build the Python for the Lab DAQ</title><link href="https://www.pythonforthelab.com/blog/instructions-to-build-the-python-for-the-lab-daq/" rel="alternate"></link><published>2021-03-27T00:00:00+01:00</published><updated>2021-03-27T00:00:00+01:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2021-03-27:/blog/instructions-to-build-the-python-for-the-lab-daq/</id><summary type="html">&lt;p&gt;The PFTL DAQ is the ideal companion to follow the book &lt;a href="https://www.pythonforthelab.com/books/"&gt;Python for the Lab&lt;/a&gt;. Building the device itself is not part of the book because it focuses on Python best practices and not on lower-level electronics. In this article, we will quickly see how to build the device to …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The PFTL DAQ is the ideal companion to follow the book &lt;a href="https://www.pythonforthelab.com/books/"&gt;Python for the Lab&lt;/a&gt;. Building the device itself is not part of the book because it focuses on Python best practices and not on lower-level electronics. In this article, we will quickly see how to build the device to follow the book to its fullest. &lt;/p&gt;
&lt;h2&gt;Materials&lt;/h2&gt;
&lt;p&gt;The device is built on an &lt;strong&gt;Arduino DUE&lt;/strong&gt;, which can be purchased directly from &lt;a href="https://store.arduino.cc/arduino-due"&gt;Arduino's webstore&lt;/a&gt; or any other supplier. The DUE choice was driven because it is the only board that provides analog outputs (also known as DAC). However, boards evolve over time, and there may be others available with the same options. &lt;/p&gt;
&lt;p&gt;Arduino also provides a program called &lt;a href="https://www.arduino.cc/en/software"&gt;Arduino IDE&lt;/a&gt;, which we need to load programs to the boards. However, the DUE is not available by default. To add the DUE to the list of compatible boards, we'll need to open the board manager. &lt;/p&gt;
&lt;p&gt;The board manager is under the menu Tools/Boards:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Arduino Board Manager menu" src="attachments/arduino_boards.png"&gt;]&lt;/p&gt;
&lt;p&gt;And the board manager will allow us to install the DUE:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Installing the Due board on the arduino IDE" src="attachments/arduino_board_manager.png"&gt;&lt;/p&gt;
&lt;p&gt;To work with the board, we must load a special code to make it behave as we want. The code is &lt;a href="https://github.com/PFTL/pythonforthelab/blob/458cd588e7d593dca15b58db1ab189e68d718c6b/extras/arduino_firmware/arduino_firmware.ino"&gt;hosted here&lt;/a&gt;. Saving it to a file on the computer is enough. &lt;/p&gt;
&lt;p&gt;Open the code with the Arduino IDE, connect the board to the computer using the programming port (the USB port closest to the power jack). Select the board under Tools/Boards and the port on which it is connected. The last step is to click the &lt;em&gt;Upload&lt;/em&gt; button, and you are ready to go. &lt;/p&gt;
&lt;h3&gt;Extra materials&lt;/h3&gt;
&lt;p&gt;Besides the DUE, there are some &lt;strong&gt;small electronics required&lt;/strong&gt;. We need a small breadboard. Something like this is enough, but anything will work:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Small electronics breadboard" src="attachments/PC01771-40.jpg"&gt;&lt;/p&gt;
&lt;p&gt;We also need one LED. The color does not matter, 3 jumper cables that make it easy to connect the Arduino and the breadboard, and one resistance of 220 Ohm. Overall, what we want to build looks like the following:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Schematics of the circuit for Python for the Lab" src="attachments/PFTL_DAQ_Schematic_bb.png"&gt;&lt;/p&gt;
&lt;p&gt;Sourcing the electronics components will depend on the country. There are some suppliers like Farnell and RS Electronics that may be available. Still, in general, any electronics do-it-yourself shop will be able to provide the elements. &lt;/p&gt;
&lt;h2&gt;Understanding the Arduino code&lt;/h2&gt;
&lt;p&gt;Although not part of the book, it can be useful to look at the code loaded to the Arduino. The approach is very similar to what was discussed in &lt;a href="https://www.pythonforthelab.com/blog/how-control-arduino-computer-using-python/"&gt;this article&lt;/a&gt;. Besides some boilerplate initialization of variables, we encounter the &lt;code&gt;setup&lt;/code&gt; function. This function is called only once when the Arduino is boot up, which makes it the ideal place to initialize the communication with the computer or set the initial value of some outputs:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;void setup() {
  Serial.begin(9600);
  while (!Serial);
  analogWriteResolution(12);
  analogWrite(DAC0, 0);
  analogWrite(DAC1, 0);
  pinMode(ledPin, OUTPUT);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This already describes what the program will do: we will communicate through the serial port using a speed of 9600. We wait for the serial to become available before continuing. We set the resolution of the DAC to 12 bit and set both DAC ports to 0. The last bit is telling the board to use a specific digital pin as an output. &lt;/p&gt;
&lt;p&gt;What is more important is what happens in the &lt;code&gt;loop&lt;/code&gt; function. This function runs forever in an infinite &lt;em&gt;loop&lt;/em&gt; and therefore is where all the exchange of information and true workings of the Arduino will happen. We start by checking if there's data available on the serial port and we store it in a variable called &lt;code&gt;Comm&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;  while (Serial.available() &amp;gt; 0 ) {
    char value = Serial.read();
    Comm += value;
    if (value == '\n') {
      isData = true;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The variable &lt;code&gt;Comm&lt;/code&gt; will tell the device what do we expect from it. If the message is &lt;code&gt;IDN&lt;/code&gt;, for example, we are expecting the device to identify itself, which it does:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;    if (Comm.startsWith(&amp;quot;IDN&amp;quot;)) {
      Serial.print(&amp;quot;General DAQ Device built by Uetke. v.1.2019&amp;quot;);
      Serial.print(&amp;quot;\n&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another possible command is &lt;code&gt;IN:CH1&lt;/code&gt;to read the analog value on channel 1, which is also what the device does: &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;else if (Comm.startsWith(&amp;quot;IN&amp;quot;)) {
      channel = Comm[5];
      input = channel.toInt();
      val = analogRead(input);
      Serial.print(val);
      Serial.print(&amp;quot;\n&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;</content><category term="blog"></category><category term="DAQ"></category><category term="PFTL"></category><category term="darduino due"></category></entry><entry><title>Using slots in Python: limit dynamic attribute creation and improve speed</title><link href="https://www.pythonforthelab.com/blog/using-slots-in-python-limit-dynamic-attribute-creation-and-improve-speed" rel="alternate"></link><published>2021-03-21T00:00:00+01:00</published><updated>2021-03-21T00:00:00+01:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2021-03-21:/blog/using-slots-in-python-limit-dynamic-attribute-creation-and-improve-speed</id><summary type="html">&lt;p&gt;When we create classes, one of the biggest challenges is understanding how to handle dynamic attribute creation. Slots have the benefit of limiting attribute creation at runtime. In this article, we will explore how slots work, including a quick overview of how classes store attributes internally. &lt;/p&gt;
&lt;h2&gt;Dynamic attribute creation&lt;/h2&gt;
&lt;p&gt;One …&lt;/p&gt;</summary><content type="html">&lt;p&gt;When we create classes, one of the biggest challenges is understanding how to handle dynamic attribute creation. Slots have the benefit of limiting attribute creation at runtime. In this article, we will explore how slots work, including a quick overview of how classes store attributes internally. &lt;/p&gt;
&lt;h2&gt;Dynamic attribute creation&lt;/h2&gt;
&lt;p&gt;One of the advantages of objects in Python is that they can store any number of attributes. Moreover, these attributes can be created dynamically when the program runs and not only when the class is defined. Let's start with a simple example to get the gist of it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Person:
    def __init__(self, name):
        self.name = name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The class &lt;code&gt;Person&lt;/code&gt; can be used like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; me = Person('Aquiles')
&amp;gt;&amp;gt;&amp;gt; print(me.name)
'Aquiles'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The class &lt;code&gt;Person&lt;/code&gt; creates an attribute &lt;code&gt;name&lt;/code&gt; when we instantiate it, and we assign any value we want. In the example above, we used &lt;code&gt;'Aquiles'&lt;/code&gt;. We print the attribute &lt;code&gt;name&lt;/code&gt; of the object &lt;code&gt;me&lt;/code&gt; to show that it is behaving as expected. Python objects allow us to modify the attribute or to create new attributes:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; me.name = 'John'
&amp;gt;&amp;gt;&amp;gt; me.last_name = 'Doe'
&amp;gt;&amp;gt;&amp;gt; print(me.name)
'John'
&amp;gt;&amp;gt;&amp;gt; print(me.last_name)
'Doe'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, we replace the value of &lt;code&gt;name&lt;/code&gt; at runtime. Later, we create a new attribute, &lt;code&gt;last_name&lt;/code&gt; that is not part of the original design of &lt;code&gt;Person&lt;/code&gt;. This pattern can be both handy and dangerous. Imagine we have a complex object, for example, to control a camera. We define an attribute &lt;code&gt;exposure_time&lt;/code&gt; when we develop the &lt;code&gt;Camera&lt;/code&gt; class. If later on we make a mistake and use &lt;code&gt;exp_time&lt;/code&gt; instead, there will be no warning, and the error can go unnoticed until it is too late:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; camera = Camera()
&amp;gt;&amp;gt;&amp;gt; camera.exposure_time = '5ms'
&amp;gt;&amp;gt;&amp;gt; camera.exp_time = '10ms'
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Quick intro to slots&lt;/h2&gt;
&lt;p&gt;Limiting the creation of attributes at runtime can be a great advantage, and Python offers a straightforward syntax to achieving it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Person:
    __slots__ = 'name'
    def __init__(self, name):
        self.name = name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And this time, if we run the same coda we ran earlier, we will get a different outcome:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; me = Person('Aquiles')  
&amp;gt;&amp;gt;&amp;gt; print(me.name)  
'Aquiles'
&amp;gt;&amp;gt;&amp;gt; me.name = 'John'  
&amp;gt;&amp;gt;&amp;gt; print(me.name)  
'John'
&amp;gt;&amp;gt;&amp;gt; me.last_name = 'Doe'
Traceback (most recent call last):
  File &amp;quot;/Users/aquiles/Documents/Web/pftl_code/code/_slots/aa.py&amp;quot;, line 11, in &amp;lt;module&amp;gt;
    me.last_name = 'Doe'
AttributeError: 'Person' object has no attribute 'last_name'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We could alter the &lt;code&gt;name&lt;/code&gt; attribute at runtime, but &lt;code&gt;last_name&lt;/code&gt; gave and &lt;code&gt;AttributeError&lt;/code&gt;. If we modify the slots to include &lt;code&gt;last_name&lt;/code&gt;, then the output would be different:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Person:
    __slots__ = 'name', 'last_name'
    def __init__(self, name):
        self.name = name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And this time there will be no &lt;code&gt;AttributeError&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; me = Person('Aquiles')
&amp;gt;&amp;gt;&amp;gt;me.last_name = 'Doe'
&amp;gt;&amp;gt;&amp;gt; print(me.last_name)
'Doe'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the examples above, it is clear that we can limit the dynamic creation of attributes by using slots. However, it is essential to note that classes tend to get much more sophisticated and store many different attributes. Keeping &lt;code&gt;__slots__&lt;/code&gt; up to date can quickly become a hassle. &lt;/p&gt;
&lt;p&gt;Two things are worth noting. One is that class attributes (i.e., attributes defined at a class level) automatically become read-only:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Person:
    __slots__ = 'name', 'last_name'
    age = 35

    def __init__(self, name):
        self.name = name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And if we try to change the age after instantiating the class we get the following error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; me = Person('Aquiles')
&amp;gt;&amp;gt;&amp;gt; print(me.age)
35
&amp;gt;&amp;gt;&amp;gt; me.age = 50
Traceback (most recent call last):
  File &amp;quot;/Users/aquiles/Documents/Web/pftl_code/code/_slots/aa.py&amp;quot;, line 16, in &amp;lt;module&amp;gt;
    me.age = 50
AttributeError: 'Person' object attribute 'age' is read-only
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We'll dive more into the reasons behind this behavior in the following section. &lt;/p&gt;
&lt;h2&gt;Where are attributes stored, the &lt;strong&gt;dict&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Objects must remember the attributes to which they have access to retrieve them or give an error if they can't be found. In Python, this is done through a dictionary called &lt;code&gt;__dict__&lt;/code&gt;. We can see how it works with the same example we used earlier:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Person:
    birth_year = 1986
    def __init__(self, age, name):
        self.age = age
        self.name = name

    def print_name(self):
        print(self.name)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can inspect the dictionary of both the Person class and of one of its instances:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; print(Person.__dict__)
{'__module__': '__main__', 'birth_year': 1986, '__init__': &amp;lt;function Person.__init__ at 0x7fd890028ee0&amp;gt;, 'print_name': &amp;lt;function Person.print_name at 0x7fd89046ca60&amp;gt;, '__dict__': &amp;lt;attribute '__dict__' of 'Person' objects&amp;gt;, '__weakref__': &amp;lt;attribute '__weakref__' of 'Person' objects&amp;gt;, '__doc__': None}
&amp;gt;&amp;gt;&amp;gt; me = Person(35, 'Aquiles')
&amp;gt;&amp;gt;&amp;gt; print(me.__dict__)
{'age': 35, 'name': 'Aquiles'}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note, first, that we are not using slots; it is a plain class. The dictionary of the class stores references to its attributes &lt;code&gt;birth_year&lt;/code&gt; and the methods &lt;code&gt;__init__&lt;/code&gt; and &lt;code&gt;print_name&lt;/code&gt;. It has no information about &lt;code&gt;age&lt;/code&gt; or &lt;code&gt;name&lt;/code&gt; because these attributes get created only &lt;em&gt;after&lt;/em&gt; the class is instantiated. &lt;/p&gt;
&lt;p&gt;On the other hand, the dictionary of the object &lt;code&gt;me&lt;/code&gt; has both &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt; but nothing else. If we would like to access the value stored in the dictionary, we can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;me.__dict__['name']
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we add slots, however, things will change. Let's what happens to the dictionary in the following example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Person:
    __slots__ = 'age', 'name'
    birth_year = 1986

    def __init__(self, age, name):
        self.age = age
        self.name = name

    def print_name(self):
        print(self.name)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We kept the &lt;code&gt;birth_year&lt;/code&gt; class attribute, but we added the slots for &lt;code&gt;age&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt;. If we repeat what we did earlier:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; print(Person.__dict__)
{'__module__': '__main__', '__slots__': ('age', 'name'), 'birth_year': 1986, '__init__': &amp;lt;function Person.__init__ at 0x7ffdf0118ee0&amp;gt;, 'print_name': &amp;lt;function Person.print_name at 0x7ffde032ba60&amp;gt;, 'age': &amp;lt;member 'age' of 'Person' objects&amp;gt;, 'name': &amp;lt;member 'name' of 'Person' objects&amp;gt;, '__doc__': None}
&amp;gt;&amp;gt;&amp;gt; me = Person(35, 'Aquiles')
&amp;gt;&amp;gt;&amp;gt; print(me.__dict__)
Traceback (most recent call last):
[...]
AttributeError: 'Person' object has no attribute '__dict__'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The only difference between the earlier code and this one is that we added the &lt;code&gt;__slots__&lt;/code&gt; class attribute. We can notice that the class dictionary is different. Now there are both &lt;code&gt;age': &amp;lt;member 'age' of 'Person' objects&amp;gt;&lt;/code&gt; and &lt;code&gt;'name': &amp;lt;member 'name' of 'Person' objects&amp;gt;&lt;/code&gt;. Moreover, if we explore the object &lt;code&gt;me&lt;/code&gt;, we see that it has no  &lt;code&gt;__dict__&lt;/code&gt;. It is fair, therefore, to ask where are these attributes stored, and the answer is close by:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; print(me.__slots__)
('age', 'name')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To wrap up what we have just seen, when we use slots, we create objects with no &lt;code&gt;__dict__&lt;/code&gt; associated with them, but rather a &lt;code&gt;__slots__&lt;/code&gt; tuple. It is a significant distinction since tuples are immutable in Python. Moreover, the attributes that we defined in the slots show directly on the class dictionary, and this was not the case before. &lt;/p&gt;
&lt;p&gt;We can explore a bit more this additions by looking at what their types are. For example, we can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; print(type(Person.__dict__['birth_year']))
&amp;lt;class 'int'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(type(Person.__dict__['age']))
&amp;lt;class 'member_descriptor'&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And this is the quid of the question regarding slots. When we define them in a class, they are automatically created as descriptors. We have written a &lt;a href="https://www.pythonforthelab.com/blog/data-descriptors-bringing-attributes-next-level/"&gt;complete article about descriptors&lt;/a&gt; that may be worth checking out to go deeper with the understanding. It is the reason why we get the read-only attributes if we don't specify them in the slots. &lt;/p&gt;
&lt;h3&gt;Adding the dictionary to the slots&lt;/h3&gt;
&lt;p&gt;We saw that when we define slots for a class, its objects do not have a &lt;code&gt;__dict__&lt;/code&gt; to store their attributes. Therefore, we could ask ourselves what would happen if we add the dictionary to the list of slots. Let's try it out:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Person:
__slots__ = 'age', 'name', '__dict__'

def __init__(self, age, name):
    self.age = age
    self.name = name
    self.birth_year = 1986
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we can now use it as we have always done:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; me = Person(35, 'Aquiles')
&amp;gt;&amp;gt;&amp;gt; print(me.__dict__)
{'birth_year': 1986}
&amp;gt;&amp;gt;&amp;gt; me.new_var = 10
&amp;gt;&amp;gt;&amp;gt; print(me.__dict__)
{'birth_year': 1986, 'new_var': 10}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have created a hybrid class in which some attributes are slots, and therefore they do not appear in the dictionary. However, since the class itself has a dictionary, we can dynamically create new attributes. Whether this pattern is useful (or even correct) can be subject to discussion. We are not going to engage with it right now. &lt;/p&gt;
&lt;h2&gt;Slots and inheritance&lt;/h2&gt;
&lt;p&gt;The final important topic to cover about slots is how they behave with inheritance. Let's start creating a new class that inherits from &lt;code&gt;Person&lt;/code&gt; and see what happens:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Person:
__slots__ = 'age', 'name'
def __init__(self, age, name):
    self.age = age
    self.name = name

class Student(Person):
    def __init__(self, age, name, course):
        super(Student, self).__init__(age, name)
        self.course = course
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the example above, &lt;code&gt;Studen&lt;/code&gt; inherits from &lt;code&gt;Person&lt;/code&gt; but it does not define new slots. Therefore, it will behave like any other class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; me = Student(35, 'Aquiles', 'Physics')    
&amp;gt;&amp;gt;&amp;gt; print(me.__dict__)
{'course': 'Physics'}
&amp;gt;&amp;gt;&amp;gt; me.new_var = 10
&amp;gt;&amp;gt;&amp;gt; print(me.__dict__)
{'course': 'Physics', 'new_var': 10}
&amp;gt;&amp;gt;&amp;gt; print(me.__slots__)
('age', 'name')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Student&lt;/code&gt; handles dynamic attribute creation, and we still have access to the slots defined in the parent class &lt;code&gt;age&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt;. This means that if we inherit from a class, we should not worry whether it defined slots or not. The child class will behave precisely as we design it to behave. &lt;/p&gt;
&lt;p&gt;The other possibility is to define slots in the child class but not in the parent class, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Person:
def __init__(self, age, name):
    self.age = age
    self.name = name

class Student(Person):
    __slots__ = 'course'
    def __init__(self, age, name, course):
        super(Student, self).__init__(age, name)
        self.course = course
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And, surprisingly, the code above still works:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; me = Student(35, 'Aquiles', 'Physics')
&amp;gt;&amp;gt;&amp;gt; print(me.__dict__)
{'age': 35, 'name': 'Aquiles'}
&amp;gt;&amp;gt;&amp;gt; me.new_var = 10
&amp;gt;&amp;gt;&amp;gt; print(me.__dict__)
{'age': 35, 'name': 'Aquiles', 'new_var': 10}
&amp;gt;&amp;gt;&amp;gt; print(me.__slots__)
course
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Therefore,  if either the parent or the child defines the &lt;code&gt;__dict__&lt;/code&gt;, then the objects will also have a dict and will be able to accept dynamically created attributes. The only way in which can leverage slots is if both parent and child define them:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Person:
    __slots__ = 'age', 'name'
    def __init__(self, age, name):
        self.age = age
        self.name = name

class Student(Person):
    __slots__ = 'course'
    def __init__(self, age, name, course):
        super(Student, self).__init__(age, name)
        self.course = course
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then we'll see the behavior that would be expected from having slots:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; me = Student(35, 'Aquiles', 'Physics')
&amp;gt;&amp;gt;&amp;gt; print(me.__slots__)
course
&amp;gt;&amp;gt;&amp;gt; me.new_var = 10
Traceback (most recent call last):
[...]
AttributeError: 'Student' object has no attribute 'new_var'
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Impact of slots on size and speed of code&lt;/h2&gt;
&lt;p&gt;One of the reasons behind adding slots to Python was to have faster attribute access. This was discussed in &lt;a href="https://python-history.blogspot.com/2010/06/inside-story-on-new-style-classes.html"&gt;this blog post&lt;/a&gt; from 2010, summarizing all the improvements done to classes. Essentially, slots were added to overcome potential impacts in performance. By defining slots, the programs can have a faster lookup of the data stored. Whether an increase of lookup times of around 15% impacts the overall code will depend on how often we perform the task. &lt;/p&gt;
&lt;p&gt;The other impact of slots is lower memory usage. Since slots prevent creating a dictionary and a &lt;em&gt;weakref&lt;/em&gt; (which didn't discuss in this article), each object created will require less memory. For code creating few hundreds of objects, the impact may be negligible. Still, if we are creating millions of objects, the effect can be tremendous. For example, &lt;a href="https://docs.sqlalchemy.org/en/14/changelog/migration_10.html#significant-improvements-in-structural-memory-use"&gt;SQLAlchemy has a measurable effect on the use of slots&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Conclusions: Deciding when is worth using slots&lt;/h2&gt;
&lt;p&gt;Slots are a feature worth keeping in mind when developing code and, more importantly, when studying other's code. Using them for speed and memory improvements is likely to be far-fetched for most programs. It is essential to keep in mind that if a program was optimized using slots, we could easily ruin those optimizations by careless inheritance. &lt;/p&gt;
&lt;p&gt;On the other hand, limiting the attribute creation at runtime can have a broad set of application contexts, even if it was not the original motivation for implementing slots in Python. For example, when developing code to control hardware, such as a camera, users may make mistakes such as using &lt;code&gt;exposure&lt;/code&gt; instead of &lt;code&gt;exposure_time&lt;/code&gt; to change a parameter. Due to dynamic attribute creation, there won't be any error shown on the screen. &lt;/p&gt;
&lt;p&gt;Slots are not the only way of solving these issues, but they are straightforward to implement. &lt;/p&gt;</content><category term="blog"></category><category term="classes"></category><category term="object oriented"></category><category term="dictionary"></category><category term="memory"></category><category term="slots"></category></entry><entry><title>Acquiring images from Basler Cameras</title><link href="https://www.pythonforthelab.com/blog/getting-started-with-basler-cameras" rel="alternate"></link><published>2021-02-27T00:00:00+01:00</published><updated>2021-02-27T00:00:00+01:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2021-02-27:/blog/getting-started-with-basler-cameras</id><summary type="html">&lt;p&gt;Basler offers a wide range of cameras that can be used for microscopy, computer vision, or even as security cameras. One of the cameras' advantages is that they come with a software development kit that makes them easy to integrate into our projects. Basler puts continuous effort into maintaining PyPylon …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Basler offers a wide range of cameras that can be used for microscopy, computer vision, or even as security cameras. One of the cameras' advantages is that they come with a software development kit that makes them easy to integrate into our projects. Basler puts continuous effort into maintaining PyPylon, the Python bindings for their drivers. This tutorial will focus on learning how to get started with the cameras and how to leverage the existing Pylon Viewer to speed up our development. &lt;/p&gt;
&lt;h2&gt;Installing&lt;/h2&gt;
&lt;p&gt;To work with Basler cameras using Python, we must install the PyPylon package, which is the Python wrapper for the Pylon SDK. Basler's team improved the installation scripts of the package in the last few months, and it is now possible to install like any other package:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install pypylon
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Older releases of the code required to install other dependencies first and then getting a release of pypylon from the &lt;a href="https://github.com/Basler/pypylon/releases"&gt;Github repository&lt;/a&gt;. This is still possible if we need to work with specific versions, for example, when maintaining legacy code. &lt;/p&gt;
&lt;p&gt;Although only PyPylon is required to work with the cameras, we will also use the &lt;a href="https://www.baslerweb.com/en/sales-support/downloads/software-downloads/#type=pylonsoftware;language=all;version=all"&gt;Pylon software suite&lt;/a&gt;, which includes Pylon Viewer, a program to quickly acquire images from the cameras. On the download page, be sure to select the package for your operating system and architecture. &lt;/p&gt;
&lt;p&gt;Pylon Viewer allows us to test the camera, acquire images, and configure it. Trying whether we can acquire images is important to rule out other problems. For example, on Linux systems accessing USB ports may require additional permissions. Pylon Viewer is also a great starting point for finding out the names of the functions and parameters we may need to change in our programs. &lt;/p&gt;
&lt;h3&gt;Problems with PyPylon installation&lt;/h3&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;PyPylon is evolving quickly, and some of the issues I highlight here may disappear on later releases. In any case, I have decided to keep them since they may provide valuable insight to some programmers.  &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;I have found that sometimes there is a mismatch between the latest Pylon version and the released PyPylon wheel available to download. Even if this does not raise problems during installation, we may face an error like the following when running the examples of this tutorial:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;ImportError: cannot import name '_pylon' 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The best solution is to &lt;a href="https://github.com/basler/pypylon"&gt;download the PyPylon code&lt;/a&gt;, and install it locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ python setup.py install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Depending on your operating system, there may be another error associated with it. In Linux, Pylon is expected in the folder &lt;code&gt;/opt/pylon5&lt;/code&gt;, but newer versions of Pylon are installed on &lt;code&gt;/opt/pylon&lt;/code&gt;. The simplest solution is to create a system variable to point the installer to the right folder:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ export PYLON_ROOT=/opt/pylon
$ python setup.py install
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Getting Started&lt;/h2&gt;
&lt;p&gt;When getting started, we must make sure to identify the camera we want to work with. This is not only useful for practical matters, but it is also the first step to start understanding the patterns that drivers impose. We can run the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from pypylon import pylon


tl_factory = pylon.TlFactory.GetInstance()
devices = tl_factory.EnumerateDevices()
for device in devices:
    print(device.GetFriendlyName())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It generates a list of the cameras connected to our computer, like what we see with the PylonViewer program. The output will depend on what camera is connected to the computer, but it will look like the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;Basler a2A1920-160umBAS (40063823)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let's start by understanding the code that generated the output. It begins by creating a &lt;em&gt;transport layer&lt;/em&gt; instance and enumerating the devices to which it has access. According to the manual, the transport layer is an abstraction of the physical connection between the camera and the computer (i.e., USB, Camera Link, etc.). Its primary purpose is to find and manage the life cycle of the cameras. The method &lt;code&gt;EnumerateDevices&lt;/code&gt; returns a tuple containing information of each connected camera. &lt;/p&gt;
&lt;p&gt;Bear in mind that PyPylon is built using Swig, a library that automatically wraps C code into Python. If we printed &lt;code&gt;device&lt;/code&gt; instead of its friendly name, we would get an output like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;quot;&amp;lt;pypylon.pylon.DeviceInfo; proxy of &amp;lt;Swig Object of type 'Pylon::CDeviceInfo *' at 0x7fb7c3cd53f0&amp;gt; &amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which is not particularly useful. Each object returned by the enumeration of the transport layer allows for the unique identification of the camera. This means that the information contained within it is all we need to start communicating with a camera. Other methods that may be useful to identify a camera are: &lt;code&gt;GetFullName()&lt;/code&gt; which returns a unique code like &lt;code&gt;2676:ba05:3:2:10&lt;/code&gt;, or &lt;code&gt;GetSerialNumber()&lt;/code&gt; which returns a number like &lt;code&gt;40063823&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;In many cases, we have only one camera, and the rest of the article will proceed on that assumption. If it is not the case, we can address the camera we want by using its unique properties. &lt;/p&gt;
&lt;h2&gt;Acquiring an Image&lt;/h2&gt;
&lt;p&gt;If we are working with a camera, the first thing we may want to do is to acquire an image. We can create an &lt;code&gt;InstantCamera&lt;/code&gt; object by running the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;tl_factory = pylon.TlFactory.GetInstance()
camera = pylon.InstantCamera()
camera.Attach(tl_factory.CreateFirstDevice())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which consists of two steps. After getting the instance of the transport layer, we create an &lt;code&gt;InstantCamera&lt;/code&gt; object. Basler provides these objects as a way of simplifying our work with their cameras, including handling the device life cycle, making event callbacks, and physical device removal. Suppose we are developing a highly specialized application. In that case, we may want to dive into Pylon's &lt;em&gt;Device objects&lt;/em&gt;, which are beyond this article's scope. &lt;/p&gt;
&lt;p&gt;Once the &lt;code&gt;InstantCamera&lt;/code&gt; is instantiated, we proceed to attach the first available camera to it. Note that the code above is transparent to the underlying data transport layer. We can use USB or GigE cameras with the same pattern. It is also important to point out that the transport layer is responsible for creating the actual device while &lt;code&gt;camera&lt;/code&gt; is a convenient interface. The connection between the wrapper object &lt;code&gt;InstantCamera&lt;/code&gt; and the actual device happens when we &lt;code&gt;Attach&lt;/code&gt; it. &lt;/p&gt;
&lt;p&gt;To acquire an image, we must follow few steps that are self-explanatory:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;camera.Open()
camera.StartGrabbing(1)
grab = camera.RetrieveResult(2000, pylon.TimeoutHandling_Return)
if grab.GrabSucceeded():
    img = grab.GetArray()
    print(f'Size of image: {img.shape}')
camera.Close()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We start by opening the camera. At this stage, we establish the communication with the device, and Pylon takes care of applying some basic configuration. When we &lt;code&gt;StartGrabbing&lt;/code&gt; with a single integer argument, we tell Pylon the number of frames we want to acquire. When the camera reaches that number of frames, it will stop acquiring new ones. This method is one of the convenience methods provided by the &lt;code&gt;InstantCamera&lt;/code&gt; objects. &lt;/p&gt;
&lt;p&gt;In the code above, we grab only one frame. We retrieve the result using a timeout of 2000 milliseconds. We specify that if 2 seconds pass and there is no result, it would simply return. Another option would have been using &lt;code&gt;TimeoutHandling_ThrowException&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;We check that the grab actually worked by using the &lt;code&gt;GrabSucceeded&lt;/code&gt; method. Then we get the actual data using the &lt;code&gt;GetArray&lt;/code&gt; method. The resulting &lt;code&gt;img&lt;/code&gt; is a numpy array. We print the shape of the image and close the camera. This is a minimal example to get started, but nothing limits us to show the image, save it, etc. In any case, the most essential step is to get data from the camera. &lt;/p&gt;
&lt;h2&gt;Changing Parameters&lt;/h2&gt;
&lt;p&gt;Once we can read from a device, the second most important step is to change the acquisition parameters. In the case of a camera, the exposure time is probably, one of the most important ones. The &lt;code&gt;InstantCamera&lt;/code&gt; interface allows us to change it with the following syntax:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;camera.ExposureTime.SetValue(50000)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The syntax is pretty clear. If we want to change &lt;code&gt;ExposureTime&lt;/code&gt;, we can use a method called &lt;code&gt;SetValue&lt;/code&gt; and provide the value in microseconds (see below for more discussion on units). If we check the Pylon manual, this is the pattern we will find for the camera's parameters. However, since we are using &lt;strong&gt;PyPylon&lt;/strong&gt;, we can also make use of an alternative syntax:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;camera.ExposureTime = 50000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both examples generate the same effect and show the difference between &lt;a href="https://www.aquiles.me/functional_or_imperative_programming/"&gt;functional or imperative programming&lt;/a&gt;. I, personally, believe the first one is clearer since it will always raise an error if, for example, we use &lt;code&gt;Exposure&lt;/code&gt; instead of &lt;code&gt;ExposureTime&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Getting node information&lt;/h3&gt;
&lt;p&gt;One of the reasons for favoring the imperative setting of the exposure time (i.e., using &lt;code&gt;SetValue&lt;/code&gt;) is that &lt;code&gt;ExposureTime&lt;/code&gt; is more complex than a simple number attribute of the camera. When setting values to a device, one common concern is knowing the limits and the units of each parameter. Pylon, in that regard, is very transparent and consistent. &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;camera.Open()
print(camera.ExposureTime.GetUnit())
print(camera.ExposureTime.GetValue())
print(camera.ExposureTime.GetMin())
print(camera.ExposureTime.GetMax())
print(camera.ExposureTime.Unit)
print(camera.ExposureTime.Value)
print(camera.ExposureTime.Min)
print(camera.ExposureTime.Max)
camera.Close()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is possible to get the units of the &lt;code&gt;ExposureTime&lt;/code&gt;and the current value, the minimum, and the maximum. The code above shows the two ways of getting the information, using &lt;code&gt;GetUnit&lt;/code&gt; or attributes like &lt;code&gt;Unit&lt;/code&gt;. Again, this is a matter of personal preference and consistency through more extensive projects. &lt;/p&gt;
&lt;h2&gt;PylonViewer as the documentation entry point&lt;/h2&gt;
&lt;p&gt;The examples above are a great starting point, but the main problem is that they are limited. As soon as we want to do something slightly more complex, we will need to use a different approach. For example, we know the minimum and maximum value of the exposure time, but how do we know the minimum difference between possible values? Fortunately, Basler bundles the PylonViewer with their software package. Let's see what information it provides when we select the exposure time:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./_basler/pylon_viewer_01.png"&gt;&lt;/p&gt;
&lt;p&gt;For every parameter that we can change in the camera, PylonViewer tells us what method should be used to change and retrieve the value. But this is not the only information that it provides. If we open the Feature Properties panel (must be selected under the Window menu), we can also see a table with more information for that specific property:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./_basler/pylon_viewer_02.png"&gt;&lt;/p&gt;
&lt;p&gt;The PylonViewer does not allow us to see how to retrieve that information. Still, if it is on the table, it means it can be programmatically accessed. The PylonViewer gives us access to the Programmer's Guide if we click on the &lt;em&gt;Help menu&lt;/em&gt;. Normally, the C++ guide is the easiest to translate into Python code. If we search for &lt;code&gt;ExposureTime&lt;/code&gt; we will get several matches, but any &lt;code&gt;Member List&lt;/code&gt; would be a good starting point. The information on &lt;code&gt;ExposureTime&lt;/code&gt; may be a bit vague:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./_basler/pylon_manual_exposure_01.png"&gt;&lt;/p&gt;
&lt;p&gt;But it provides a significant hint (highlighted in red above). The Exposure time is not an ordinary number, but a &lt;code&gt;Pylon::IFloatEx&lt;/code&gt;. Without entering too much into details, if we click on it, we get the information we were looking for:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./_basler/pylong_manual_exposure_02.png"&gt; &lt;/p&gt;
&lt;p&gt;Every parameter that belongs to this class will have plenty of available information. The exposure time is only one of them. For basic applications, it may be slightly far-fetched. Still, it is important to learn how to navigate the documentation to get the relevant information and translate it to Python. &lt;/p&gt;
&lt;h2&gt;Acquiring in free-run mode&lt;/h2&gt;
&lt;p&gt;With cameras, often we want to acquire images continuously, not just one frame. Free-run means that the camera will acquire frames one after the other until we tell it to stop. With &lt;code&gt;InstantCamera&lt;/code&gt;, this can be achieved by using the method &lt;code&gt;StartGrabbing&lt;/code&gt; without specifying a maximum number of frames:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;camera.Open()
camera.StartGrabbing(pylon.GrabStrategy_OneByOne)
i = 0
print('Starting to acquire')
t0 = time.time()
while camera.IsGrabbing():
    grab = camera.RetrieveResult(100, pylon.TimeoutHandling_ThrowException)
    if grab.GrabSucceeded():
        i += 1
    if i == 100:
        break

print(f'Acquired {i} frames in {time.time()-t0:.0f} seconds')
camera.Close()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, &lt;code&gt;StartGrabbing&lt;/code&gt; receives a strategy of &lt;code&gt;OneByOne&lt;/code&gt;, which is equivalent to first-in, first-out. Frames are acquired in order and retrieved in order. We use the method &lt;code&gt;IsGrabbing&lt;/code&gt; to check that the camera is actually acquiring data. Note that we are using only 100 milliseconds of timeout when retrieving the result. If the exposure time is longer than that, Pylon will raise an error. We can check it by combining this example with the previous one. &lt;/p&gt;
&lt;p&gt;If grabbing data was successful, we increase a counter. We stop the loop if we reach 100 frames, but any other approach to stop the program at a given point is valid. It is important to note that we stop the loop, but not the grabbing itself. The grabbing stops when the camera is closed, courtesy of the &lt;code&gt;InstantCamera&lt;/code&gt; object. We can also use &lt;code&gt;StopGrabbing&lt;/code&gt; to stop the camera acquisition:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;camera.Open()
camera.StartGrabbing(pylon.GrabStrategy_OneByOne)
i = 0
print('Starting to acquire')
t0 = time.time()
while camera.IsGrabbing():
    grab = camera.RetrieveResult(100, pylon.TimeoutHandling_ThrowException)
    if grab.GrabSucceeded():
        i += 1
    if i == 100:
        camera.StopGrabbing()
        break

print(f'Acquired {i} frames in {time.time()-t0:.0f} seconds')
camera.Close()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Timeout when retrieving the result&lt;/h2&gt;
&lt;p&gt;In the examples we've seen so far, we have set everything to avoid problems. However, we are one step away from getting into trouble. We are using an exposure time of 50ms and a timeout of 100ms when retrieving the result. It is worth exploring what would happen if the timeout is shorter than the exposure time. &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;camera.Open()
camera.ExposureTime = 105000  # in us
camera.StartGrabbing(pylon.GrabStrategy_OneByOne)
grab = camera.RetrieveResult(100, pylon.TimeoutHandling_ThrowException)
if grab.GrabSucceeded():
    print('Grab succeded')

camera.Close()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we run the code above, we see that many times it runs fine. Note that the difference between exposure time and timeout is only 5ms. If there's a slight delay between starting and retrieving results, it is enough to pass through. If we try to acquire a couple of frames in a row, we'll see the problem:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;camera.Open()
camera.ExposureTime = 105000
camera.StartGrabbing(pylon.GrabStrategy_OneByOne)
for i in range(10):
    grab = camera.RetrieveResult(100, pylon.TimeoutHandling_ThrowException)
    if grab.GrabSucceeded():
        print('Grab succeded')

camera.Close()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code above will generate an output like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;Traceback (most recent call last):
  File &amp;quot;ac.py&amp;quot;, line 17, in &amp;lt;module&amp;gt;
    grab = camera.RetrieveResult(100, pylon.TimeoutHandling_ThrowException)
  File &amp;quot;C:\Users\aquic\.conda\envs\disper\lib\site-packages\pypylon\pylon.py&amp;quot;, line 3458, in RetrieveResult
    return _pylon.InstantCamera_RetrieveResult(self, *args)
_genicam.TimeoutException: Grab timed out. : TimeoutException thrown (file 'instantcameraimpl.h', line 1064)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is expected since we are using the option &lt;code&gt;pylon.TimeoutHandling_ThrowException&lt;/code&gt;. We can also try to use the other option, &lt;code&gt;TimeoutHandling_Return&lt;/code&gt;, in which case we would get this output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;Traceback (most recent call last):
  File &amp;quot;ac.py&amp;quot;, line 18, in &amp;lt;module&amp;gt;
    if grab.GrabSucceeded():
  File &amp;quot;C:\Users\aquic\.conda\envs\disper\lib\site-packages\pypylon\pylon.py&amp;quot;, line 2229, in GrabSucceeded
    return _pylon.GrabResult_GrabSucceeded(self)
_genicam.RuntimeException: No grab result data is referenced. Cannot access NULL pointer. : RuntimeException thrown (file 'grabresultptr.cpp', line 84)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both snippets result in exceptions, but they have a very different origin. On the first one, it is the &lt;code&gt;RetrieveResult&lt;/code&gt; method that raises the exception, while in the second is the &lt;code&gt;GrabSucceeded&lt;/code&gt;. For the first pattern, we can use a &lt;code&gt;try... except&lt;/code&gt; block to catch the exception. For the second example, note that the error message states &lt;code&gt;Cannot access NULL pointer&lt;/code&gt;. This means that grab is actually NULL. We can therefore use another approach to deal with it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;if grab and grab.GrabSucceeded():
    print('Grab succeded')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It must be clear that &lt;code&gt;if grab&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; only when the RetrieveResult didn't timeout. On the other hand, Python tests if-statements sequentially. It will first check &lt;code&gt;if grab&lt;/code&gt; and &lt;em&gt;only&lt;/em&gt; if it passes, it checks for &lt;code&gt;GrabSucceeded()&lt;/code&gt;. In this way, we can quickly prevent the error without try-excepts. &lt;/p&gt;
&lt;h2&gt;Using callbacks&lt;/h2&gt;
&lt;p&gt;Python programmers often do not use callbacks, but they can be a useful pattern and worth discussing them for the options they offer. The idea of a callback is that we can specify what function gets executed when an action finishes. For cameras, we can think of when a frame is acquired or after the camera is initialized. Pylon implements these ideas through event handlers, a specific type of class that defines some specific methods. Let's develop a basic one so we can start exploring the options:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class EventPrinter(pylon.ConfigurationEventHandler):
    def OnAttach(self, camera):
        print(f'Before attaching the camera {camera}')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The name, &lt;code&gt;EventPrinter&lt;/code&gt; is arbitrary, but the method &lt;code&gt;OnAttach&lt;/code&gt; is defined in the Pylon manual. As the name suggests, this method will be executed after a camera is attached, and it takes one argument: &lt;code&gt;camera&lt;/code&gt;. In order to use this event handler, we must register it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;tl_factory = pylon.TlFactory.GetInstance()
camera = pylon.InstantCamera()
camera.RegisterConfiguration(EventPrinter(), pylon.RegistrationMode_Append, pylon.Cleanup_Delete)

camera.Attach(tl_factory.CreateFirstDevice())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code above is enough to start understanding how to use callbacks. Note that we used an instance of the &lt;code&gt;EventPrinter&lt;/code&gt; which defines a method &lt;code&gt;OnAttach&lt;/code&gt;. We used the &lt;code&gt;RegistrionMode_Append&lt;/code&gt; that determines where the event handler will be placed related to other handlers present. In this case, it will be added &lt;em&gt;after&lt;/em&gt;. Finally, we delete the configuration when we are done, and the camera is cleaned up. &lt;/p&gt;
&lt;p&gt;The event handler is not limited to the moment in which we attach the camera. There are many other possibilities:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class EventPrinter(pylon.ConfigurationEventHandler):
    def OnAttach(self, camera):
        print(f'Before attaching the camera {camera}')

    def OnAttached(self, camera):
        print(f'Attached: {camera.GetDeviceInfo()}')

    def OnOpen(self, camera):
        print('Before opening')

    def OnOpened(self, camera):
        print('After Opening')

    def OnDestroy(self, camera):
        print('Before destroying')

    def OnDestroyed(self, camera):
        print('After destroying')

    def OnClosed(self, camera):
        print('Camera Closed')

    def OnDetach(self, camera):
        print('Detaching')

    def OnGrabStarted(self, camera):
        print('Grab started')
        time.sleep(2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can see a great level of control at every stage of the camera lifecycle, and we have access to the camera itself. The names of the methods refer to the moment right before or right after an action happens. For example, &lt;code&gt;OnOpen&lt;/code&gt; is executed right before the camera is opened and &lt;code&gt;OnOpened&lt;/code&gt; right after. With this pattern, we can, for example, define initial parameters for the camera, such as the exposure time or gain, so that it always starts the same way. We can use this approach to let other parts of our program know when a camera is attached, starts grabbing, or is destroyed. &lt;/p&gt;
&lt;p&gt;We can think about callbacks in the same way we think about &lt;a href="https://www.pythonforthelab.com/blog/step-by-step-guide-to-building-a-gui/#signals-and-slots-in-qt"&gt;signals and slots in Qt&lt;/a&gt;. They offer similar possibilities and allow us to connect different parts of a program in a very flexible way. &lt;/p&gt;
&lt;p&gt;Another option that Pylon has is to use the image handler. This simple example makes it clear how it can be used:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class ImageEventPrinter(pylon.ImageEventHandler):
    def OnImagesSkipped(self, camera, countOfSkippedImages):
        print(&amp;quot;OnImagesSkipped event for device &amp;quot;, camera.GetDeviceInfo().GetModelName())
        print(countOfSkippedImages, &amp;quot; images have been skipped.&amp;quot;)
        print()

    def OnImageGrabbed(self, camera, grabResult):
        print(&amp;quot;OnImageGrabbed event for device &amp;quot;, camera.GetDeviceInfo().GetModelName())

        # Image grabbed successfully?
        if grabResult.GrabSucceeded():
            print(&amp;quot;SizeX: &amp;quot;, grabResult.GetWidth())
            print(&amp;quot;SizeY: &amp;quot;, grabResult.GetHeight())
            img = grabResult.GetArray()
            print(&amp;quot;Gray values of first row: &amp;quot;, img[0])
            print()
        else:
            print(&amp;quot;Error: &amp;quot;, grabResult.GetErrorCode(), grabResult.GetErrorDescription())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we register it in the camera with the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;camera.RegisterImageEventHandler(ImageEventPrinter(), pylon.RegistrationMode_Append, pylon.Cleanup_Delete)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since we have access to the data itself, we can use callbacks to save every image to the hard drive, or do some analysis, compression, etc. It is important to note that while we can trigger actions when an image is acquired or skipped, the methods have access to the camera. This is very useful if, for example, we are controlling more than one camera because we may need to know which one triggered the callback. It is also possible to think about other possibilities. We could stop acquiring images after one has been skipped. We could change the exposure time if too many pixels are dark, or if the camera is saturating, etc. &lt;/p&gt;
&lt;p&gt;The advantage of callbacks, as presented by Pylon, is that we can achieve complex functionality with very little overhead and boilerplate code. If we would like to perform pattern recognition on every image, we can create a handler that takes care of it. &lt;/p&gt;
&lt;h2&gt;Understanding the work of buffers&lt;/h2&gt;
&lt;p&gt;We have used the &lt;code&gt;InstantCamera&lt;/code&gt; without digging into what happens with the camera and the computer. Working with buffers may give us the best overview of the data flow between the camera and our program. So far, we have always dealt with data coming from the camera using the method &lt;code&gt;RetrieveResult&lt;/code&gt; and its resulting &lt;code&gt;grab&lt;/code&gt; object. We should look a bit more into the details to understand memory allocation and how to make the best out of the camera. &lt;/p&gt;
&lt;p&gt;Basler's manual divides the process of acquiring an image into three steps: &lt;em&gt;image acquisition&lt;/em&gt; which happens in the camera when the sensor gets exposed, and each pixel is read. &lt;em&gt;Data transfer&lt;/em&gt;, when the computer receives the collected information. Finally, &lt;em&gt;image grabbing&lt;/em&gt; when our application accesses the underlying data. Setting up the image acquisition was what we did at the beginning of the tutorial, for example, when we changed the exposure time. There's little control over the data transfer since this is what Pylon takes care to do as efficiently as possible. But we do have control over what happens when we &lt;em&gt;grab&lt;/em&gt; the images.&lt;/p&gt;
&lt;p&gt;Each image is transferred from the camera to the computer and stored in a buffer. We are doing with the &lt;code&gt;grab&lt;/code&gt; object is actually not communicating with the camera, but just accessing an already stored element in the computer. Pylon automatically sets up a buffer in which frames are received. And this is where things get interesting. Each buffer can be accessed through a &lt;em&gt;smart pointer&lt;/em&gt; and Pylon takes care of reusing the buffer once it's no longer being accessed. With PyPylon, this flow becomes clearer with the following snippet:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;grab = camera.RetrieveResult(100, pylon.TimeoutHandling_Return)
if grab and grab.GrabSucceeded():
    img = grab.GetArray()
    grab.Release()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that we have added the &lt;code&gt;grab.Release()&lt;/code&gt; line to let Pylon know that particular buffer can be reused. Pylon automatically creates a ring buffer in which it stores the images. We must clear it periodically by retrieving the grab results and releasing them. Bear in mind that the behavior of the buffer depends on the acquisition strategy we select. We can choose &lt;em&gt;one by one&lt;/em&gt;, which respects the arrival order. We could also select &lt;em&gt;latest images only&lt;/em&gt; if we care about always getting the more recent picture, even if we sacrifice timing accuracy. &lt;/p&gt;
&lt;p&gt;In any case, there is always a chance that our program runs slower than the pace at which we generate images, and being able to control the size of the buffer is important. We can achieve this by using &lt;code&gt;MaxNumBuffer&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;camera.MaxNumBuffer = 20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By default, Pylon creates 10 buffers, which may not be enough if we have cameras able to go as fast a 1000 frames per second. Each buffer's size is equal to the size of an image. When using the entire sensor of a camera, it may be impossible to hold 1000 frames in memory. Still, when using a cropped region of the sensor, it can be feasible. &lt;/p&gt;
&lt;p&gt;I, personally, like allocating buffers not by numbers but by the total memory they would take. This gives me reasonable control when I switch from computers with enough RAM to lower-spec hardware such as a Raspberry Pi. &lt;/p&gt;
&lt;p&gt;It is important to note that the &lt;code&gt;InstantCamera&lt;/code&gt; objects create two queues. One is a queue of buffers that the low-level API can use to store data. The other is a queue of the data waiting to be read. Each time a new grab element is available, the &lt;code&gt;RetrieveResult&lt;/code&gt; thread gets notified, and the loop keeps going. Releasing the grab results is important, or we risk running out of available buffers where Pylon can store the incoming frames. &lt;/p&gt;
&lt;h2&gt;Moving Further&lt;/h2&gt;
&lt;p&gt;Basler cameras offer many more possibilities than the ones covered in this tutorial. For example, we haven't discussed triggers, which can be both software or hardware-based. Many models have input-output pins that can be used in combination with other electronics to better control the acquisition cycle. And we haven't covered advanced topics, such as working with multiple cameras, receiving events, or the access to &lt;em&gt;chunk features&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;All these topics are covered in detail in the documentation that can be accessed from the Pylon viewer's help menu. Once the essential topics are understood, it is easier to start implementing other features. &lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;Basler did a great job by open-sourcing its wrapper for Python. I've seen swift replies on &lt;a href="https://github.com/basler/pypylon"&gt;the repository&lt;/a&gt; where the code is hosted. I have been using PyPylon for some years already. It is nice to see a company that invests time and effort in adding Python support to its hardware. It takes a while to grasp the flow behind Pylon to build efficient solutions, but overall it is a very well-designed tool. It clearly shows that it was thought through and polished over the years. &lt;/p&gt;
&lt;p&gt;In my opinion, the jewel of the crown is the PylonViewer. Having a program that exposes all the parameters of the hardware as well as their documentation is priceless. Leveraging the viewer to understand the effect the parameters have, their limits, etc., was a significant game-changer for me. Instead of starting from the manual seeking out terms, I always start with the viewer and only go to the manual if I have doubts or need extra contextual information. &lt;/p&gt;</content><category term="blog"></category><category term="microscopy"></category><category term="video"></category><category term="pypylon"></category><category term="camera"></category><category term="basler"></category></entry><entry><title>Singletons: Instantiate objects only once</title><link href="https://www.pythonforthelab.com/blog/singletons-instantiate-objects-only-once" rel="alternate"></link><published>2021-01-16T00:00:00+01:00</published><updated>2021-01-16T00:00:00+01:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2021-01-16:/blog/singletons-instantiate-objects-only-once</id><summary type="html">&lt;p&gt;When developing more extensive programs, being aware of different patterns can significantly help us solve problems even before they arise. One of those patterns is the creation of singletons, which are nothing else but objects that can be instantiated only once. In Python, we are exposed to singletons since the …&lt;/p&gt;</summary><content type="html">&lt;p&gt;When developing more extensive programs, being aware of different patterns can significantly help us solve problems even before they arise. One of those patterns is the creation of singletons, which are nothing else but objects that can be instantiated only once. In Python, we are exposed to singletons since the beginning, even if we are not aware of them. This article will discuss how singletons permeate our everyday programming and how we can bring them a step further. &lt;/p&gt;
&lt;h2&gt;Every Day Singletons&lt;/h2&gt;
&lt;p&gt;Before we dive into singletons, it is important to remember how Python behaves when it comes to mutable and immutable data types. A list, for example, is mutable, which means we can change its contents without creating a new object. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; var2 = var1
&amp;gt;&amp;gt;&amp;gt; var1[0] = 0
&amp;gt;&amp;gt;&amp;gt; print(var2)
[0, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;If the output of the code above puzzles you, I strongly advise you to check out the article on mutable and immutable data types. &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;When we have two lists like &lt;code&gt;var1&lt;/code&gt; and &lt;code&gt;var2&lt;/code&gt;, we can see whether they have the same content:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 == var2 
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But we can also see if they are the same object:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 is var2
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, we can also do the following: &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; var2 = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; var1 == var2
True
&amp;gt;&amp;gt;&amp;gt; var1 is var2
False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case, both &lt;code&gt;var1&lt;/code&gt; and &lt;code&gt;var2&lt;/code&gt; have the same values &lt;code&gt;[1, 2, 3]&lt;/code&gt; but they are not the same object. That is why &lt;code&gt;var1 is var2&lt;/code&gt; returns &lt;code&gt;False&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;However, Python programmers are likely exposed to the following syntax very early on:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;if var is None:
    print('Var is none')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At first sight the question that could pop anyone's mind is why can we use &lt;code&gt;ìs&lt;/code&gt; in the example above. And the answer is that &lt;code&gt;None&lt;/code&gt; is a special type of object, one that can be instantiated only once. Let's see some examples:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 = None
&amp;gt;&amp;gt;&amp;gt; var2 = None
&amp;gt;&amp;gt;&amp;gt; var1 == var2
True
&amp;gt;&amp;gt;&amp;gt; var1 is var2
True
&amp;gt;&amp;gt;&amp;gt; var3 = var2
&amp;gt;&amp;gt;&amp;gt; var3 is var1
True
&amp;gt;&amp;gt;&amp;gt; var3 is None
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It means that through our code, there can be only one &lt;code&gt;None&lt;/code&gt;, and any variable that references it will reference the same object, unlike what happened when we created two lists that had the same values. Together with &lt;code&gt;None&lt;/code&gt;, the other two common singletons are &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; [1, 2, 3] is [1, 2, 3]
False
&amp;gt;&amp;gt;&amp;gt; None is None
True
&amp;gt;&amp;gt;&amp;gt; False is False
True
&amp;gt;&amp;gt;&amp;gt; True is true
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That completes the triad of singletons that Python programmers encounter daily. It explains why we can use the &lt;code&gt;is&lt;/code&gt; syntax when checking if a variable is &lt;code&gt;None&lt;/code&gt;, &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;. The examples above are only the beginning regarding singletons.&lt;/p&gt;
&lt;h2&gt;Small integer singletons&lt;/h2&gt;
&lt;p&gt;Python defines other singletons that are not that obvious and are mostly there because of memory and speed efficiency. Such is the case of small integers in the range -5 to 256. Therefore, we can do something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 = 1
&amp;gt;&amp;gt;&amp;gt; var2 = 1
&amp;gt;&amp;gt;&amp;gt; var1 is var2
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or, more interestingly:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; var2 = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; var1 is var2
False
&amp;gt;&amp;gt;&amp;gt; for i, j in zip(var1, var2):
...     i is j
... 
True
True
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the example above, you see two lists with the same elements. They are not the same list as we saw earlier, but each element is the same. If we want to get fancier with Python's syntax (just because we can), we can also run the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 = [i for i in range(250, 260)]
&amp;gt;&amp;gt;&amp;gt; var2 = [i for i in range(250, 260)]
&amp;gt;&amp;gt;&amp;gt; for i, j in zip(var1, var2):
...     print(i, i is j)
... 
250 True
251 True
252 True
253 True
254 True
255 True
256 True
257 False
258 False
259 False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we see that up to 256 integers are the same, but from 257 onwards, they are not. &lt;/p&gt;
&lt;h2&gt;Short strings singletons&lt;/h2&gt;
&lt;p&gt;Small integers are not the only unexpected singletons in Python. Short strings are, sometimes, also singletons. We can try something like the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 = 'abc'
&amp;gt;&amp;gt;&amp;gt; var2 = 'abc'
&amp;gt;&amp;gt;&amp;gt; var1 is var2
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, with strings, the reality is somewhat different. The process is called &lt;strong&gt;string interning&lt;/strong&gt; and is described on &lt;a href="https://en.wikipedia.org/wiki/String_interning"&gt;Wikipedia&lt;/a&gt;. Python decides whether to allocate memory for strings as singletons based on some rules. First, strings must be defined at &lt;em&gt;compile-time&lt;/em&gt;. It means that they should not be the output of a formatting task or a function. In the example above, &lt;code&gt;var1 = 'abc'&lt;/code&gt; qualifies. &lt;/p&gt;
&lt;p&gt;Python tries its best at being efficient, and it will intern other strings that it considers will help save memory (and/or time). For example, function names are interned by default:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; def test_func():
...     print('test func')
... 
&amp;gt;&amp;gt;&amp;gt; var1 = 'test_func'
&amp;gt;&amp;gt;&amp;gt; test_func.__name__ is var1
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Empty strings and some single-character strings are interned by default, as is the case with small integers:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 = chr(255)
&amp;gt;&amp;gt;&amp;gt; var2 = chr(255)
&amp;gt;&amp;gt;&amp;gt; var3 = chr(256)
&amp;gt;&amp;gt;&amp;gt; var4 = chr(256)
&amp;gt;&amp;gt;&amp;gt; var1 is var2
True
&amp;gt;&amp;gt;&amp;gt; var3 is var4
False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The fact that some strings are interned, does not mean we can get too confident about it. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 = 'Test String'
&amp;gt;&amp;gt;&amp;gt; var2 = 'Test String'
&amp;gt;&amp;gt;&amp;gt; var1 is var2
False
&amp;gt;&amp;gt;&amp;gt; var2 = 'TestString'
&amp;gt;&amp;gt;&amp;gt; var1 = 'TestString'
&amp;gt;&amp;gt;&amp;gt; var1 is var2
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As we can see in the example above, being a short string is not the only requirement. The string must also be made of a limited set of characters, and spaces are not part of it. &lt;/p&gt;
&lt;p&gt;Therefore, the fact that Python is interning strings does not mean we should use the &lt;code&gt;is&lt;/code&gt; syntax instead of the &lt;code&gt;==&lt;/code&gt;. It just means that Python is running some optimizations under the hood. Perhaps one day, those optimizations become relevant for our code, but likely they will go completely unnoticed (but enjoyed). &lt;/p&gt;
&lt;h2&gt;Why singletons&lt;/h2&gt;
&lt;p&gt;What we have seen up to now is interesting, but it does not answer why going through the trouble of defining singletons. One clear answer is that by having singletons, we can save memory. In Python, what we usually call variables, can also be considered labels, pointing to the underlying data. If we have several labels pointing to the same data, it would be very memory efficient. There's no duplication of the information. &lt;/p&gt;
&lt;p&gt;However, if we ask ourselves when to add a singleton to our code, most likely, we won't find good examples. A singleton is a class that is instantiated only once. All other instances refer to the first, and therefore &lt;em&gt;are&lt;/em&gt; the same. If you think about it, singletons and global variables are easy to mistake one for the other. However, a global variable does not imply anything about how it is instantiated. We could have a global variable pointing to an instance of a class and a local variable pointing to a different instance of the same class. &lt;/p&gt;
&lt;p&gt;Singletons are a programming pattern, and as such, they can be useful, but there's nothing we can do with them that can't be done without them. A standard example of singletons is a &lt;strong&gt;logger&lt;/strong&gt;. Several parts of the program share information with the logger. The handler then decides whether to print to the terminal, save to a file, or don't do anything.&lt;/p&gt;
&lt;h2&gt;Defining a singleton&lt;/h2&gt;
&lt;p&gt;The crucial point of singletons is preventing multiple instantiations. Let's start by checking what happens when we instantiate a class twice:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MySingleton:
    pass


ms1 = MySingleton()
ms2 = MySingleton()
print(ms1 is ms2)
# False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As expected, both instances are different objects. To prevent the second instantiation, we must keep track of whether a class was instantiated. We can use a variable in the class itself to do it and return the same object. A possibility is to use the &lt;code&gt;__new__&lt;/code&gt; method of the class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MySingleton:
    instance = None

    def __new__(cls, *args, **kwargs):
        if not isinstance(cls.instance, cls):
            cls.instance = object.__new__(cls)
        return cls.instance
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we can test it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; ms1 = MySingleton()
&amp;gt;&amp;gt;&amp;gt; ms2 = MySingleton()
&amp;gt;&amp;gt;&amp;gt; ms1 is ms2
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This approach is relatively straightforward. We only need to check whether the &lt;code&gt;instance&lt;/code&gt; was defined and create it if it does not exist. Sure, we could use &lt;code&gt;__instance&lt;/code&gt;, or fancier ways of checking if the variable exists. The result would be the same. &lt;/p&gt;
&lt;p&gt;Singletons are a pattern which, in the end, is hard to justify. So we can see one example on which we open a file more than once. Our singleton class would look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyFile:
    _instance = None
    file = None

    def __init__(self, filename):
        if self.file is None:
            self.file = open(filename, 'w')

    def write(self, line):
        self.file.write(line + '\n')

    def __new__(cls, *args, **kwargs):
        if not isinstance(cls._instance, cls):
            cls._instance = object.__new__(cls)

        return cls._instance
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note a couple of things. First, we have defined &lt;code&gt;file&lt;/code&gt; as a class attribute. We do this because the &lt;code&gt;__init__&lt;/code&gt; method will be executed as often as the class is instantiated. Therefore, we open the file only once. We can achieve the same behavior directly in the &lt;code&gt;__new__&lt;/code&gt; method after checking the &lt;code&gt;_instance&lt;/code&gt; attribute. Note that we open the file in &lt;code&gt;w&lt;/code&gt; mode, which means that we will overwrite the file's content each time. &lt;/p&gt;
&lt;p&gt;We can use the singleton like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; f = MyFile('test.txt')
&amp;gt;&amp;gt;&amp;gt; f.write('test1')
&amp;gt;&amp;gt;&amp;gt; f.write('test2')

&amp;gt;&amp;gt;&amp;gt; f2 = MyFile('test.txt')
&amp;gt;&amp;gt;&amp;gt; f2.write('test3')
&amp;gt;&amp;gt;&amp;gt; f2.write('test4')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the contents of the file would be:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;test1
test2
test3
test4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is clear from the example above that it does not matter if we first define &lt;code&gt;f&lt;/code&gt; or &lt;code&gt;f2&lt;/code&gt;. The file to which we are going to write is opened only once. The contents get erased only once, and every time we write to it through the program, we will append lines. &lt;/p&gt;
&lt;p&gt;We can also check if it is a singleton:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; f is f2
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, in the way we defined our class above, there is one huge problem. What would be the output of the following?&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; f = MyFile('test.txt')
&amp;gt;&amp;gt;&amp;gt; f.write('test1')
&amp;gt;&amp;gt;&amp;gt; f.write('test2')
&amp;gt;&amp;gt;&amp;gt; f2 = MyFile('test2.txt')
&amp;gt;&amp;gt;&amp;gt; f2.write('test3')
&amp;gt;&amp;gt;&amp;gt; f2.write('test4')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code is valid, but the program will create only the first file (&lt;code&gt;test.txt&lt;/code&gt;) and ignore the second instantiation argument. Another fascinating point is what happens if we removed completely the &lt;code&gt;__new__&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyFile:
    file = []

    def __init__(self, filename):
        if len(self.file) == 0:
            self.file.append(open(filename, 'w'))

    def write(self, line):
        self.file[0].write(line + '\n')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By definition this class is not a singleton, since each time we instantiate it we will get a different object:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; f = MyFile('test.txt')
&amp;gt;&amp;gt;&amp;gt; f2 = MyFile('test.txt')
&amp;gt;&amp;gt;&amp;gt; f is f2
False
&amp;gt;&amp;gt;&amp;gt; f.write('test1')
&amp;gt;&amp;gt;&amp;gt; f.write('test2')
&amp;gt;&amp;gt;&amp;gt; f2.write('test3')
&amp;gt;&amp;gt;&amp;gt; f2.write('test4')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We are slightly cheating now because we changed the &lt;code&gt;file&lt;/code&gt; attribute from &lt;code&gt;None&lt;/code&gt; to an empty list. We do this because lists are mutable. When we append the opened file, the list is still the same and therefore shared among the other instances. In any case, the end effect is the same. The file is opened only once, and the lines get written in the same fashion as before. &lt;/p&gt;
&lt;p&gt;The idea of this quick example is that opening the file only once is not a feature exclusive of singletons. Just by smartly using mutability, we can achieve the same effect in even fewer lines of code. &lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;The singleton pattern can be of great help when designing lower-level applications or frameworks. Python uses singletons to speed up its execution and to be more memory efficient. If we compare the time it takes to resolve &lt;code&gt;f == f2&lt;/code&gt; and &lt;code&gt;f is f2&lt;/code&gt; in the singleton and not-singleton cases, we can see some time improvements in the first. Whether the modifications impact the costs and limitations of the implementation will depend on how often we check equality. &lt;/p&gt;
&lt;p&gt;For higher-level solutions, however, the singleton pattern is harder to come by. I have tried to dig examples in other projects, but the only answer that comes back is the &lt;em&gt;logger&lt;/em&gt; implementation. If anyone has an excellent example of using singletons in higher-level programs, I would be very grateful to hear it. &lt;/p&gt;
&lt;h3&gt;Singletons can break unit tests&lt;/h3&gt;
&lt;p&gt;A side note that is worth mentioning is that the singleton pattern can easily break unit tests' idea. In the singleton example above, we could have modified the &lt;code&gt;MyFile&lt;/code&gt; object by doing something like &lt;code&gt;f.new_file = open('another_file')&lt;/code&gt;. This change would have been persistent and can potentially alter other tests. The spirit behind unit tests is that each one is responsible for one thing and one thing only. If tests can impact each other, they are no longer &lt;em&gt;unit&lt;/em&gt; tests. &lt;/p&gt;</content><category term="blog"></category><category term="instance"></category><category term="objects"></category><category term="pattern"></category><category term="object oriented"></category><category term="singleton"></category></entry><entry><title>Differences of Multiprocessing on Windows and Linux</title><link href="https://www.pythonforthelab.com/blog/differences-between-multiprocessing-windows-and-linux" rel="alternate"></link><published>2020-06-13T00:00:00+02:00</published><updated>2020-06-13T00:00:00+02:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2020-06-13:/blog/differences-between-multiprocessing-windows-and-linux</id><summary type="html">&lt;p&gt;Multiprocessing is an excellent package if you ever want to speed up your code without leaving Python. When I started working with multiprocessing, I was unaware of the differences between Windows and Linux, which set me back several weeks of development time on a relatively big project. Let's quickly see …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Multiprocessing is an excellent package if you ever want to speed up your code without leaving Python. When I started working with multiprocessing, I was unaware of the differences between Windows and Linux, which set me back several weeks of development time on a relatively big project. Let's quickly see how multiprocessing works and where Windows and Linux diverge. &lt;/p&gt;
&lt;p&gt;The quickest way of showing how to use multiprocessing is to run a simple function without blocking the main program:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import multiprocessing as mp
from time import sleep


def simple_func():
    print('Starting simple func')
    sleep(1)
    print('Finishing simple func')


if __name__ == '__main__':
    p = mp.Process(target=simple_func)
    p.start()
    print('Waiting for simple func to end')
    p.join()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which outputs the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;Waiting for simple func to end
Starting simple func
Finishing simple func
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output is what we were expecting. Let's go to the core of the problem at hand by studying how this code behaves: &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import multiprocessing as mp
from time import sleep


print('Before defining simple_func')

def simple_func():
    print('Starting simple func')
    sleep(1)
    print('Finishing simple func')


if __name__ == '__main__':
    p = mp.Process(target=simple_func)
    p.start()
    print('Waiting for simple func to end')
    p.join()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we run this code on Windows, we get the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;Before defining simple_func
Waiting for simple func to end
Before defining simple_func
Starting simple func
Finishing simple func
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While on Linux we get the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;Before defining simple_func
Waiting for simple func to end
Starting simple func
Finishing simple func
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It does not look like much, except for the second &lt;code&gt;Before defining simple_func&lt;/code&gt;, and this difference is crucial. On &lt;strong&gt;Linux&lt;/strong&gt;, when you start a child process, it is &lt;em&gt;Forked&lt;/em&gt;. It means that the child process inherits the memory state of the parent process. On Windows (and by default on Mac), however, processes are &lt;em&gt;Spawned&lt;/em&gt;. It means that a new interpreter starts and the code reruns. &lt;/p&gt;
&lt;p&gt;It explains why, if we run the code on Windows, we get twice the line &lt;code&gt;Before defining simple_func&lt;/code&gt;. As you may have noticed, this could have been much worse if we wouldn't include the &lt;code&gt;if __main__&lt;/code&gt; at the end of the file, let's check it out. On Windows, it produces a very long error, that finishes with:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;RuntimeError: 
        An attempt has been made to start a new process before the
        current process has finished its bootstrapping phase.

        This probably means that you are not using fork to start your
        child processes and you have forgotten to use the proper idiom
        in the main module:

            if __name__ == '__main__':
                freeze_support()
                ...

        The &amp;quot;freeze_support()&amp;quot; line can be omitted if the program
        is not going to be frozen to produce an executable.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While on Linux, it works just fine. It may not look like much, but imagine you have some computationally expensive initialization task. Perhaps you do some system checks when the program runs. Probably you don't want to run all those checks for every process you start. It can get even more interesting if you have values that change at runtime:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import multiprocessing as mp
import random

val = random.random()

def simple_func():
    print(val)


if __name__ == '__main__':
    print('Before multiprocessing: ')
    simple_func()
    print('After multiprocessing:')
    p = mp.Process(target=simple_func)
    p.start()
    p.join()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;On Windows, it would give an output like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;Before multiprocessing:
0.16042209710776734
After multiprocessing:
0.9180213870647225
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While on Linux, it gives an output like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;Before multiprocessing:
0.28832424513226507
After multiprocessing:
0.28832424513226507
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And this brings us to the last topic and the reason why I lost so much time when I had to port code written in Linux to work on Windows. A typical situation in which values change at runtime is when you are working with classes. Objects are meant to hold values; they are not static. So, what happens if you try to run a method of a class on a separate process? Let's start with a straightforward task:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import multiprocessing as mp


class MyClass:
    def __init__(self, i):
        self.i = i

    def simple_method(self):
        print('This is a simple method')
        print(f'The stored value is: {self.i}')

    def mp_simple_method(self):
        self.p = mp.Process(target=self.simple_method)
        self.p.start()

    def wait(self):
        self.p.join()


if __name__ == '__main__':
    my_class = MyClass(1)
    my_class.mp_simple_method()
    my_class.wait()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code works fine both on Linux and Windows. And this may happen for a lot of different scenarios, until one day you try to do something slightly more complicated, like writing or reading from a file:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import multiprocessing as mp


class MyClass:
    def __init__(self, i):
        self.i = i
        self.file = open(f'{i}.txt', 'w')

    def simple_method(self):
        print('This is a simple method')
        print(f'The stored value is: {self.i}')

    def mp_simple_method(self):
        self.p = mp.Process(target=self.simple_method)
        self.p.start()

    def wait(self):
        self.p.join()
        self.file.close()


if __name__ == '__main__':
    my_class = MyClass(1)
    my_class.mp_simple_method()
    my_class.wait()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;On Linux, the code above works fine. On Windows (and Mac), however, there'll be a very nasty error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;[...]
    ForkingPickler(file, protocol).dump(obj)
TypeError: cannot serialize '_io.TextIOWrapper' object
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pay attention to the fact that we don't do anything with the file. We just open and store it as an attribute in the class. However, the error already points to an interesting feature. The way Spawning works is by pickling the entire object. Therefore, if we have a class or an attribute that is not &lt;em&gt;pickable&lt;/em&gt;, we will not be able to start a child process with it. &lt;/p&gt;
&lt;p&gt;And, for people working with hardware, most likely the communication with the device, in pretty much the same way that a file is non-pickable. It does not matter how much you try to make it multiprocessing safe by implementing locks or whatnot. The root problem is at a lower level. &lt;/p&gt;
&lt;h2&gt;Is there a way of solving it?&lt;/h2&gt;
&lt;p&gt;Sadly, there is no way of changing how processes start on Windows. You can, on the other hand, change how processes start on Linux. It would allow you to be sure your program also runs on Windows and Mac. We just need to add the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;if __name__ == '__main__':
    mp.set_start_method('spawn')
    my_class = MyClass(1)
    my_class.mp_simple_method()
    my_class.wait()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By using &lt;code&gt;set_start_method&lt;/code&gt;, the program will give the same error on Windows and Linux. Whether you need to add this line or not depends on what do you want to achieve. &lt;/p&gt;
&lt;p&gt;So, if you ever encounter these discrepancies, you will have to re-think the design of your program. I had objects with non-pickable attributes, especially drivers for devices and ZMQ sockets. &lt;/p&gt;
&lt;h2&gt;Speed is another factor&lt;/h2&gt;
&lt;p&gt;Even though processes usually speed up the speed of a program by leveraging multiple cores on a computer, starting each process can be time-consuming. The fact that on Windows and Mac Python needs to &lt;em&gt;pickle&lt;/em&gt; the objects to create child processes adds an overhead that may offset the benefits of running on separated processes. It is especially relevant when you have many small tasks to perform, instead of a couple of long-running ones. &lt;/p&gt;
&lt;p&gt;Therefore, when using processes, improving the speed of the program is not a granted outcome. You should always benchmark your application to understand where and how different components can affect its behavior. &lt;/p&gt;</content><category term="tips"></category><category term="multiprocessing"></category><category term="windows"></category><category term="linux"></category><category term="tips"></category></entry><entry><title>Python Tip: Using Else with Loops</title><link href="https://www.pythonforthelab.com/blog/python-tip-using-else-loops" rel="alternate"></link><published>2020-05-25T00:00:00+02:00</published><updated>2020-05-25T00:00:00+02:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2020-05-25:/blog/python-tip-using-else-loops</id><summary type="html">&lt;p&gt;Most likely, you are aware of how to use the &lt;code&gt;else&lt;/code&gt; statement with an &lt;code&gt;if&lt;/code&gt; clause. However, Python also allows us to use them with loops. They are straightforward to understand and open some exciting possibilities. Before continuing, remember that &lt;code&gt;else&lt;/code&gt; in this context should be called &lt;code&gt;no-break&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;Let's quickly …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Most likely, you are aware of how to use the &lt;code&gt;else&lt;/code&gt; statement with an &lt;code&gt;if&lt;/code&gt; clause. However, Python also allows us to use them with loops. They are straightforward to understand and open some exciting possibilities. Before continuing, remember that &lt;code&gt;else&lt;/code&gt; in this context should be called &lt;code&gt;no-break&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;Let's quickly see how a for-loop works:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;start = 0
end = 10

for i in range(start, end):
    print(i)
else:
    print('End')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code above will print the numbers from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;9&lt;/code&gt; and the &lt;code&gt;End&lt;/code&gt; string. So far, nothing impressive, but check this out:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;start = 0  
end = 10  
break_point = 5  

for i in range(start, end):  
    print(i)  
    if i == break_point:  
        break  
else:  
    print('Nothing')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output will be all the numbers from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;5&lt;/code&gt;, but no string at the end. Now you can understand why it was called &lt;code&gt;no-break&lt;/code&gt;. The same approach also works for &lt;code&gt;while&lt;/code&gt; loops:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;start = 0  
end = 10  
break_point = 5  

i = start  

while i &amp;lt; end:  
    print(i)  
    i += 1  
  if i == break_point:  
        break  
else:  
    print('Nothing')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The fair question is, when would you use this pattern. A clear situation is when you are looking for an element. For example, you may be looking for a specific line in a file, and want to raise an exception if not found:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;key_line = 'Key Line'
f = open('file.dat', 'r')
for line in f:
    if line == key_line:
        break
else:
    raise Exception('Line not Found')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Perhaps raising an exception is a bit extreme, but you see the pattern. It saves you from checking whether we found the line in the file or not using some extra variable to verify it. &lt;/p&gt;
&lt;p&gt;If you have used this pattern and have any helpful examples, you can always share it in the discussion below.&lt;/p&gt;</content><category term="tips"></category><category term="loops"></category><category term="for"></category><category term="while"></category><category term="else"></category><category term="tips"></category></entry><entry><title>Python Tip: Ready to Publish Matplotlib Figures</title><link href="https://www.pythonforthelab.com/blog/python-tip-ready-publish-matplotlib-figures" rel="alternate"></link><published>2020-05-18T00:00:00+02:00</published><updated>2020-05-18T00:00:00+02:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2020-05-18:/blog/python-tip-ready-publish-matplotlib-figures</id><summary type="html">&lt;p&gt;Saving figures for publications, presentations, books, or websites can be a cumbersome task but doesn't need to be. In this &lt;strong&gt;Python Tip&lt;/strong&gt;, we will see how to create images using Matplotlib that are ready to be embedded. We will take care of the most important aspects: shape, font sizes, and …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Saving figures for publications, presentations, books, or websites can be a cumbersome task but doesn't need to be. In this &lt;strong&gt;Python Tip&lt;/strong&gt;, we will see how to create images using Matplotlib that are ready to be embedded. We will take care of the most important aspects: shape, font sizes, and resolution. You won't have to tinker ever again with random parameters until the result is right. &lt;/p&gt;
&lt;p&gt;Once you understand the options that Matplotlib offers, and what they mean, you will realize that generating publication-ready figures can be a breeze. We will focus mostly on plots for papers, but once you get the gist, you can extrapolate to other formats such as posters, books, or websites.  &lt;/p&gt;
&lt;h2&gt;Size&lt;/h2&gt;
&lt;p&gt;First, we need to discuss size and resolution, two independent, but related magnitudes. Size is the physical dimensions of an image. If we were preparing a plot for a paper, for example, we should first check the column width. &lt;a href="https://www.sciencemag.org/sites/default/files/Figure_prep_guide.pdf"&gt;Science uses a width&lt;/a&gt; of 9cm, or 3.54 inches. The height of the image will depend on the content we are displaying. For simplicity, I will assume a square image, so we have 3.54x3.54 inches. &lt;/p&gt;
&lt;p&gt;With matplotlib, defining the size of a figure is straightforward:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;fig = plt.figure(figsize=(3.54,3.54))
plt.plot(x, y)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, knowing the size is only half the problem. We can make a plot of the same size, but with different &lt;em&gt;resolution&lt;/em&gt;, which is the second parameter we need to discuss. &lt;/p&gt;
&lt;h2&gt;DPI&lt;/h2&gt;
&lt;p&gt;The resolution of an image can be calculated, counting the total number of pixels it contains or defining the dots per inch: &lt;strong&gt;DPI&lt;/strong&gt;. We can calculate the dots per inch if we know the total number of pixels and the physical size we expect for the image. The other way around, if we know the final size of an image and the &lt;strong&gt;dpi&lt;/strong&gt;, we can calculate the number of pixels we need. The terminology comes from the printer process of making &lt;em&gt;dots&lt;/em&gt; of ink. If we are looking at the image on a screen instead of printing, the &lt;em&gt;dots&lt;/em&gt; become &lt;em&gt;pixels&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;If we are preparing a paper, the &lt;em&gt;dpi&lt;/em&gt; is fixed by the printer. Therefore, we must match that value when we prepare our images, or they would look terrible. A typical &lt;em&gt;dpi&lt;/em&gt; value for printing is &lt;strong&gt;600dpi&lt;/strong&gt;. We can specify this directly on matplotlib:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;fig = plt.figure(figsize=(3.54,3.54), dpi=600)
plt.plot(x, y)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we make the math, this means the final figure has 2124 pixels on each axis. &lt;/p&gt;
&lt;h2&gt;Font Size&lt;/h2&gt;
&lt;p&gt;At some point, you must wonder why we are specifying both the figure size and the &lt;em&gt;dpi&lt;/em&gt;. If we used bigger image sizes, we would get more pixels. However, font size and thickness is related to the size of the figure, not to the number of pixels. Therefore, if we do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;fig = plt.figure(figsize=(3.54,3.54), dpi=300)
plt.plot(x, y, linewidth=2)
plt.xlabel('X label (s)', fontsize=20)
plt.ylabel('Y label (V)', fontsize=10)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We will get a figure that, when set to the proper size of 3.54inx3.54in will have axes with fonts of 20pt and 10pt. Matplotlib allows us to set the font size to the exact value we want. For example, if our main text uses a font size of 12pt, we can make the labels slightly larger than the text, and the ticks slightly smaller:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import matplotlib 
matplotlib.rc('xtick', labelsize=10) 
matplotlib.rc('ytick', labelsize=10) 

fig = plt.figure(figsize=(3.54,3.54), dpi=300)
plt.plot(x, y, linewidth=2)
plt.xlabel('X label (s)', fontsize=15)
plt.ylabel('Y label (V)', fontsize=15)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Remember, setting the font size implies knowing the final size of the figure. We can try to change the &lt;em&gt;dpi&lt;/em&gt; parameter. We will see that even if the figure shrinks on the screen (because of fewer pixels), the relative size of the fonts to the total image area is always the same. If you stretch the images to occupy the same space on the screen, the axes labels will have the same size.  &lt;/p&gt;
&lt;p&gt;You can download [this document]https://www.pythonforthelab.com/documents/1/image_sizes.pdf) to see how the dpi affects the overall image quality. There are figures at 72dpi, 150dpi, 300dpi, and 600dpi. I've also included one figure with double-column width but keeping all the other parameters the same, including the data.&lt;/p&gt;
&lt;p&gt;If you are preparing figures for a poster, for example, you would likely have a larger figure size, bigger font sizes, but keeping a &lt;em&gt;dpi&lt;/em&gt; of 600 for printing. &lt;/p&gt;
&lt;h2&gt;Saving&lt;/h2&gt;
&lt;p&gt;Once we have the figures we want, the last step is to save them. We must decide the format we want to use to save them. I tend to default to &lt;em&gt;png&lt;/em&gt; because it is a lossless compression format. It means that the quality is as good as what I've defined it. In Matplotlib, it becomes:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;plt.savefig('figure.png', bbox_inches='tight')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The extra argument, &lt;code&gt;bbox_inches&lt;/code&gt; is needed to be sure Matplotlib figures out the entire canvas before saving. If we don't add it, the axes will likely be cropped out of the picture. PNG images can be embedded in documents, websites, and presentations. Almost all paper journals also accept them if you provide them with the proper resolution. &lt;/p&gt;
&lt;p&gt;Other alternatives are saving as vector formats. You can choose to save as &lt;em&gt;SVG&lt;/em&gt; if you plan to further edit the images in programs such as Inkscape or Adobe Illustrator. If you are writing in TeX, prefer vector over raster, you can save the figures as &lt;em&gt;pdf&lt;/em&gt;. My note: avoid &lt;em&gt;eps&lt;/em&gt; (encapsulated postscript), unless you have a legitimate reason to do it. They are just harder to share, and they don't provide a real gain.  &lt;/p&gt;
&lt;h2&gt;For Presentations&lt;/h2&gt;
&lt;p&gt;If we are preparing figures for a presentation, we must consider two things. People will be looking at the slides from afar, and we don't want to have PowerPoint files of hundreds of megabytes. Generally speaking, font sizes in presentations are larger than in a paper, or people won't be able to see the axes. The other aspect is that figures should have a reasonable amount of pixels. Higher resolutions would generate heavy figures without any gain. &lt;/p&gt;
&lt;p&gt;PowerPoint specifies some default slide dimensions. For a wide-screen presentation, they are 13.33inx7.5in. Let's assume we will use a Full-HD projector, which has a width of 1920px and a height of 1080px. It gives a &lt;em&gt;dpi&lt;/em&gt; of 144. However, PowerPoint works with a &lt;a href="https://docs.microsoft.com/en-us/office/troubleshoot/powerpoint/change-export-slide-resolution"&gt;default resolution&lt;/a&gt; of &lt;strong&gt;96dpi&lt;/strong&gt;. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: other programs may use different default resolutions, or newer versions of PowerPoint may default to higher resolutions. In any case, the only thing you have to do is changing the &lt;em&gt;dpi&lt;/em&gt; parameter of the figure. &lt;/p&gt;
&lt;p&gt;With the information we have, we can create the figures: &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import matplotlib 
matplotlib.rc('xtick', labelsize=16) 
matplotlib.rc('ytick', labelsize=16) 

fig = plt.figure(figsize=(13.33,7.5), dpi=96)
plt.plot(x, y, linewidth=2)
plt.xlabel('X label (s)', fontsize=18)
plt.ylabel('Y label (V)', fontsize=18)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have selected font sizes of &lt;strong&gt;16&lt;/strong&gt; and &lt;strong&gt;18&lt;/strong&gt;. These are reasonable values, but you may prefer to make them larger if you are presenting to large auditoriums.  In most presentations, however, we won't show figures at full-screen. If we use two images side-by-side, we can have something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;fig = plt.figure(figsize=(5,3), dpi=96)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we don't scale the image after we embed it into PowerPoint, we will have consistent figures. Perhaps they are full-screen, maybe they are displayed side-by-side, but all the axes and line thicknesses will be precisely the same. &lt;/p&gt;
&lt;h2&gt;Figures for the Web&lt;/h2&gt;
&lt;p&gt;If you are preparing figures for the web, then the discussion becomes much more complicated. Screens change in shape and resolution. Someone behind an iPad with a retina display will have as many pixels as someone behind a desktop screen. Still, the physical size of the figure is dramatically different. There is no blanket advice on how to prepare images for the web that work across all possible situations. Most websites make separate images for different situations, at various resolutions, and with different content. &lt;/p&gt;
&lt;p&gt;However, the best you can do when preparing images for the web is to save them as &lt;strong&gt;SVG&lt;/strong&gt;, which is a vector format. These images can be scaled without losing resolution. In Matplotlib, it is trivial:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;plt.savefig('my_figure.svg', bbox_inches='tight')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can go ahead and try changing the &lt;em&gt;dpi&lt;/em&gt; of the image before saving, and try to notice if there are any differences. &lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;If you are preparing figures for a publication, the best you can do is finding out the size figures should have. Most journals give you the dimensions of the columns. If you can't find them, you can always default to the size of &lt;a href="https://www.sciencemag.org/sites/default/files/Figure_prep_guide.pdf"&gt;Science&lt;/a&gt;. Once you know the size of your figures, fix the &lt;em&gt;dpi&lt;/em&gt;. If it is for a paper, a thesis, or a poster, &lt;strong&gt;600dpi&lt;/strong&gt; should be good enough. Then, set the font size of the labels and the axes to match the font size of the text around them. You can make labels and ticks slightly bigger or smaller than the text, depending on your style preferences. &lt;/p&gt;
&lt;p&gt;In &lt;a href="https://www.pythonforthelab.com/documents/1/image_sizes.pdf"&gt;this PDF&lt;/a&gt;, I have included figures generated at different &lt;em&gt;dpi&lt;/em&gt; but scaled to the sizes recommended by Science.&lt;/p&gt;</content><category term="tips"></category><category term="matplotlib"></category><category term="resolution"></category><category term="figure"></category><category term="plot"></category><category term="saving"></category></entry><entry><title>Data Descriptors: Bringing Attributes to the Next level</title><link href="https://www.pythonforthelab.com/blog/data-descriptors-bringing-attributes-next-level" rel="alternate"></link><published>2020-05-16T00:00:00+02:00</published><updated>2020-05-16T00:00:00+02:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2020-05-16:/blog/data-descriptors-bringing-attributes-next-level</id><summary type="html">&lt;p&gt;Descriptors in Python allow us to control how attributes of classes are accessed or modified. A pattern often encountered is defining properties to use setter and getter methods encapsulated as if they were a single attribute. In this article, we will dig into how the property decorator works, to understand …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Descriptors in Python allow us to control how attributes of classes are accessed or modified. A pattern often encountered is defining properties to use setter and getter methods encapsulated as if they were a single attribute. In this article, we will dig into how the property decorator works, to understand how to implement our solutions. &lt;/p&gt;
&lt;p&gt;The descriptor interface also allows attributes to access the class where they are defined. For example, this is useful in registering all the attributes of a specific type in the parent class. With this tool, we can have a clear interface to update all the settings of a class. We will cover not only how to define this type of attributes, but also how to deal with inheritance. &lt;/p&gt;
&lt;h2&gt;Properties are Descriptors&lt;/h2&gt;
&lt;p&gt;Once you fully embrace the object-oriented nature of Python, there is a high chance that you cross interesting tools, such as the @propery decorator. Let's quickly see an example of how it works and what it can do for us:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    _var = 0

    @property
    def var(self):
        print('Getting Var')
        return self._var
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; my_class = MyClass()
&amp;gt;&amp;gt;&amp;gt; print(my_class.var)
Getting Var
0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can see that by using the &lt;code&gt;@property&lt;/code&gt; decorator, we have changed the behavior of a method, &lt;code&gt;var&lt;/code&gt; to look like an attribute of the class &lt;code&gt;MyClass&lt;/code&gt;. We went one step further, and we added some extra functionality. Whenever we read the value of &lt;code&gt;var&lt;/code&gt;, we print a line to the screen informing us about it. This pattern has exciting possibilities that we discuss in the rest of the article. &lt;/p&gt;
&lt;p&gt;As a side note, Python does not have &lt;em&gt;private&lt;/em&gt; attributes. It means that whatever we define in a class can be accessed and modified from outside of it. Using the underscore for &lt;code&gt;_var&lt;/code&gt; is just a way of signaling other developers that they should not change &lt;code&gt;_var&lt;/code&gt; directly, but that it should be changed only within the class itself. IDE's such as PyCharm warn us if we ever try to alter one such variable, but there is nothing more that we can do. &lt;/p&gt;
&lt;p&gt;Before we move to more complicated topics, there is something worth mentioning. In the enthusiasm of learning a new topic, sometimes important considerations are overlooked. Whenever we encounter a code that looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; my_class.var
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We expect execution to be close to instantaneous. If, for example, the method &lt;code&gt;var&lt;/code&gt; includes connecting to a remote server and fetching information, the program's behavior would become tougher to anticipate. It is hard to draw a line between clarity and usefulness. Always keep in mind that there is nothing that descriptors can do that can't be achieved with plain methods. &lt;/p&gt;
&lt;p&gt;Getting a value is less than half what properties can do. The other half is setting a value. The syntax is  straightforward:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    _var = 0

    @property
    def var(self):
        print('Getting var')
        return self._var

    @var.setter
    def var(self, value):
        print('Setting var')
        self._var = value
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; my_class = MyClass()
&amp;gt;&amp;gt;&amp;gt; print(my_class.var)
Getting var
0
&amp;gt;&amp;gt;&amp;gt; my_class.var = 2
Setting var
&amp;gt;&amp;gt;&amp;gt; print(my_class.var)
Getting var
2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we used the decorator &lt;code&gt;@property&lt;/code&gt;, it altered the method &lt;code&gt;var&lt;/code&gt; in such a way that we could use itself as a decorator. A fair question at this stage is what do we gain by using properties instead of methods. In my opinion, it is only a matter of simplifying how the code looks at this stage. Compare this code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; my_class.get_var()
0
&amp;gt;&amp;gt;&amp;gt; my_class.set_var(2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;to this one:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; print(my_class.var)
0
&amp;gt;&amp;gt;&amp;gt; my_class.var = 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We could argue that the second is easier to read. Properties are convenient when we have many methods for getting and setting values because they can simplify the interface quite often. When we control devices, for example, and each setting has a different method for reading and changing its value. &lt;/p&gt;
&lt;p&gt;We can see an example of how to go one step further. We can use the pattern to verify that the value we assign to &lt;code&gt;var&lt;/code&gt; is an integer:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;@var.setter
def var(self, value):
    print('Setting var')
    if not isinstance(value, int):
        raise TypeError('Value must be integer')
    self._var = value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we can test it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; my_class.var = 2.0
[...]
TypeError: Value must be integer
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Develop your own Descriptors&lt;/h2&gt;
&lt;p&gt;Using &lt;code&gt;@property&lt;/code&gt; can extend our options when planning classes in Python, but at some point, we need to go beyond the built-in tools. When we defined descriptors, we said that they are objects that define how they are &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; from the object that contains them. However, &lt;code&gt;var&lt;/code&gt; does not implement anything like that. The real descriptor is &lt;code&gt;@property&lt;/code&gt;. So, let's start by developing our object that can work similarly. &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyDescriptor:
    _val = 0

    def __get__(self, instance, owner):
        print('Getting Descriptor')
        return self._val

    def __set__(self, instance, value):
        print('Setting Value')
        self._val = value


class MyClass:
    var = MyDescriptor()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;MyDescriptor&lt;/code&gt; is a class that defines two methods: &lt;code&gt;__get__&lt;/code&gt; and &lt;code&gt;__set__&lt;/code&gt;. Perhaps you can already notice that the methods are very similar to how we defined &lt;code&gt;var&lt;/code&gt; in the previous section. We can use the class like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; my_class = MyClass()
&amp;gt;&amp;gt;&amp;gt; my_class.var
Getting Descriptor
0
&amp;gt;&amp;gt;&amp;gt; my_class.var = 2
Setting Value
&amp;gt;&amp;gt;&amp;gt; my_class.var
Getting Descriptor
2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We are not limited to having only one &lt;code&gt;MyDescriptor&lt;/code&gt; in the class, we can define as many as we need:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    var = MyDescriptor()
    var1 = MyDescriptor()
    var2 = MyDescriptor()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this way, we can define as many attributes as we want, all with the same behavior. Every time we read them, a message is printed; every time we set them, another message is printed. However useful, this is also pushing us away from how properties work. We are storing &lt;code&gt;_var&lt;/code&gt; directly in the descriptor and not in the class itself. &lt;/p&gt;
&lt;p&gt;What we would like to achieve is the following behavior:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    _var = 0

    @MyDescriptor
    def var(self):
        print('Getting var')
        return self._var
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We need to change &lt;code&gt;MyDescriptor&lt;/code&gt; so we can use it as a decorator. We should also change its &lt;code&gt;__get__&lt;/code&gt; method, so it uses the method defined in the class and not just a standard method defined in the descriptor. &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyDescriptor:
    def __init__(self, fget):
        print('Instantiating descriptor')
        self.fget = fget

    def __get__(self, instance, owner):
        print('Getting Descriptor')
        return self.fget(instance)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that we have included an &lt;code&gt;__init__&lt;/code&gt; method that takes one argument: fget. When we develop decorators, the method being decorated is the first argument. You can check &lt;a href="https://www.pythonforthelab.com/blog/how-to-use-decorators-part-2/"&gt;our article on decorators&lt;/a&gt; to learn more. We also had to adapt the &lt;code&gt;__get__&lt;/code&gt; method to use the &lt;code&gt;fget&lt;/code&gt; function. Notice that the first argument of &lt;code&gt;fget&lt;/code&gt; should be &lt;code&gt;self&lt;/code&gt;, and that is why we pass &lt;code&gt;instance&lt;/code&gt; as the first argument. &lt;/p&gt;
&lt;p&gt;When we use it, we can have a clear look at the order in which things happen:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; from descriptors import *
Instantiating descriptor
&amp;gt;&amp;gt;&amp;gt; my_class = MyClass()
print(my_class.var)
&amp;gt;&amp;gt;&amp;gt; my_class = MyClass()
&amp;gt;&amp;gt;&amp;gt; my_class.var
Getting Descriptor
Getting var
0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The instantiation of the descriptor happens at import time. Whenever the python interpreter goes through those lines of code, even if we never instantiate the class, the Descriptor is instantiated. The rest of the code proceeds as usual, but note that we first get the descriptor, then we run the method for returning &lt;code&gt;var&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;As we saw earlier, this is only half the problem. Once we know how to get a value, we should also see how to set it. Before we do anything, we can just try:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; my_class = MyClass()
&amp;gt;&amp;gt;&amp;gt; print(my_class.var)
Getting Descriptor
0
&amp;gt;&amp;gt;&amp;gt; my_class.var = 2
&amp;gt;&amp;gt;&amp;gt; print(my_class.var)
2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first time we access &lt;code&gt;var&lt;/code&gt;, we get the two lines printed on the screen, telling us that both the method and the descriptor worked as expected. However, after we set &lt;code&gt;var = 2&lt;/code&gt;, they stop working. It is fascinating because what happened is that we overwrote the &lt;code&gt;var&lt;/code&gt;, which is a descriptor, by a plain integer. To prevent this, we can add an explicit &lt;code&gt;__set__&lt;/code&gt; method that raises an exception:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def __set__(self, instance, value):
    raise Exception('This is a read-only descriptor')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And with this, the problem of overwriting &lt;code&gt;var&lt;/code&gt; goes away. But, we are still far from done. What happens if we want to define a setter? Things slowly get more interesting. We would like to use the following syntax:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    _var = 0

    @MyDescriptor
    def var(self):
        return self._var

    @var.setter
    def var(self, value):
        self._var = value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Right now, &lt;code&gt;var&lt;/code&gt; is passed as the first argument of &lt;code&gt;MyDescriptor&lt;/code&gt;. The only way in which &lt;code&gt;setter&lt;/code&gt; can exist is if it is a method of &lt;code&gt;MyDescriptor&lt;/code&gt;. Moreover, we should also store not only &lt;code&gt;fget&lt;/code&gt; but also &lt;code&gt;fset&lt;/code&gt; as attributes. We can start by improving the &lt;code&gt;__init__&lt;/code&gt; and &lt;code&gt;__set__&lt;/code&gt; methods:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyDescriptor:
    def __init__(self, fget=None, fset=None):
        print('Instantiating descriptor')
        self.fget = fget
        self.fset = fset

    def __set__(self, instance, value):
        print('Setting Descriptor')
        self.fset(instance, value)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To quickly use the solution as is, we could define &lt;code&gt;var&lt;/code&gt; with a more explicit syntax:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    _var = 0

    def get_var(self):
        return self._var

    def set_var(self, value):
        self._var = value

    var = MyDescriptor(get_var, set_var)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can go ahead and test it to see that it works, even if it is not what we were after. By the way, the same syntax also works for &lt;code&gt;property&lt;/code&gt;. The &lt;code&gt;setter&lt;/code&gt; method looks a bit more magical, but if we break it in smaller parts we can understand it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;    def setter(self, fset):
        return type(self)(self.fget, fset)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;setter&lt;/code&gt; takes one argument, &lt;code&gt;fset&lt;/code&gt;, which is the decorated method. Now, we need to instantiate the &lt;code&gt;MyDecorator&lt;/code&gt;, using the &lt;code&gt;fget&lt;/code&gt; that we already know and passing the &lt;code&gt;fset&lt;/code&gt;, which is new. Here is where the magic of &lt;code&gt;type(self)&lt;/code&gt; comes into place. It returns the class to which the instance (&lt;code&gt;self&lt;/code&gt;) belongs, and we can use it in the same way as we would use the &lt;code&gt;MyDecorator&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;That was the only missing part; now we can use the full syntax:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    _var = 0

    @MyDescriptor
    def var(self):
        return self._var

    @var.setter
    def var(self, value):
        self._var = value


my_class = MyClass()
print(my_class.var)
my_class.var = 2
print(my_class.var)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course, there are a lot of different options that can be implemented. For example, we could raise an exception of &lt;code&gt;fset&lt;/code&gt; does not exist, such as we did earlier. It would mean that &lt;code&gt;var&lt;/code&gt; is "read-only". We could also define "set-only" properties, but there is something important to discuss before going forward. &lt;/p&gt;
&lt;p&gt;We are using &lt;code&gt;MyDescriptor&lt;/code&gt; as a decorator, and we managed to use &lt;code&gt;setter&lt;/code&gt; without too much effort. Note that we used the name &lt;code&gt;var&lt;/code&gt; for both the get and set methods. It is because Python binds those names to the class. If we use a different name for the setter, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    _var = 0

    @MyDescriptor
    def var(self):
        return self._var

    @var.setter
    def var_setter(self, value):
        self._var = value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We would end up with two different attributes, &lt;code&gt;var&lt;/code&gt; is read-only, and &lt;code&gt;var_setter&lt;/code&gt; which can be read and set. However, the underlying value, &lt;code&gt;_var&lt;/code&gt; is the same:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;my_class = MyClass()
print(my_class.var)
my_class.var_setter = 2
print(my_class.var_setter)
print(my_class.var)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The last two lines would print the same value to the screen. Therefore, we must be careful because using different names is not wrong in itself. Still, it defeats the purpose of having a clear interface. Before we move on, there is something else that we can implement with what we already know. &lt;/p&gt;
&lt;p&gt;We could use &lt;code&gt;MyDescriptor&lt;/code&gt; to specify some boundaries. If the value we try to set is beyond them, we raise an exception. We would like to be able to have a class that looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    _var = 0

    @MyDescriptor(val_min=0, val_max=3)
    def var(self):
        return self._var

    @var.setter
    def var(self, value):
        self._var = value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To keep going, you must be familiar with decorators. If you are not, we recommend you to check &lt;a href="https://www.pythonforthelab.com/blog/how-to-use-decorators-part-2/"&gt;this article&lt;/a&gt;. Not that we instantiate &lt;code&gt;MyDescriptor&lt;/code&gt; and then we use it as a decorator. The only way in which that can work is if we define the &lt;code&gt;__call__&lt;/code&gt; method. We also need to change the &lt;code&gt;__init__&lt;/code&gt;to accommodate for the limits. The full class would look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyDescriptor:
    def __init__(self, fget=None, fset=None, val_min=None, val_max=None):
        print('Instantiating descriptor')
        self.val_min = val_min
        self.val_max = val_max
        self.fget = fget
        self.fset = fset

    def __call__(self, fget):
        return type(self)(fget, self.fset, self.val_min, self.val_max)

    def __get__(self, instance, owner):
        print('Getting Descriptor')
        return self.fget(instance)

    def __set__(self, instance, value):
        print('Setting Descriptor')
        if not self.val_min &amp;lt;= value &amp;lt;= self.val_max:
            raise ValueError(f'Value must be between {self.val_min} and {self.val_max}')
        self.fset(instance, value)

    def setter(self, fset):
        return type(self)(self.fget, fset, self.val_min, self.val_max)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Most of the code is the same, but the flow is very different. The &lt;code&gt;__call__&lt;/code&gt; method allows us to specify how a class can be used after it was instantiated. To understand it a bit better, let's simplify the code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyDescriptor:
    def __init__(self, val):
        self.val = val

    def __call__(self):
        print(self.val)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we can use it like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; my_descriptor = MyDescriptor(1)
&amp;gt;&amp;gt;&amp;gt; my_descriptor()
1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the example above, we can see that &lt;code&gt;__call__&lt;/code&gt; is the method that allows us to use &lt;code&gt;MyDescriptor&lt;/code&gt; as a decorator, even after we have instantiated it. The pattern is the same we used for the &lt;code&gt;setter&lt;/code&gt; method. We just assume that the argument that follows is the &lt;em&gt;getter&lt;/em&gt; method. &lt;/p&gt;
&lt;p&gt;Back to the full example, the decorator will take care of checking if the value is between the specified range:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; my_class = MyClass()
&amp;gt;&amp;gt;&amp;gt; my_class.var
Getting Descriptor
0
&amp;gt;&amp;gt;&amp;gt; my_class.var = 5
Setting Descriptor
[...]
ValueError: Value must be between 0 and 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Only Setters&lt;/h3&gt;
&lt;p&gt;We have assumed that the getter was always defined, both with properties and with our custom descriptor. However, it is also possible to have descriptors that can only be set, but not retrieved. It is hard to come up with situations in which this could be useful. With a property, it would look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    _var = 0

    def var_setter(self, value):
        self._var = value

    var = property(None, var_setter)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And with our descriptor it would look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    _var = 0

    var = MyDescriptor(val_min=0, val_max=3)

    @var.setter
    def var(self, value):
        self._var = value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You should study the code above to understand why we can use &lt;code&gt;MyDescriptor&lt;/code&gt; both as a decorator and as a class. &lt;/p&gt;
&lt;p&gt;The sections above cover the classic approach to descriptors. However, since &lt;strong&gt;Python 3.6&lt;/strong&gt;, objects include another method, &lt;code&gt;__set_name__&lt;/code&gt;. This method allows them to manipulate the owner of the descriptor easily. This behavior is where real new opportunities appear in a much more straightforward way of thinking. &lt;/p&gt;
&lt;h2&gt;Accessing the Owner Class with &lt;code&gt;set_name&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Something that will happen at some point is that you would like to know where an attribute is defined. A possible pattern would be to register certain types of attributes in the class that holds them. For example, imagine you have a device in which you define settings and that you would like to know all the settings contained within that device. To achieve that, you should have attributes that can register themselves in the owner class. &lt;/p&gt;
&lt;p&gt;First, let's develop a solution to show what &lt;code&gt;__set_name__&lt;/code&gt; can do, and then we can see the details. The descriptor is very similar to the one we developed earlier: &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyDescriptor:
    def __init__(self, fget=None, fset=None):
        print('Instantiating descriptor')
        self.fget = fget
        self.fset = fset

    def __set_name__(self, owner, name):
        print(f'Setting name to {name}')
        if not hasattr(owner, '_descriptors'):
            setattr(owner, '_descriptors', [])

        owner._descriptors.append(name)

    def __get__(self, instance, owner):
        print('Getting Descriptor')
        return self.fget(instance)

    def __set__(self, instance, value):
        print('Setting Descriptor')
        self.fset(instance, value)

    def setter(self, fset):
        return type(self)(self.fget, fset)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The class to use this descriptor would be the same as before:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    _var = 0

    @MyDescriptor
    def var(self):
        return self._var

    @var.setter
    def var(self, value):
        self._var = value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And when we actually use it, we will see the behavior: &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; from descriptors import MyClass
Instantiating descriptor
Instantiating descriptor
Setting name to var
&amp;gt;&amp;gt;&amp;gt; my_class = MyClass()
&amp;gt;&amp;gt;&amp;gt; print(my_class._descriptors)
['var']
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the name was assigned before we instantiated the class. The &lt;code&gt;__set_name__&lt;/code&gt; method had access to the owner class right at the moment of its definition. Finally, we see that we can store all the instances of &lt;code&gt;MyDescriptor&lt;/code&gt; on a list. If we had more than one, they would all appear there. &lt;/p&gt;
&lt;p&gt;We have chosen a list because it is the most straightforward application. Still, we could also use a dictionary, for example, to store not only the name but also the latest updated value, or the time of the update. We could use that as a cache for later retrieval. &lt;/p&gt;
&lt;p&gt;What we show here is one of the most straightforward patterns that can be achieved with &lt;code&gt;__set_name__&lt;/code&gt;, but also one of the most useful ones. Being able to register attributes on the owner class is of great help in many applications. &lt;/p&gt;
&lt;h3&gt;Taking care of inheritance&lt;/h3&gt;
&lt;p&gt;The method above has one big problem when dealing with inheritance. Let's quickly see what happens if we have a second class that inherits from &lt;code&gt;MyClass&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    _var = 0
    _var1 = 1

    @MyDescriptor
    def var(self):
        return self._var

    @var.setter
    def var(self, value):
        self._var = value

    @MyDescriptor
    def var1(self):
        return self._var1

class MyOtherClass(MyClass):
    _new_var = 2

    @MyDescriptor
    def new_var(self):
        return self._new_var
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we look at the list of descriptors, we will see that they are both the same:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; my_class = MyClass()
&amp;gt;&amp;gt;&amp;gt; my_other_class = MyOtherClass()
&amp;gt;&amp;gt;&amp;gt; my_class._descriptors
['var', 'var1', 'new_var']
&amp;gt;&amp;gt;&amp;gt; my_other_class._descriptors
['var', 'var1', 'new_var']
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now is a great time to check out what &lt;a href="https://www.pythonforthelab.com/blog/mutable-and-immutable-objects/"&gt;mutable and immutable&lt;/a&gt; data types are in Python. What is happening is that the list of descriptors is mutable, and therefore it is shared. When the child appends a new value, it also appears in the parent class. &lt;/p&gt;
&lt;p&gt;Solving this problem is not trivial, but Hernán Grecco found a &lt;a href="https://github.com/lantzproject/lantz-core/blob/b30a073296fb86fe652bc90893514e15ffbfe840/lantz/core/feat.py#L106"&gt;very elegant solution&lt;/a&gt; for Lantz, which I explain here.&lt;/p&gt;
&lt;h3&gt;Taking care of inheritance&lt;/h3&gt;
&lt;h4&gt;Subclassing built-in data types&lt;/h4&gt;
&lt;p&gt;First, we need to discuss something that may seem slightly esoteric for most. We are going to create a child object from a standard data-type in Python. As a general rule, if you don't have a good reason to do it, it is probably a good idea to avoid this pattern. However, this time we do have a good reason. It works the same as always, let's assume we want to subclass a list, we do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyList(list):
    pass


var = MyList([1, 2, 3])
print(len(var))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;var&lt;/code&gt; has the same features a normal list has, so we can &lt;code&gt;append&lt;/code&gt;, iterate through the objects, etc. But we can now define new attributes to &lt;code&gt;MyList&lt;/code&gt;, as we would do with our objects:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;var.my_info = 'This is my info'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It would not have been possible to achieve the same with a plain list. When following this pattern, you should be extra careful not to overwrite methods from the list. For example, the following could lead to errors even though it is not incorrect in itself:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;var.append = 'Update'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Before we continue, it is also important to refresh how we can set and get attributes to an object: &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;setattr(var, 'my_info', 'Updated Info')
getattr(var, 'my_info')
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Checking ownership&lt;/h4&gt;
&lt;p&gt;The general idea to prevent children from propagating information to their parents would be to register the owner class in the list of descriptors itself. New descriptors check whether the list of descriptors and the class that defines it belong to the same owner. If it is the same, then it just appends itself. If it is different, it means it is a child creating a descriptor, and instead of appending, it creates a new list. &lt;/p&gt;
&lt;p&gt;We start by creating a custom list:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyList(list):
    pass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the secret now is to use this list to register the descriptors. We can add the following to &lt;code&gt;MyDescriptor&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def __set_name__(self, owner, name):
    descriptors = getattr(owner, '_descriptors', None)
    if descriptors is not None:
        if getattr(descriptors, 'owner_class', None) != owner.__qualname__:
            owner._descriptors = MyList(descriptors)
            setattr(owner._descriptors, 'owner_class', owner.__qualname__)
        owner._descriptors.append(name)
    else:
        setattr(owner, '_descriptors', MyList())
        setattr(owner._descriptors, 'owner_class', owner.__qualname__)
        owner._descriptors.append(name)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let's go line by line. First, we check if the owner has a &lt;code&gt;_descriptors&lt;/code&gt; attribute. If it has one, it probably means another descriptor created it, but we should check whether it was another descriptor in the same class or the parent class. We are going to use the attribute &lt;code&gt;owner_class&lt;/code&gt; in the custom list. The dunder &lt;code&gt;__qualname__&lt;/code&gt; returns the &lt;em&gt;qualified name&lt;/em&gt;, which is the full path to the class (including the &lt;code&gt;.&lt;/code&gt;) and therefore, should be unique through your program. &lt;/p&gt;
&lt;p&gt;If the registered qualified name is different from the owner's name, we are probably dealing with an inheritance. What we have to do is create a new &lt;code&gt;_descriptors&lt;/code&gt; attribute. With this, we unlink the parent from the child attribute. Right after creating the list, we set the attribute &lt;code&gt;owner_class&lt;/code&gt; to the qualified name of the owner so that it can be used later on. Once we know we are dealing with the proper &lt;code&gt;_descriptors&lt;/code&gt;, we append the name of the current descriptor. &lt;/p&gt;
&lt;p&gt;The last block is taking care of the situation where the owner does not have a &lt;code&gt;_descriptors&lt;/code&gt; attribute defined. Depending on what you are building, you may already know that the attribute has to be there. But it has no more complications, it just forces the owner to have a list, with the proper owner class, and then appends the name. &lt;/p&gt;
&lt;p&gt;With the same definition of the classes that we had before, we can check again if we are getting the proper list of descriptors:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;my_class = MyClass()
my_other_class = MyOtherClass()
print(my_class._descriptors)
# ['var', 'var1']
print(my_other_class._descriptors)
# ['var', 'var1', 'new_var']
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So now you see that inheritance is working only from parent to children, as expected. &lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;We have focused this article on using descriptors as decorators, similar to how @property works. We do believe this is one of the most common patterns for descriptors, but it is by no means the only one. First, you don't need to use them as decorators for methods; they could be attributes directly defined in classes. If you check the &lt;a href="https://docs.python.org/3/howto/descriptor.html#static-methods-and-class-methods"&gt;official documentation&lt;/a&gt; you can see examples that drill deeper into manipulating the &lt;code&gt;__dict__&lt;/code&gt; of the objects. This degree of complexity is, however, seldom required, but please let us know in the comments if it can be useful for you. &lt;/p&gt;
&lt;p&gt;The &lt;em&gt;descriptor protocol&lt;/em&gt; is an incredibly useful tool when you need to manipulate the class where attributes are defined. A very common situation is what we showed in the last section: registering specific attributes in a list. We could go one step further and define a cache, timeouts, and more. It is not something everyone needs every time. Still, when you wonder how to have access to the owner class when you are defining an attribute, descriptors are the solution. &lt;/p&gt;</content><category term="blog"></category><category term="data"></category><category term="decorator"></category><category term="pattern"></category><category term="description"></category><category term="property"></category></entry><entry><title>Python Tips: Using Sets</title><link href="https://www.pythonforthelab.com/blog/python-tips-using-sets" rel="alternate"></link><published>2020-05-11T00:00:00+02:00</published><updated>2020-05-11T00:00:00+02:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2020-05-11:/blog/python-tips-using-sets</id><summary type="html">&lt;p&gt;Most people are familiar with lists, tuples, and dictionaries as the basic data types for grouping information. However, there is another convenient option: &lt;strong&gt;sets&lt;/strong&gt;. They are directly linked to the mathematical idea of a &lt;em&gt;set&lt;/em&gt;. To define them, we can use the following syntax:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;var = {1, 2, 3, 4}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Most people are familiar with lists, tuples, and dictionaries as the basic data types for grouping information. However, there is another convenient option: &lt;strong&gt;sets&lt;/strong&gt;. They are directly linked to the mathematical idea of a &lt;em&gt;set&lt;/em&gt;. To define them, we can use the following syntax:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;var = {1, 2, 3, 4}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also use this alternative:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;var1 = set([1, 2, 3, 4])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Where the argument of &lt;code&gt;set&lt;/code&gt; is an iterable (see &lt;a href="https://www.pythonforthelab.com/blog/generators-iterables-iterators-python-when-and-where/"&gt;this article&lt;/a&gt; if you want to learn about iterables). &lt;/p&gt;
&lt;p&gt;Sets &lt;strong&gt;can't have repeated elements&lt;/strong&gt;. Therefore, they can be used to clean up the repeated elements from iterables. For example, &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;mis = &amp;quot;mississippi&amp;quot;

var = set(mis)
for i in var:
    print(i)
# p
# i
# m
# s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code only outputs different letters. See that the &lt;strong&gt;order is not respected&lt;/strong&gt;. By definition, sets are unordered. Sets also define operations. &lt;/p&gt;
&lt;h3&gt;Operations Between Sets&lt;/h3&gt;
&lt;h4&gt;Union&lt;/h4&gt;
&lt;p&gt;To calculate the union between two sets:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;mis = &amp;quot;mississippi&amp;quot;
ama = &amp;quot;amazon&amp;quot;
var1 = set(mis)
var2 = set(ama)

letters = var1 | var2

for i in letters:
    print(i)

# n
# i
# s
# a
# m
# z
# p
# o
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Intersection&lt;/h4&gt;
&lt;p&gt;The intersection between two sets can also be calculated with an operator:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;mis = &amp;quot;mississippi&amp;quot;
ama = &amp;quot;amazon&amp;quot;
var1 = set(mis)
var2 = set(ama)

letters = var1 &amp;amp; var2

for i in letters:
    print(i)

# m
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Subsets or Supersets&lt;/h4&gt;
&lt;p&gt;If you want to know whether a set is contained in another (or the other way around), you can use the comparison operator:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;var1 = set('asia')
var2 = set('australia')

print(var1 &amp;lt; var2)

# True
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Difference between sets&lt;/h4&gt;
&lt;p&gt;The difference between sets can be defined in different ways. For example, if we want to remove the elements of one set from another, we can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;var1 = set('america')
var2 = set('australia')

var3 = var2 - var1

for i in var3:
    print(i)

# t
# s
# l
# u
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It removed the elements of &lt;code&gt;var1&lt;/code&gt; from &lt;code&gt;var2&lt;/code&gt;. There is no need for &lt;code&gt;var1&lt;/code&gt; to be a subset of &lt;code&gt;var2&lt;/code&gt;, it just removes the elements that are present and disregards the ones that are not. &lt;/p&gt;
&lt;p&gt;But there is another option, which is the &lt;strong&gt;symmetric difference&lt;/strong&gt;, meaning the elements that are present in only one of the two sets, but not in both:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;var1 = set('america')
var2 = set('australia')

var3 = var1 ^ var2

print(var3)

# {'c', 'u', 's', 'm', 'e', 't', 'l'}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Accessing Elements&lt;/h3&gt;
&lt;p&gt;Since sets are unordered, we can't access the elements using an index. However, sets are iterables, which allowed us to do things like&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;for i in var1:
    print(i)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Sets also allow us to pop elements:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;var = set('mississippi')

print(var)
print(var.pop())
print(var)

# {'s', 'i', 'm', 'p'}
# s
# {'i', 'm', 'p'}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also verify if an element is contained within a set:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;var = set('mississippi')
print('i' in var)

# True
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Frozen Sets&lt;/h3&gt;
&lt;p&gt;Sets are &lt;a href="https://www.pythonforthelab.com/blog/mutable-and-immutable-objects/"&gt;mutable&lt;/a&gt;, which means that we can change their contents while the variable will be pointing to the same object. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;var1 = set('mississipi')
var2 = var1
var3 = set('amazon')

print(var2)
# {'s', 'p', 'i', 'm'}
var1 |= var3

print(var2)
# {'p', 'i', 'n', 'm', 'o', 'z', 's', 'a'}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the example above, we change &lt;code&gt;var1&lt;/code&gt; but the changes get propagated to &lt;code&gt;var2&lt;/code&gt;, as expected for mutable objects. Sets define another data type that prevents that behavior, called &lt;code&gt;frozenset&lt;/code&gt;, see the example below:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;var1 = frozenset('mississipi')
var2 = var1
var3 = set('amazon')

print(var2)
# frozenset({'p', 'm', 's', 'i'})
var1 |= var3

print(var2)
# frozenset({'p', 'm', 's', 'i'})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also check the &lt;code&gt;id&lt;/code&gt; of the variables to see that they are effectively changing:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;var1 = frozenset('mississipi')
print(id(var1))
# 139836399804936
var1 |= var3
print(id(var1))
# 139836371992136
&lt;/code&gt;&lt;/pre&gt;</content><category term="tips"></category><category term="data types"></category><category term="tips"></category><category term="iterables"></category></entry><entry><title>Generators, Iterables, Iterators in Python: When and Where</title><link href="https://www.pythonforthelab.com/blog/generators-iterables-iterators-python-when-and-where" rel="alternate"></link><published>2020-04-10T00:00:00+02:00</published><updated>2020-04-10T00:00:00+02:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2020-04-10:/blog/generators-iterables-iterators-python-when-and-where</id><summary type="html">&lt;p&gt;Generators, Iterables, and Iterators are some of the most used tools in Python. However, we don't often stop to think about how they work, how we can develop our generators and iterables. Once you learn what you can do with them, it is possible to expand your toolbox and make …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Generators, Iterables, and Iterators are some of the most used tools in Python. However, we don't often stop to think about how they work, how we can develop our generators and iterables. Once you learn what you can do with them, it is possible to expand your toolbox and make your code much more efficient and pythonic. &lt;/p&gt;
&lt;h2&gt;Iterables&lt;/h2&gt;
&lt;p&gt;One of the very first things you learn about Python is that if you have a list, for example, you can go through all the elements with a convenient syntax:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; for element in var:
...     print(element)
... 
1
2
3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Even if you have worked with Python for long, you may give this syntax for granted, without stopping to think a lot about it. At some point you may find that it also works with tuples or dictionaries:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var = {'a': 1, 'b':2, 'c':3}
&amp;gt;&amp;gt;&amp;gt; for key in var:
...     print(key)
... 
a
b
c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The same syntax works with strings:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var = 'abc'
&amp;gt;&amp;gt;&amp;gt; for c in var:
...     print(c)
... 
a
b
c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can imagine, an iterable is an object in Python that allows going through its elements one by one. It seems like almost any data type that allows to group information together is iterable. So, the next logical step is to think about whether we can define our own iterable. &lt;/p&gt;
&lt;h3&gt;The __getitem__ approach&lt;/h3&gt;
&lt;p&gt;As you may know now, to define our own types, we define classes. We could do something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Arr:
    def __init__(self):
        self.a = 0
        self.b = 1
        self.c = 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And to use it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; a = Arr()
&amp;gt;&amp;gt;&amp;gt; print(a.a)
0
&amp;gt;&amp;gt;&amp;gt; print(a.b)
1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can see very, very briefly, how to get started using classes. It is a simple example, in which we store three different values, and we then print two of them. However, if we try the following, we would get an error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; for item in a:
...     print(item)
... 
Traceback (most recent call last):
  File &amp;quot;&amp;lt;input&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: 'Arr' object is not iterable

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Indeed we see that we can't iterate over our object. Python just doesn't know what element comes first, which one later. Therefore, we need to implement it ourselves, and you'll see from the example that it is obvious: &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Arr:
    def __init__(self):
        self.a = 0
        self.b = 1
        self.c = 2

    def __getitem__(self, item):
        if item == 0:
            return self.a
        elif item == 1:
            return self.b
        elif item == 2:
            return self.c
        raise StopIteration

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I know it is very convoluted, but let's see how it works:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; a = Arr()
&amp;gt;&amp;gt;&amp;gt; print(a[0])
0
&amp;gt;&amp;gt;&amp;gt; print(a[1])
1
&amp;gt;&amp;gt;&amp;gt; for element in a:
...     print(element)
... 
0
1
2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you see that by implementing the &lt;code&gt;__getitem__&lt;/code&gt; method, we can access the attributes of our object like if it would be a list, or a tuple, just by doing &lt;code&gt;a[0]&lt;/code&gt;, &lt;code&gt;a[1]&lt;/code&gt;. When you start threading this precisely, there are many paths you can follow, many questions you can ask yourself. At this stage may be essential to check what &lt;a href="https://www.pythonforthelab.com/blog/duck-typing-or-how-to-check-variable-types/"&gt;duck typing&lt;/a&gt; is and how you can work with it. &lt;/p&gt;
&lt;p&gt;You can see that we also raise a &lt;code&gt;StopIteration&lt;/code&gt; exception if we go beyond the first three elements. This exception is particular to iterables. In the for loop, we get all the elements we wanted without any problems. However, if we try the following the behavior wouldn't be what we expected:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; a[3]
Traceback (most recent call last):
  File &amp;quot;&amp;lt;input&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
  File &amp;quot;&amp;lt;input&amp;gt;&amp;quot;, line 14, in __getitem__
StopIteration
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If it had been a list, we would expect to get an &lt;code&gt;IndexError&lt;/code&gt; instead of a &lt;code&gt;StopIteration&lt;/code&gt; exception. Let's see another example, that allows us to construct an iterable from data and not as we did with just 3 elements. We can develop an object called &lt;code&gt;Sentence&lt;/code&gt;, which can go word by word within a &lt;code&gt;for&lt;/code&gt; loop, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Sentence:
    def __init__(self, text):
        self.words = text.split(' ')

    def __getitem__(self, item):
        return self.words[item]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is a simple example in which we take some text and split it in the spaces. This result is stored in the attribute &lt;code&gt;words&lt;/code&gt;. The &lt;code&gt;__getitem__&lt;/code&gt; in this case is just returning the appropriate item from the list of words. We can use it as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; s = Sentence('This is some form of text that I want to explore')
&amp;gt;&amp;gt;&amp;gt; for w in s:
        print(w)

This 
is 
some 
form 
of 
text 
that 
I 
want 
to 
explore
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can very quickly see that the behavior is what we were expecting. Of course, there are some limitations, such as not taking into account punctuation. However, we see that the &lt;code&gt;for&lt;/code&gt; loop stops without problems once the list of words runs out of elements. On the other hand, if we try something like &lt;code&gt;s[100]&lt;/code&gt;, we get the expected &lt;code&gt;IndexError&lt;/code&gt;. &lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;The class Sentence can be greatly improved if, for instance, we implement a &lt;code&gt;__len__&lt;/code&gt; method. However, this goes beyond the scope of this article.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;The only requisite to create an iterable object such as the ones we showed above, is to have a &lt;code&gt;__getitem__&lt;/code&gt; method that &lt;strong&gt;access elements using a 0-index&lt;/strong&gt; approach. The first element is s[0], and so forth. If you are relying on a list, such as in the example with &lt;code&gt;Sentence&lt;/code&gt;, then there are no problems. If you are developing something such as our &lt;code&gt;Arr&lt;/code&gt; example, then you need to take care of ensuring the 0 is the first element to be retrieved. &lt;/p&gt;
&lt;h3&gt;Creating elements on the fly&lt;/h3&gt;
&lt;p&gt;In the examples above, we could go through the specified elements within a &lt;code&gt;for&lt;/code&gt;-loop. However, the elements we were iterating over were specified at the moment of instantiation of the class. It is not necessary. Let's see how it would look like if we create a class that can generate random numbers for as long as we want:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import random 

class RandomNumbers:
    def __getitem__(self, item):
        return random.randint(0, 10)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we can use it as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; r = RandomNumbers()
&amp;gt;&amp;gt;&amp;gt; for a in r:
&amp;gt;&amp;gt;&amp;gt;         print(a)
&amp;gt;&amp;gt;&amp;gt;         if a==10:
&amp;gt;&amp;gt;&amp;gt;             break
&amp;gt;&amp;gt;&amp;gt;             
4
1
5
2
5
7
2
7
9
9
3
10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pay attention to the fact that we are stopping the loop as soon as the &lt;code&gt;RandomNumber&lt;/code&gt; object generates a 10. If we don't do this, the for loop would be running forever. You may, or example, use a timer to stop after a certain time, or after a certain number of iterations, or you may simply want to run forever. The choice is yours. You can also limit the generation of values in the class itself:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def __getitem__(self, item):
    num = random.randint(0, 10)
    if num == 10:
        raise StopIteration
    return num
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then we don't need to break the &lt;code&gt;for&lt;/code&gt; loop, it naturally stops once a &lt;code&gt;10&lt;/code&gt; is generated within the class. &lt;/p&gt;
&lt;p&gt;A situation where you may think about applying this method is, for example, if you are acquiring a signal from a device that generates sequential values. It may be frames acquired from a camera, or analog values read by a simple device one after the other. I will use these techniques in a later tutorial focusing on the interfacing with devices. &lt;/p&gt;
&lt;p&gt;Another example of an iterable that generates values only when requested is when we open a file. Python does not load into memory all the contents, but instead, we can iterate over each line. It is how it looks like with &lt;a href="https://github.com/PFTL/website_articles/blob/master/articles/39_use_arduino_with_python.md"&gt;one of the articles&lt;/a&gt; of this website:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; with open('39_use_arduino_with_python.md', 'r') as f:
...     for line in f:
...         print(line) 
...
Using Python to communicate with an Arduino
===========================================
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is what allows you to work with files that are much bigger than what it's possible to hold in memory. You can also quickly check it by looking at the sizes:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; import sys
&amp;gt;&amp;gt;&amp;gt; with open('39_use_arduino_with_python.md', 'r') as f:
&amp;gt;&amp;gt;&amp;gt;     print(sys.getsizeof(f))
&amp;gt;&amp;gt;&amp;gt;     size = 0
...     for line in f:
...         size += sys.getsizeof(line) 
...     print(size)
...
216
56402
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can see that the size of the &lt;code&gt;f&lt;/code&gt; variable is much smaller than the total size of the contents of the file added up. It is, of course, not an accurate method to know the size of a file. Still, it can get you an idea of the areas in which you can start considering iterables instead of loading a wealth of information to the memory of the computer.&lt;/p&gt;
&lt;h2&gt;Iterators&lt;/h2&gt;
&lt;p&gt;In the section above, we have seen that we can create an iterable object just by defining an appropriate &lt;code&gt;__getitem__&lt;/code&gt; method. We have also seen that several objects with which we have probably already interacted, such as lists, or files are iterables. However, something is happening under the hood, which is worth discussing and is called &lt;em&gt;iterators&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;The difference between an iterable and an iterator is very subtle. Perhaps it can be thought as the difference between a class and an object. We know we can iterate over a list, or over a custom object. But how is Python dealing with that flow? We can, very quickly, see how it works with a simple list:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var = ['a', 1, 0.1]
&amp;gt;&amp;gt;&amp;gt; it = iter(var)
&amp;gt;&amp;gt;&amp;gt; next(it)
'a'
&amp;gt;&amp;gt;&amp;gt; next(it)
1
&amp;gt;&amp;gt;&amp;gt; next(it)
0.1
&amp;gt;&amp;gt;&amp;gt; next(it)
Traceback (most recent call last):
  File &amp;quot;&amp;lt;input&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
StopIteration
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the code above, we have constructed an iterator using the built-in function &lt;code&gt;iter&lt;/code&gt;. This function takes an iterable and returns an iterator. The iterator is the object which understands what &lt;code&gt;next&lt;/code&gt; means. The iterator is iterable itself: &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; it = iter(var)
&amp;gt;&amp;gt;&amp;gt; for element in it:
...     print(element)
...
a
1
0.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we would like more control over the process, Python gives it to us. An iterator must implement two methods: &lt;code&gt;__next__&lt;/code&gt; and &lt;code&gt;__iter__&lt;/code&gt;. If we want our class to use a specific iterator, then it should also specify an &lt;code&gt;__iter__&lt;/code&gt; method. Let's see what would happen with the &lt;code&gt;Sentence&lt;/code&gt; class. To make it more obvious, we have it iterating through the words but in backward order. First, we define the iterator:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class SentenceIterator:
    def __init__(self, words):
        self.words = words
        self.index = 0

    def __next__(self):
        try:
            word = self.words[self.index]
        except IndexError:
            raise StopIteration()
        self.index -= 1
        return word

    def __iter__(self):
        return self
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code above is relatively clear. You only have to keep in mind that the only way of specifying a &lt;code&gt;next&lt;/code&gt; value is by keeping track of the current index is returned. Now that we have our iterator, we must update the original &lt;code&gt;Sentence&lt;/code&gt; class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Sentence:
    def __init__(self, text):
        self.words = text.split(' ')

    def __iter__(self):
        return SentenceIterator(self.words)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now comes the fun part:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; text = &amp;quot;This is a text to test if our iterator returns values backward&amp;quot;
&amp;gt;&amp;gt;&amp;gt; s = Sentence(text)
&amp;gt;&amp;gt;&amp;gt; s[0]
Traceback (most recent call last):
  File &amp;quot;&amp;lt;input&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: 'Sentence' object does not support indexing
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Indeed, we can't access the elements of our &lt;code&gt;Sentence&lt;/code&gt; object because we haven't specified the appropriate &lt;code&gt;__getitem__&lt;/code&gt;. However, the &lt;code&gt;for&lt;/code&gt; loop will work:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; for w in s:
...     print(w)
...     
This
backward
values
returns
iterator
our
if
test
to
text
a
is
This
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You see, the order in which it prints is backward, as expected. Just the first word is mistaken because we start in &lt;code&gt;0&lt;/code&gt;, and that also corresponds to the last index: &lt;code&gt;-12&lt;/code&gt;. You can find a solution to this issue if you want, it just requires a bit of thinking. &lt;/p&gt;
&lt;p&gt;The example above also works with &lt;code&gt;iter&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; it = iter(s)
&amp;gt;&amp;gt;&amp;gt; next(it)
'This'
&amp;gt;&amp;gt;&amp;gt; next(it)
'backwards'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is important to note that once the iterator is exhausted, there is nothing else we can do with it. At the same time, we can always go through the elements in the &lt;code&gt;Sentence&lt;/code&gt; object within a &lt;code&gt;for&lt;/code&gt; loop.&lt;/p&gt;
&lt;p&gt;The only missing part now is adding the ability to access the words by index but in the proper order. If we develop a &lt;code&gt;__getitem__&lt;/code&gt;, what do you expect to happen to the &lt;code&gt;for&lt;/code&gt; loop?&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Sentence:
    def __init__(self, text):
        self.words = text.split(' ')

    def __iter__(self):
        return SentenceIterator(self.words)

    def __getitem__(self, item):
        return self.words[item]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and we use it as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; s = Sentence(text)
&amp;gt;&amp;gt;&amp;gt; s[0]
'This'
&amp;gt;&amp;gt;&amp;gt; s[1]
'is'
&amp;gt;&amp;gt;&amp;gt; for w in s:
...     print(w)
...     
This
backwards
values
returns
iterator
our
if
test
to
text
a
is
This
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So now you see, we can access the elements through their index, and we can iterate over them in backward order. &lt;/p&gt;
&lt;h3&gt;Can Sentence have a __next__ method?&lt;/h3&gt;
&lt;p&gt;In principle, you can make &lt;code&gt;Sentence&lt;/code&gt; also an iterator, by adding a &lt;code&gt;__next__&lt;/code&gt; method. But this may be a terrible idea. Remember that iterators work until they exhaust themselves, and they maintain an internal index. If you mix &lt;code&gt;Sentence&lt;/code&gt; as both an iterable and an iterator, you will run into problems every time you encounter a double loop. &lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;Splitting the iterator and the iterable is a good idea. You can read a bit more about it in the book Fluent Python, by Luciano Ramalho. Chapter 14 is entirely dedicated to this topic. &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;For people working with scientific instruments, splitting the iterable and the iterator can have benefits. It is plausible to think scenarios where you want an iterator that behaves in different ways, depending on a parameter. For example, imagine you are reading from a camera, and want to achieve something like:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; for frame in camera:
...     analyze(frame)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Very simple, you analyze every frame generated by a camera. However, you may be in a situation where an external trigger generates frames. Therefore you want to attach the timestamp to each frame, or it may be that the camera acquires a finite number of frames at a given framerate. In principle, it could be the iterator that takes care of it. &lt;/p&gt;
&lt;p&gt;In many cases, however, we don't need to define a separated iterator, we can use &lt;strong&gt;generators&lt;/strong&gt; directly in our &lt;code&gt;__iter__&lt;/code&gt; definition. That is the focus of the next section.&lt;/p&gt;
&lt;h2&gt;Generators: Using the yield keyword&lt;/h2&gt;
&lt;p&gt;The last important topic to cover is the role of &lt;strong&gt;generators&lt;/strong&gt;, which, in my opinion, are still under-utilized, but they open new doors. A classic example is generating an infinite list of numbers. We know that it is impossible to store a list of infinite numbers in memory. Still, if we know the spacing between them, we can always know what number comes next. It is the core idea with generators. Let's start with a straightforward idea to understand the mechanics:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def make_numbers():
    print('Making a number')
    yield 1
    print('Making a new number')
    yield 2
    print('Making the last number')
    yield 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first thing that should grab your attention in the code above is that we define a function with the keyword &lt;code&gt;def&lt;/code&gt;, but instead of a &lt;code&gt;return&lt;/code&gt;, we use a &lt;code&gt;yield&lt;/code&gt; statement. The prints are there for you to understand the flow. Another interesting aspect is that we have three &lt;code&gt;yield&lt;/code&gt;, while for a normal function, you would have at most one &lt;code&gt;return&lt;/code&gt;. And now, to use it, we can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; a = make_numbers()
&amp;gt;&amp;gt;&amp;gt; print(a)
&amp;lt;generator object make_numbers at 0x7f65a8ea8ed0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As soon as we invoke the &lt;em&gt;function&lt;/em&gt; &lt;code&gt;make_numbers&lt;/code&gt;, we see no print statement. It means that nothing is running yet. Now, we can ask for the next element of the generator:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; next(a)
Making a number
1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you see the print statement is running, because we get the &lt;code&gt;making a number&lt;/code&gt; string on the screen, and we also get the first number. We can keep going:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; next(a)
Making a new number
2
&amp;gt;&amp;gt;&amp;gt; next(a)
Making the last number
3
&amp;gt;&amp;gt;&amp;gt; next(a)
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
StopIteration
&amp;gt;&amp;gt;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And there you have it, once we run out of &lt;code&gt;yield&lt;/code&gt; statements, the &lt;code&gt;StopIteration&lt;/code&gt; is raised. It is the same exception we saw earlier when developing our iterables. This exception shows us that we could use a generator in the same way we have used an iterable before. For example, we can use it inside a for-loop:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; b = make_numbers()
&amp;gt;&amp;gt;&amp;gt; for i in b:
...  print(i)
... 
Making a number
1
Making a new number
2
Making the last number
3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can expand the generators to do a plethora of things. For example, let's see how to generate a flexible number of equally spaced integers:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def make_numbers(start, stop, step):
    i = start
    while i&amp;lt;=stop:
        yield i
        i += step
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And based on what we have done before, we can do, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; for i in make_numbers(1, 20, 2):
...     print(i)
1
3
5
7
9
11
13
15
17
19
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What is very important to note here is that every number is generated only when it is needed, and hence the name of generators. Let's see what happens with the amount of memory used by our variables:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; import sys
&amp;gt;&amp;gt;&amp;gt; z = make_numbers(0, 1000000000, 1)
&amp;gt;&amp;gt;&amp;gt; sys.getsizeof(z)
128
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The variable &lt;code&gt;z&lt;/code&gt; goes from 0 to 1 billion in steps of 1. However, if we check the amount of memory used, we get just 128 bytes. It is very remarkable and is possible thanks to the generator syntax. &lt;/p&gt;
&lt;h3&gt;Generators in classes&lt;/h3&gt;
&lt;p&gt;One pattern remaining is mixing generators and iterators. We can rewrite the Sentence class to allow us looping through its elements:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Sentence:
    def __init__(self, text):
        self.words = text.split(' ')

    def __iter__(self):
        for word in self.words:
            yield word
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we can simply use it as before:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; text = &amp;quot;This is a text to test our iterator&amp;quot;
&amp;gt;&amp;gt;&amp;gt; s = Sentence(text)
&amp;gt;&amp;gt;&amp;gt; for w in s:
...     print(w)
This
is
a
text
to
test
our
iterator
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that we didn't define an explicit iterator such as &lt;code&gt;SentenceIterator&lt;/code&gt;, and we are not defining the &lt;code&gt;__next__&lt;/code&gt; method. However, we can still iterate through our sentence. The example is so basic that maybe we can't see its usefulness. Let's adapt it slightly to be able to iterate through each word of a file. One option would be to read the entire file and split it into words, making a huge list. It can consume too much memory if the file is large enough, and therefore it is not handy. But nothing prevents us from reading line by line:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class WordsFromFile:
    def __init__(self, filename):
        self.filename = filename

    def __iter__(self):
        with open(self.filename, 'r') as f:
            for line in f:
                words = line.split(' ')
                for word in words:
                    yield word
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For example, we could use it like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; words = WordsFromFile('22_Step_by_step_qt.rst.md')
&amp;gt;&amp;gt;&amp;gt; for w in words:
...     print(w)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What you can see from the example is that when we instantiate the &lt;code&gt;WordsFromFile&lt;/code&gt; class, we only store the filename, we don't open any file. However, when we iterate through the file, we open it, and instead of reading it all to memory, we iterate through each line. It is something that Python allows us to do with files. Then, we split the words on each line, just as we did before, and we &lt;code&gt;yield&lt;/code&gt; each word on each line. &lt;/p&gt;
&lt;p&gt;Another exciting result that arises from using a generator as we just did is that we can nest loops, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; for w in words:
...     for c in words:
...         print(w, c)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is a ridiculous example, but we would get an output like the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;considerations very
considerations simple
considerations way.
considerations You
considerations could
considerations find
considerations better
considerations solutions,
considerations of
considerations course,
considerations but
considerations this
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we had defined an index in the class and used it to grab the following element, the nesting would not have worked. You can go ahead and try it by yourself. &lt;/p&gt;
&lt;h2&gt;Generators, Iterators, Iterables?&lt;/h2&gt;
&lt;p&gt;It may happen that after reading the entire guide, you are still struggling to understand the difference between generators, iterators, and iterables. Iterables are the easiest to separate because it refers to objects on which is possible to iterate. Without the formality, if given an element of your object, you know how to get the next element, then your object is iterable. &lt;/p&gt;
&lt;p&gt;To iterate through objects, however, you create a new type of class, called an iterator. Iterators are the ones responsible for keeping track of the index, and knowing when you reached the end. Generators are, in essence, the same, but they just use the &lt;code&gt;yield&lt;/code&gt; syntax. &lt;/p&gt;
&lt;p&gt;There are some subtleties regarding whether iterators can be generators or vice-versa. Still, the distinction is useful when you want to transmit a clear message of what your code is doing. An iterator can be thought of as a class that goes through given elements. For example, a file has lines, and an iterator would go through all those lines. A generator, on the other hand, can generate values under demand. For example, we could generate numbers one after the other while they are being requested. &lt;/p&gt;
&lt;p&gt;The main difference would be that an iterator just returns values as they are, while generators can modify values on the fly. Is this a strict distinction? I would claim that it is not, and the gray area is so large, that it doesn't make much sense to stress about the specificities. However, I do like making the distinction if I have to explain my code to someone. I do believe that the words generator and iterator make a big difference when understanding the logic. &lt;/p&gt;
&lt;p&gt;For example, if I am acquiring images from a Camera, I would say I am using a generator. The images are not available beforehand, nor I know how they are going to look like. On the other hand, if I am reviewing the frames of data stored on the hard drive, I would try to use the word iterator. The data is already there, and I am not altering it. &lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;Iterators and Generators are two tools that are very handy to keep in your repository of strategies when planning code. They are especially handy when you are dealing with streams of data that may exceed the memory you have available. In the past, we have seen how to create &lt;a href="https://www.pythonforthelab.com/blog/the-with-command-and-custom-classes/"&gt;your classes supporting context managers&lt;/a&gt;, with generators and iterators now you can support loops and iterations. &lt;/p&gt;
&lt;p&gt;Understanding generators is essential not only to be able to add it to your code but also to be able to understand the logic behind other packages. If you quickly search around, Django uses &lt;a href="https://github.com/django/django/search?q=yield&amp;amp;unscoped_q=yield"&gt;plenty of generators in its code base&lt;/a&gt;. Once you can understand generators, it will give you a hint to how the developer was expecting you to use their code. &lt;/p&gt;</content><category term="blog"></category><category term="driver"></category><category term="arduino"></category><category term="control"></category></entry><entry><title>How to control an Arduino from the computer using Python</title><link href="https://www.pythonforthelab.com/blog/how-control-arduino-computer-using-python" rel="alternate"></link><published>2020-02-04T00:00:00+01:00</published><updated>2020-02-04T00:00:00+01:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2020-02-04:/blog/how-control-arduino-computer-using-python</id><summary type="html">&lt;p&gt;Arduinos may be one of the most disruptive electronic developments of the past decade. They opened a world of possibilities to quickly prototype solutions in professional settings but also opened the door for enthusiasts to learn about electronics and microcontrollers. In this article, we are going to see how to …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Arduinos may be one of the most disruptive electronic developments of the past decade. They opened a world of possibilities to quickly prototype solutions in professional settings but also opened the door for enthusiasts to learn about electronics and microcontrollers. In this article, we are going to see how to get started with an Arduino board and how to control it from a computer using Python. &lt;/p&gt;
&lt;p&gt;An Arduino is an electronics board packaging a micro-controller unit plus passive elements to ensure proper functioning, and headers to be able to interface with the real world very simply. But Arduinos are not just the electronics, they are also the ecosystem around them, including the software needed to program them as one sees fit.&lt;/p&gt;
&lt;p&gt;To get started, we assume you have access to an Arduino, such as the Uno, but most of the available ones are going to work fine. The Nano, Micro, Due, Mega, they all have different specifications, but the way you program and interface with them is more or less the same. In this article, we are not going to discuss electronics and how to build circuits, but just about the software side, so you can follow along even if you don't have an Arduino board at hand. &lt;/p&gt;
&lt;p&gt;The main goal of this tutorial is to show you how you can communicate with an Arduino using Python. This involves cleverly programming the Arduino and understanding some basic Python libraries which will allow you to build solutions very quickly. &lt;/p&gt;
&lt;h2&gt;Getting Started With Arduino&lt;/h2&gt;
&lt;p&gt;If you have an Arduino or equivalent at hand, the first thing you must do is installing the Arduino IDE. You can download it from &lt;a href="https://www.arduino.cc/en/Main/Software"&gt;here&lt;/a&gt;. Even though you can develop code online, I strongly suggest you have the tools on your computer, and use version control. For bigger projects, like the one we are going to build here, it is very handy to keep everything in the same place. &lt;/p&gt;
&lt;p&gt;After you install the program, just run the Arduino IDE. Note that the interface is very minimalistic but does exactly what it was designed to do. Connect your board to the computer. Click on Tools/Ports and you should see your board listed there. Note that in principle you could have several boards connected at the same time, and if you plug/unplug the board from the computer, the port may change. It is always wise to check whether the port is properly configured. &lt;/p&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;If you are on a Linux computer, you will need to add the appropriate permissions to work with the USB ports. You can follow &lt;a href="https://www.arduino.cc/en/guide/linux"&gt;this guide&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;The first Arduino program&lt;/h2&gt;
&lt;p&gt;We are going to build a very simple program that can read an analog signal. We are choosing this scenario because most boards can read an analog input. Moreover, analog inputs are susceptible to noise and this means the value can change if you approach your hand to it, touch it with a wire, etc. Digital ports, since they only produce one of two values, are a bit more resilient to this kind of testing. &lt;/p&gt;
&lt;p&gt;The first challenge a Python programmer faces when programming an Arduino is that the language is different. The Arduino IDE works with a language inspired by C and C++. It is not hard to understand, and there are many examples you can use as a starting point. Also, the programs you develop inside an Arduino are tightly coupled with the real world through sensors and actuators, and this adds a new layer of complexity. &lt;/p&gt;
&lt;h2&gt;The Arduino Program Loop&lt;/h2&gt;
&lt;p&gt;As soon as you start the Arduino IDE, you will find an almost blank file, in which to functions are defined:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;void setup() {
  // put your setup code here, to run once:
}

void loop() {
  // put your main code here, to run repeatedly:
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Arduino programs have two very distinctive stages: the &lt;strong&gt;setup&lt;/strong&gt; stage is where you initialize whatever needs to be initialized, such as serial communication, while the &lt;strong&gt;loop&lt;/strong&gt; is running continuously. So, imagine you want to switch on and off an LED, you would develop that piece of code in the &lt;strong&gt;loop&lt;/strong&gt;. &lt;/p&gt;
&lt;h2&gt;Switching on and off an LED (Blinking)&lt;/h2&gt;
&lt;p&gt;we are going to use the built-in LED of an Arduino UNO, but the majority of the other boards are going to work as well. The first step is to define the digital pin to which the LED is connected as an output pin. Since we need to do this only once, at the beginning of the program, we do it on the &lt;code&gt;setup&lt;/code&gt; function:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;void setup() {
  pinMode(LED_BUILTIN, OUTPUT);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You see here that we are using two variables: &lt;code&gt;LED_BUILTIN&lt;/code&gt; and &lt;code&gt;OUTPUT&lt;/code&gt; which were not defined anywhere. They are Arduino built-in constants, you can see more on the &lt;a href="https://www.arduino.cc/reference/en/"&gt;documentation&lt;/a&gt;. The next step is to switch on and off the LED, and we can do that on the ``loop```function:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;void loop() {
  digitalWrite(LED_BUILTIN, HIGH);
  delay(1000);
  digitalWrite(LED_BUILTIN, LOW);
  delay(1000);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the loop, what we are doing is setting the output digital pin to &lt;code&gt;HIGH&lt;/code&gt;, which means the LED will switch on. We wait for 1000 milliseconds and switch it off. Then it starts again, hence the name &lt;code&gt;loop&lt;/code&gt;. You can upload the code to your Arduino, and once it is done, you will see an LED on the board blinking. &lt;/p&gt;
&lt;p&gt;It is very important to note at this stage that there is no need to have a computer connected to the board. After you upload the program, you can power the Arduino with a USB charger and the LED will still blink. This is one of the nicest features of micro-controllers and is that they can run on their own, and normally they are much less error-prone than entire computers. &lt;/p&gt;
&lt;h2&gt;Monitoring the status of the board&lt;/h2&gt;
&lt;p&gt;The next step would be to be able to monitor from the computer whether the LED is on or off. Perhaps you would like to know whether it is working fine, or you would like to count the number of times it switches on, etc. For this, we will need to change a bit the code from the previous section. &lt;/p&gt;
&lt;p&gt;The first step is to think about how can the Arduino send information to the computer. As you may have already noticed, we used the USB port to load the program to the board, and thus, it is reasonable to think we can use the same connection to get data from the device, and you are right. To be able to send information we will need to use the &lt;code&gt;Serial&lt;/code&gt; communication. First, we establish the communication:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;void setup() {
  Serial.begin(19200);
  pinMode(LED_BUILTIN, OUTPUT);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note here that the argument of the &lt;code&gt;begin&lt;/code&gt; function is known as the baud rate. This fixes how fast data is transferred, and only a few values are acceptable, and &lt;code&gt;9600&lt;/code&gt; is perhaps the most common one. Remember the number you put in there since it will appear also later. We are now ready to send information through the serial to the computer:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;void loop() {
  Serial.write(&amp;quot;Switching ON&amp;quot;);
  digitalWrite(LED_BUILTIN, HIGH);  
  delay(1000);
  Serial.write(&amp;quot;Switching OFF&amp;quot;);
  digitalWrite(LED_BUILTIN, LOW);
  delay(1000);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, you can upload the program to the board and you will see that the LED still blinks. So, how can we see the information being printed to the serial communication? In the Arduino IDE open Tools/Serial Monitor. And now you should see that every time the LED changes from on to off or the other way around, there is a message appearing on the screen. &lt;/p&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;At the bottom of the serial monitor window, be sure you select the proper baud rate, or the messages are going to be nonsense.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Of course, you are probably also seeing that the messages get printed one after the other. This is because in serial communication there is no specific way of saying &lt;em&gt;this message has ended&lt;/em&gt;. Something that is sort of a standard is using special characters to mark the end of a message, such as the newline character. Such as with Python, newline is represented by &lt;code&gt;\n&lt;/code&gt;, so you can update the code to include it, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Serial.write(&amp;quot;Switching ON\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This discussion is important because we are not forced to use the new line character, we could have used anything we wanted. If you pay attention to the serial monitor window, you see there are some options regarding the line ending. We are going to keep the &lt;code&gt;\n&lt;/code&gt; but be aware that other programs and other hardware may use a different character.  &lt;/p&gt;
&lt;h2&gt;Controlling the LED&lt;/h2&gt;
&lt;p&gt;Right now the LED is switching independently from what we do with the computer. So now it is time to be able to control the LED at our own will from the computer. And probably you have anticipated it already, we are going to use the &lt;code&gt;Serial&lt;/code&gt; communication, but reading from it instead of just writing to it. Before going through a lengthier discussion on how to do things properly, let's quickly make a ping-pong program, i.e. one that replies with the same message we send:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;int val;

void setup() {
  Serial.begin(19200);
}

void loop() {
  if (Serial.available() &amp;gt; 0){
    val = Serial.read();
    Serial.write(val);
    Serial.write(&amp;quot;\n&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What you have to pay attention to is that we first define &lt;code&gt;val&lt;/code&gt; as an integer. In the &lt;code&gt;loop&lt;/code&gt;, we first check whether there is any serial data available. If there is, we read from it and write it back. We also write a newline, so things appear nicely formatted. &lt;/p&gt;
&lt;p&gt;If you open the serial monitor, you can now send messages to your device, and it will write them back to you. There are several things to notice here, first, what happens if you send a character such as an &lt;code&gt;a&lt;/code&gt; instead of a number? Surprisingly, you get the same character back. Even though &lt;code&gt;val&lt;/code&gt; is an integer, it gets converted to a character when writing on the serial. &lt;/p&gt;
&lt;p&gt;The second thing you have to see is what happens if you write several letters and then you press enter. You will see that every character gets a new line. This means that the &lt;code&gt;read&lt;/code&gt; method is getting byte by byte. You can try a lot of different things, such as what happens if you send non-ascii characters, if you put delays, etc. The fact that is so easy to play around with all the parameters can help you understand how serial communication works. &lt;/p&gt;
&lt;h3&gt;Controlling the LED&lt;/h3&gt;
&lt;p&gt;So, we know how to send a message to the Arduino and how to do something with the received message. We must now go one step further and change the LED to on or off based on the message we send. Let's quickly see a possible program to achieve it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;int val;

void setup() {
  Serial.begin(19200);
}

void loop() {
  if (Serial.available() &amp;gt; 0){
    val = Serial.read();
    Serial.write(&amp;quot;\n&amp;quot;);
    if(val==1){
      Serial.write(&amp;quot;ON\n&amp;quot;);
      }
    if(val==0){
      Serial.write(&amp;quot;OFF\n&amp;quot;);
      }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The program above will only write back to us whether we are switching on or off through the serial communication. We do this because it makes it very easy to debug. If something is not working we can check whether is the program or the electronics that are giving problems. After you upload the code above, and you try it, you will notice that it is not working. Can you guess why? &lt;/p&gt;
&lt;p&gt;We have seen earlier that the serial read gets bytes out of the communication. This means, that if we send a &lt;code&gt;1&lt;/code&gt;, it will be transformed into bytes, which will be received by the Arduino and then transformed back into a 1. It is not worth spending too much time on this topic at this stage, but it all relates to encoding characters. You can take a look at the &lt;a href="https://www.asciitable.com/"&gt;ascii table&lt;/a&gt; and notice that if you encode the character &lt;code&gt;1&lt;/code&gt;, you will get the bytes corresponding to the number 49, i.e.: &lt;code&gt;110001&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;The serial communication works by actually sending bite by bite of information in the form of a square wave. If the square wave is up, it corresponds to a 1, if it stays low, it is a 0, and so forth. Of course, to build a byte you need to have a fixed number of bits, or we would have problems knowing when one byte finished and the next started. Anyways, if we change the program above, we can use the information on the ascii table:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;void loop() {
  if (Serial.available() &amp;gt; 0){
    val = Serial.read();
    Serial.write(&amp;quot;\n&amp;quot;);
    if(val==49){
      Serial.write(&amp;quot;ON\n&amp;quot;);
      }
    if(val==48){
      Serial.write(&amp;quot;OFF\n&amp;quot;);
      }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you test it, you will see that this is working fine. If you send a 1, the serial will get the &lt;code&gt;ON&lt;/code&gt; message, and the opposite if you send a 0. However, is this useful? I would argue strongly against it since it is very hard to understand the comparison to &lt;code&gt;49&lt;/code&gt; and to &lt;code&gt;48&lt;/code&gt;. The best would be to change the value you are reading into a string or an integer which we can compare. For simplicity let's just focus on converting to an integer, we just need to change the line in which we read and the comparison lines:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;void loop() {
  if (Serial.available() &amp;gt; 0){
    int val = char(Serial.read())-'0';
    Serial.println(val);
    Serial.write(&amp;quot;\n&amp;quot;);
    if(val == 1){
      Serial.write(&amp;quot;ON\n&amp;quot;);
      }
    if(val == 0){
      Serial.write(&amp;quot;OFF\n&amp;quot;);
      }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you see, how we change from bytes to an integer is slightly convoluted. We exploit the fact that characters are essentially numbers, and that they are in order on the ascii table. If we subtract the 0, we will start counting in the proper position. Nonetheless, the code shown above works. If we send a 1 to the Arduino we get the proper message back. To switch ON/OFF the LED, we just need to add the proper instructions. The final code would look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;void setup() {
  Serial.begin(19200);
  Serial.flush();
  pinMode(LED_BUILTIN, OUTPUT);
}

void loop() {
  if (Serial.available() &amp;gt; 0){
    int val = char(Serial.read())-'0';
    Serial.println(val);
    Serial.write(&amp;quot;\n&amp;quot;);
    if(val == 1){
      Serial.write(&amp;quot;ON\n&amp;quot;);
      digitalWrite(LED_BUILTIN, HIGH);  
      }
    if(val == 0){
      Serial.write(&amp;quot;OFF\n&amp;quot;);
      digitalWrite(LED_BUILTIN, LOW);
      }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you are effectively switching ON/OFF an LED from the computer. I don't know about you, but I find this incredibly rewarding. Probably your head is already branching out to different possibilities. There is only one more topic to cover before we move into Python. &lt;/p&gt;
&lt;h2&gt;Reading a signal&lt;/h2&gt;
&lt;p&gt;Arduinos allow you to interact with the world not only by setting parameters, such as an LED, on or off, but also by reading values from the environment. Normally, you would need some sensor to make a valuable reading, but we are just going to read noise, so we don't worry about having a sensor at hand, and without worrying about going out of range. Let's quickly see how to get an analog signal:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int analogPin = A0;
int val = 0;  

void setup() {
  Serial.begin(19200);
}

void loop() {
  val = analogRead(analogPin);
  Serial.println(val);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The only part of the code which may not be self-explanatory is the first line. &lt;code&gt;A0&lt;/code&gt; represents the input port we are reading, in this case, it is the analog port number 0. Almost all Arduino boards have analog inputs to read, the amount, however, can change. You can run the program above and see that there are a lot of numbers appearing on the screen. &lt;/p&gt;
&lt;p&gt;If you move the board, and especially if you touch the pins from below, you will see that these numbers can change. Interesting, don't you think? It is up to you, at this stage, to come with an explanation of why this happens. &lt;/p&gt;
&lt;p&gt;Probably you noticed also that we are using &lt;code&gt;println&lt;/code&gt; instead of &lt;code&gt;write&lt;/code&gt;. This is handy because we can then forget about the line ending. We are almost done with the introduction to the Arduino, we have just to cover a detail.&lt;/p&gt;
&lt;h2&gt;Triggering a measurement&lt;/h2&gt;
&lt;p&gt;Up to now, we used the serial input just to switch the LED on or off. We can use the same approach to read the analog channel. It takes no time to implement, the full code would be:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;int analogPin = A0;
int val = 0;

void setup() {
  Serial.begin(19200);
  Serial.flush();
  pinMode(LED_BUILTIN, OUTPUT);
}

void loop() {
  if (Serial.available() &amp;gt; 0) {
    int val = char(Serial.read()) - '0';
    if (val == 1) {
      Serial.write(&amp;quot;ON\n&amp;quot;);
      digitalWrite(LED_BUILTIN, HIGH);
    }
    if (val == 0) {
      Serial.write(&amp;quot;OFF\n&amp;quot;);
      digitalWrite(LED_BUILTIN, LOW);
    }
    if (val == 2) {
      val = analogRead(analogPin);
      Serial.println(val);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, if you send a &lt;code&gt;1&lt;/code&gt;, the LED switches on, off with a &lt;code&gt;0```, and if you send a&lt;/code&gt;2``, you will get the reading from the analog port number 0. We are all set to go to hook it up to Python. &lt;/p&gt;
&lt;h2&gt;Reading the Arduino from Python&lt;/h2&gt;
&lt;p&gt;We know how to send a command from the serial monitor of the Arduino IDE, but this may be very limiting. Let's see how can we control our Arduino board using Python. To control devices, we will need some libraries installed. Perhaps you noticed that we have always been talking about serial communication. Serial is an old standard, which is normally associated with the bulky &lt;a href="https://en.wikipedia.org/wiki/RS-232"&gt;RS-232&lt;/a&gt; connectors. Even though the connectors have fallen in disgrace, the protocol for sharing data is as alive as always was. The trick is that the Arduino has a built-in chip that transforms the USB port into a Serial device. A little trick that saves a lot of effort when programming the boards. &lt;/p&gt;
&lt;p&gt;So, let's first get the basic library we need, &lt;strong&gt;pyserial&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install pyserial
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is the basic building blog for communicating with serial devices on Python. Be extra careful because there is another library called &lt;strong&gt;serial&lt;/strong&gt; which has nothing to do with serial communication. &lt;/p&gt;
&lt;p&gt;Now that we have it installed, we can test it, by making it list all the serial devices connected to our computer:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;python -m serial.tools.list_ports
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output depends on your operating system. If you are on Windows, this is what you would get something like:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;COM4
1 ports found
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you are on Linux or Mac, something like:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;/dev/ttyACM0
1 ports found
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The name of the port you are getting is the same you should have used when developing with the Arduino IDE. However, it may also be that if you plug/unplug the board, reboot the computer, etc. it changes. Note the port name, since we are going to use it extensively, and you will need to replace it on your code. &lt;/p&gt;
&lt;p&gt;Let's move to Python now. &lt;/p&gt;
&lt;p&gt;Start a Python console so we can start playing with our board. We start by importing the needed libraries and opening the communication with the device:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; import serial
&amp;gt;&amp;gt;&amp;gt; dev = serial.Serial(&amp;quot;COM4&amp;quot;, baudrate=19200)
&lt;/code&gt;&lt;/pre&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;If you already established communication with the board from another application, such as the Serial Monitor of the Arduino IDE, you will probably get an error saying the resource is busy. Close any application communicating with the board and start again&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Two important things in the sample code above. First, you should replace &lt;code&gt;COM4&lt;/code&gt; by the serial port you got earlier. The second, the baud rate is given by the Arduino program we developed in the previous sections. We could have programmed the Arduino to work at 9600, and there is no a-priory way of knowing. You are left to the documentation of the hardware to know what is the proper baud rate to communicate. Not even the serial monitor of the Arduino IDE can pick it up automatically. &lt;/p&gt;
&lt;p&gt;And now, to the juicy part. Let's switch on and off an LED:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; dev.write(b'1')
&amp;gt;&amp;gt;&amp;gt; dev.write(b'0')
&amp;gt;&amp;gt;&amp;gt; dev.write(b'1')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I know, I know, could have been much much better! You can have a for loop, accept input, etc. It is important to note that we are using a &lt;code&gt;b&lt;/code&gt; in front of the command we are sending. This is to tell Python to &lt;em&gt;encode&lt;/em&gt; the string before sending it. Remember that Arduino works with bytes, and therefore we must tell Python to transform a string to bytes before sending it. Without entering into the discussion of what encoding characters mean, another way of doing the same is by explicitly using the &lt;code&gt;encode&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; data = '1'
&amp;gt;&amp;gt;&amp;gt; data.encode('ascii')
b'1'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we are selecting &lt;code&gt;ascii&lt;/code&gt; to encode, we could have used other encoding options, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;data.encode('utf-8')
b'1'
data.encode('utf-16')
b'\xff\xfe1\x00'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you see, if we use UTF-8, the representation is the same as using ascii, while if we use UTF-16, it is radically different. Anyways, Arduinos work with ascii characters, and therefore we should stick to them. &lt;/p&gt;
&lt;p&gt;You probably remember that every time we were setting the LED, there was a message confirming it. So we can also quickly read from the Arduino:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; dev.write(b'1')
&amp;gt;&amp;gt;&amp;gt; print(dev.readline())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, at this stage, is when things can get messy. I decided not to show you the output of the print on purpose. Are you seeing the output you are expecting? Probably not. This happens because messages accumulate on a buffer, and you read whatever is available. You can try to use the &lt;code&gt;readline()&lt;/code&gt; several times and you will see that the output keeps changing... Until it doesn't work anymore. When you use &lt;code&gt;readline()&lt;/code&gt;, Python will wait until there is a line to read (something that ends with a &lt;code&gt;\n&lt;/code&gt;.) If your program hangs waiting for data, you can press &lt;code&gt;Ctrl&lt;/code&gt;+&lt;code&gt;C&lt;/code&gt;to stop the execution. &lt;/p&gt;
&lt;p&gt;Now we can move what we learned to a Python script:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import serial


dev = serial.Serial(&amp;quot;COM4&amp;quot;, baudrate=19200)
dev.write(b'1')
print(dev.readline())
dev.write(b'0')
print(dev.readline())
dev.write(b'1')
print(dev.readline())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run this program, probably it will hang forever. The LED will not blink, nor the message will be printed to screen. This happens because we write to the device before it is ready to receive commands. Therefore, in the following step, when we try to read from it, nothing will be displayed. This can be easily solved by adding a delay after opening the communication with the board (some lines were removed for clarity):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from time import sleep

dev = serial.Serial(&amp;quot;COM4&amp;quot;, baudrate=19200)
sleep(1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can make our LED blink, we can also read the analog signal, this time let's make it a bit more sophisticated, using a loop:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;data = []
for _ in range(10):
    dev.write(b'2')
    line = dev.readline()
    data.append(line)

print(data)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we will get an output like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;[b'493\r\n', b'502\r\n', b'499\r\n', b'495\r\n', b'495\r\n', b'496\r\n', b'496\r\n', b'492\r\n', b'490\r\n', b'490\r\n']
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, note that the output is all strings prepended with a &lt;code&gt;b&lt;/code&gt;. We can get read of it if we know how to encode/decode the strings. We so earlier that we were encoding strings as &lt;em&gt;ascii&lt;/em&gt;, therefore, we can do the opposite:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;data.append(line.decode('ascii'))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, we still see the end of the line. You see we are getting '\r\n', which corresponds to the output of the &lt;code&gt;Serial.println(val);&lt;/code&gt; on the Arduino code. Pay attention to the fact that &lt;code&gt;println&lt;/code&gt; uses that specific line ending, which is two characters long. It is very easy to remove, I'm splitting it to several lines for clarity:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;line = dev.readline()
line = line.decode('ascii')
line = line.strip()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now we got just the numbers as strings... Of course, if you would like to use the numbers, you should translate them, in our case they are integers, so we can do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;line = int(line.decode('ascii'))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which will take care of stripping the newline characters for us.&lt;/p&gt;
&lt;h2&gt;Querying the device&lt;/h2&gt;
&lt;p&gt;Perhaps you have noticed in the previous examples that we are always following the same flow: We write to the device, we read back from the device. This can be called querying a device. This is how many commercial devices work, but it is not mandatory. For example, we could have the Arduino writing to the serial port continuously, and whenever we start reading from it, we will get the data out. However, this flow was not triggered from the computer. What you want to achieve with the board is up to you, here we stick to the querying approach. &lt;/p&gt;
&lt;p&gt;Since we are going to repeat this over and over, we can abstract this cycle to a method in a class. Something reasonable would be:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Arduino:
    def __init__(self, port):
        self.dev = serial.Serial(port, baudrate=19200)
        sleep(1)

    def query(self, message):
        self.dev.write(message.encode('ascii'))
        line = self.dev.readline().decode('ascii').strip()
        return line
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then, to repeat the steps from before, including the LED blinking:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;ard = Arduino('COM4')

for _ in range(10):
    print(ard.query('1'))
    sleep(0.5)
    print(ard.query('0'))
    sleep(0.5)

data = []
for _ in range(10):
    data.append(ard.query('2'))

print(data)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It was on purpose that the change to integers was not added to the &lt;code&gt;query&lt;/code&gt; method: it works only if you are getting an integer. Arduino can output other information, such as &lt;code&gt;ON&lt;/code&gt; or &lt;code&gt;OFF&lt;/code&gt; when changing the LED. Remember that you have absolute control. If you just want to output integers, specifying that 10 means LED on, and 22 means LED OFF, then it is up to you and what you judge best for your application. &lt;/p&gt;
&lt;p&gt;What you can see is that once you abstract some common patterns into a class, the rest of the code becomes much clearer. Of course, if you see something like &lt;code&gt;query('1')&lt;/code&gt; you have no idea what it means unless you have access to the device documentation. All this can be greatly improved, there are a lot of standards in the industry, and just common sense can take you a long way ahead. &lt;/p&gt;
&lt;h2&gt;PyVISA&lt;/h2&gt;
&lt;p&gt;The last topic I would like to cover in this tutorial is that, as you may have guessed, a lot of devices follow the same patterns, not only those connecting through the serial port but also through USB, TCP/IP, GPIB, etc. Also, different brands produce the same type of devices, for example, you can get two oscilloscopes from different brands, etc. Standardizing the way you can communicate with those devices makes developing software much easier since once you have a solution, you can use it even if you change your instrument. &lt;/p&gt;
&lt;p&gt;The standard most companies follow, is called VISA, which stands for Virtual instrument software architecture. VISA allows us to abstract a lot of the work done by software into standard packages. Without entering into too much detail, we can use this standard directly from Python. You have to install only two packages:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install pyvisa pyvisa-py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is important to note that pyvisa relies on having a backend on your computer. There are several backends available that should be interchangeable, provided that they follow the VISA standards. A popular one is the National Instruments VISA or the Tektronix VISA library. To avoid going through the trouble of installing them, we opted for the pure python implementation of the VISA standard, called &lt;code&gt;pyvisa-py&lt;/code&gt;. Quickly, just to show you how it works with our very basic Arduino board:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; import visa
&amp;gt;&amp;gt;&amp;gt; rm = visa.ResourceManager('@py')
&amp;gt;&amp;gt;&amp;gt; rm.list_resources()
('ASRLCOM4::INSTR',)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This last line will change according to your operating system and the port where the board is connected. Check that we still get the &lt;code&gt;COM4&lt;/code&gt; in between the information, because it is the same. And then we just use it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; inst = rm.open_resource('ASRLCOM4::INSTR', baud_rate=19200)
&amp;gt;&amp;gt;&amp;gt; print(inst.query('2'))
442
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And you see that we got a value without the &lt;code&gt;b&lt;/code&gt; nor the line endings. This means that the people at PyVISA took care of implementing the same features, and even more! For example, check what happens if you query a value that we didn't implement in Arduino:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; inst.query('3')
...
pyvisa.errors.VisaIOError: VI_ERROR_TMO (-1073807339): Timeout expired before operation completed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You will see that instead of hanging forever, such as would be the case in our custom class, visa can stop and warn us that a timeout happened. If you head over to the &lt;a href="https://pyvisa.readthedocs.io/en/latest/introduction/index.html"&gt;pyVISA documentation&lt;/a&gt; you will learn that there is almost nothing out of your control. Would you like to make longer timeouts? Just modify the value of the instrument:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; inst.timeout = 5000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This sets the timeout to 5 seconds, and you can immediately see that if you run the command from before it will take longer to raise an Exception. I strongly encourage you to go over the pyVISA documentation, because that would also give you a lot of inspiration on how to design your board's software to accept commands from the computer.&lt;/p&gt;
&lt;h2&gt;Next Steps&lt;/h2&gt;
&lt;p&gt;Be aware that the code above, even if it does not have bugs, will have a lot of problems if you keep using it in larger projects. We didn't take care of line endings, for example. We always assumed commands to be just one byte (a &lt;code&gt;1&lt;/code&gt;, a &lt;code&gt;2&lt;/code&gt;, etc.) but this is not realistic. Imagine if you would like the Arduino to acquire a variable number of values of the analog signal and return the average. You will need to find a smarter approach to sharing information between the computer and the board. &lt;/p&gt;
&lt;p&gt;!! warning 
  This article is meant to get you started, not to be a comprehensive guide on how to interact with the Arduino boards&lt;/p&gt;
&lt;p&gt;One thing you can do is to decide which character ends a command. A standard is to use &lt;code&gt;\n&lt;/code&gt;, the newline. Then, you can read the serial port from the Arduino, until that character appears and then you know the command is done. This gives you a lot of flexibility if you want to send commands of variable length. For example, imagine you want to acquire 10 or 100 data points, a possible command would be &lt;code&gt;ACQ:10&lt;/code&gt;, or &lt;code&gt;ACQ:100&lt;/code&gt;. From the board perspective, since each character comes sequentially, how would it know that it was a 10, but nothing else is coming after it? &lt;/p&gt;
&lt;p&gt;Another useful strategy to make your commands clear is to use a separator, such as &lt;code&gt;:&lt;/code&gt;. Imagine you want to read a digital channel, a command could be &lt;code&gt;DI:1&lt;/code&gt;, of Digital Input, number 1. To set a digital output: &lt;code&gt;DO:2:1&lt;/code&gt; meaning setting the Digital Output number 2 to the value of &lt;code&gt;1&lt;/code&gt;. However, you see that they start to be harder to read. What about &lt;code&gt;DO:CH2:1&lt;/code&gt;. Then, I believe is much clearer. This means you should update the input command to &lt;code&gt;DI:CH1&lt;/code&gt;. This allows you to grow the commands without conflicts if you know what you will need at a later stage. &lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;Arduinos open a completely new world of possibilities. The main difficulty is that you have to plan your code from two different perspectives: the board and the computer. You need to decide what information you want to take out of your board and into the computer, and how you are going to ask for that information. The more complex the expectation, the more important it is to structure your code smartly. &lt;/p&gt;
&lt;p&gt;The examples we have shown in this article are extremely basic and do not follow best practices. For example, you can check the &lt;a href="https://github.com/PFTL/SimpleDaq/blob/master/extras/arduino_firmware/arduino_firmware.ino"&gt;Arduino code&lt;/a&gt; that runs on the devices I use for the &lt;a href="https://www.pythonforthelab.com/courses/python-for-the-lab"&gt;Python for the Lab Workshops&lt;/a&gt;. Or &lt;a href="https://github.com/aquilesC/DisperPy/blob/master/dispertech/controller/devices/arduino/arduino_driver/arduino_driver.ino"&gt;this example&lt;/a&gt; in which I control several LEDs, two temperature sensors and a two-axis piezo stage. If you are working with an Arduino and want to learn more on how you can communicate with it from Python, leave a message below, I would really like to hear about what you are doing and how I can help you achieve it!&lt;/p&gt;</content><category term="blog"></category><category term="driver"></category><category term="arduino"></category><category term="control"></category></entry><entry><title>How to create a setup file for your project</title><link href="https://www.pythonforthelab.com/blog/how-create-setup-file-your-project" rel="alternate"></link><published>2020-01-20T00:00:00+01:00</published><updated>2020-01-20T00:00:00+01:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2020-01-20:/blog/how-create-setup-file-your-project</id><summary type="html">&lt;p&gt;When you develop software, at some point you will want other people to be able to use what you have built. Sometimes it is handy if you can quickly use the code you developed yourself in the past on a new machine or a different virtual environment. We have already …&lt;/p&gt;</summary><content type="html">&lt;p&gt;When you develop software, at some point you will want other people to be able to use what you have built. Sometimes it is handy if you can quickly use the code you developed yourself in the past on a new machine or a different virtual environment. We have already seen that &amp;lt;:Complete Guide to Imports in Python: Absolute, Relative, and More|for importing&amp;gt; to work properly, it is very important to have well-defined packages, and that Python knows where to find them. &lt;/p&gt;
&lt;p&gt;With a proper setup file, Python will quickly understand where to find the package, and thus importing from other places becomes trivial. It will also be possible to quickly distribute the code with other people, diminishing the barrier of adoption. Having a &lt;strong&gt;setup.py&lt;/strong&gt; file is the first step into being able to switch from scripts to a package on which to rely. &lt;/p&gt;
&lt;h2&gt;Your first setup file&lt;/h2&gt;
&lt;p&gt;The examples we are going to develop are toy examples, very similar to the ones on &amp;lt;:Complete Guide to Imports in Python: Absolute, Relative, and More|the article about importing&amp;gt;. But they will prove the point. You should start on an empty directory, the name doesn't matter, but it is important not to mix it with other things, so you can follow this article without complications. &lt;/p&gt;
&lt;p&gt;Let's start by creating a file called &lt;strong&gt;first.py&lt;/strong&gt;, with the following code inside:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def first_function():
    print('This is the first function')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This file is what we want to be able to use from other packages, etc. What we would like to be able to achieve is to run code like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from first import first_function

first_function()
# 'This is the first function'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next to the file, let's create a new file called &lt;strong&gt;setup.py&lt;/strong&gt;, with the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from setuptools import setup

setup(
    name='My First Setup File',
    version='1.0',
    scripts=['first.py'],
)
&lt;/code&gt;&lt;/pre&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;The code we are developing is harmless, nevertheless, it is always wise to create a virtual environment to play around, and eventually discard once you understood and polished the details&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;To install your script, you can simply do the following from the console:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;python setup.py install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You will see some information printed to the screen. More importantly, you can now use your package from anywhere else on your computer. For example, change your directory to anywhere else on your computer, and to the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from first import first_function
first_function()
# This is the first function
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is great, now you have a way of using your program from anywhere else, even from other packages. &lt;/p&gt;
&lt;h3&gt;Laying out the project&lt;/h3&gt;
&lt;p&gt;In the example above we had only one script available, and thus the structure of the program was straightforward. However, this is rarely the case. As soon as your program starts having multiple files, you will need to structure it in such a way that &lt;code&gt;setup&lt;/code&gt; knows what files are needed. Let's evolve the example above. Let's create now a package with tho modules, the folder structure will look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-txt"&gt;.
├── my_package
│   ├── __init__.py
│   ├── mod_a
│   │   ├── file_a.py
│   │   └── __init__.py
│   └── mod_b
│       ├── file_b.py
│       └── __init__.py
└── setup.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let's develop two very simple function inside &lt;strong&gt;file_a&lt;/strong&gt; and &lt;strong&gt;file_b&lt;/strong&gt;, respectively:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def function_a():
    print('This is function_a')
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def function_b():
    print('This is function_b')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We need to update the &lt;strong&gt;setup.py&lt;/strong&gt; file to accommodate that the program is more complex than what it was before. Fortunately, the developers at setuptools made our life very easy, we just need to write the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from setuptools import setup, find_packages

setup(
    name='My First Setup File',
    version='1.0',
    packages=find_packages()
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have removed the &lt;code&gt;script&lt;/code&gt; argument, but have added the &lt;code&gt;packages&lt;/code&gt; argument. &lt;code&gt;find_packages&lt;/code&gt; will automatically look for packages in a given directory. If we don't provide any arguments, it will look in the current folder. If you want to see it in action, you can do the following within a python interpreter:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; from setuptools import find_packages
&amp;gt;&amp;gt;&amp;gt; find_packages()
['my_package', 'my_package.mod_b', 'my_package.mod_a']
&amp;gt;&amp;gt;&amp;gt; find_packages(where='my_package')
['mod_b', 'mod_a']
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So now you see, find packages returns a list with the names of the packages we will include in the setup. If you want to have finer control, you can replace &lt;code&gt;find_packages&lt;/code&gt; and type down exactly what you want to include in your install. Also, if your code would be inside of an extra folder, for example &lt;code&gt;src&lt;/code&gt;, you would need to specify it: &lt;code&gt;find_packages(where='src')&lt;/code&gt;. I, personally, prefer to keep the code directly in a folder next to the setup file, with a name that makes it very clear that it is the entire package inside, just like in the example in this section. Again, if you just install the code, &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;python setup.py install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;you will be able to use it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; from my_package.mod_b.file_b import *
&amp;gt;&amp;gt;&amp;gt; function_b()
This is function_b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With everything you know from importing files in Python, it is now dead easy to use relative, absolute imports, etc. because everything is added to the path by the installation procedure. &lt;/p&gt;
&lt;h3&gt;Installing in development mode&lt;/h3&gt;
&lt;p&gt;One of the important things to point out is that the setup process can be very helpful also while developing, not only when you are releasing the code. This can be achieved by installing the code in &lt;strong&gt;development mode&lt;/strong&gt;. The only thing you need to do is to run the setup script with a different argument:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;python setup.py develop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, if you change any of your files, it will be reflected, in your code. For example, let's edit &lt;em&gt;file_b.py&lt;/em&gt;*:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def function_b():
    print('This is New function_b')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you use the module again, you will see the output was modified:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; from my_package.mod_b.file_b import *
&amp;gt;&amp;gt;&amp;gt; function_b()
This is New function_b
&lt;/code&gt;&lt;/pre&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;Remember that if you change a module in Python, you will need to restart the interpreter. Once you import a module, Python will skip any new import statements of the same packages.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;One of the best things about this approach is that if you add a new module to your package, it will still work fine. For example, let's create a new module &lt;strong&gt;C&lt;/strong&gt;, which uses what is already available in &lt;strong&gt;a&lt;/strong&gt; and &lt;strong&gt;b&lt;/strong&gt;, using two different import approaches. Create a folder called &lt;strong&gt;mod_c&lt;/strong&gt;, with a file &lt;strong&gt;file_c.py&lt;/strong&gt;, and add the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from ..mod_a.file_a import  function_a
from my_package.mod_b.file_b import function_b

def function_c():
    print('This is function c')
    function_a()
    function_b()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we can simply use it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; from my_package.mod_c.file_c import function_c
&amp;gt;&amp;gt;&amp;gt; function_c()
This is function c
This is function_a
This is New function_b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you see that by having a setup.py file, using relative and absolute imports became trivial. No more worries about the system path, the python path, etc. everything is taken care of. Having a setup.py even when you are just starting makes your life much easier. You stop worrying about where the code is, how to import it, etc.&lt;/p&gt;
&lt;h3&gt;But where is the code?&lt;/h3&gt;
&lt;p&gt;At some point, you may be wondering what is happening to your code that makes it work. I will assume you are working within a virtual environment (because that is what you should be doing anyway), and that you know where is your virtual environment located (i.e. the folder where everything is stored). Navigate to the &lt;code&gt;site-packages&lt;/code&gt; folder, in my case, it is located in:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;venv/lib/python3.6/site-packages
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;venv&lt;/strong&gt; is the name of the virtual environment. &lt;strong&gt;python3.6&lt;/strong&gt; is the version I am using now, but it can be different for you. Before you install anything else, just after a fresh virtual environment is created, the contents of the folder are very limited. You have pip, setuptools, and not much more. Let's install the package in development mode:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;python setup.py develop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And if you look at the contents of the &lt;strong&gt;site-packages&lt;/strong&gt; folder, you will notice a new file created: &lt;strong&gt;My-First-Setup-File.egg-link&lt;/strong&gt;. Pay attention that the name of the file is associated with the &lt;strong&gt;name&lt;/strong&gt; argument we used in the &lt;code&gt;setup.py&lt;/code&gt; file. You can open the file with any text editor, what do you see? Indeed, you see the full path to the directory that contains the *&lt;em&gt;my_package&lt;/em&gt; folder. That file can tell the Python interpreter what should be added to its path to work with our module. You see that it is not a lot of work, but being able to do it from a single command pays off. &lt;/p&gt;
&lt;p&gt;If you, on the other hand, install the package:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;python setup.py install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You will see that what gets installed in the &lt;strong&gt;site-packages&lt;/strong&gt; folder is radically different, you will find a file called &lt;strong&gt;My_First_Setup_File-1.0-py3.6.egg&lt;/strong&gt;. Egg files are just zip files that Python can uncompress and use when required. You can easily open the file with the same program you use to open zip files, and you will find a copy of your code. The folders, the files, etc. plus some metadata of your program, such as the author, license, etc. (which we haven't used yet in your simple setup file). Whenever you change your project files, they won't become available on your other programs, because now Python has its copy of the source code. Whenever you change a file you will need to run the setup script again:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;python setup.py install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the code will be refreshed and you can use the new development. You have to be careful, because it is very easy to forget to run again the setup script, and you will be banging your head against the wall trying to find why your bugs are still there if you solved them in your code. If you are developing a solution and trying things out, you should avoid the setup install and keep the &lt;code&gt;setup.py develop&lt;/code&gt; approach. &lt;/p&gt;
&lt;h3&gt;Installing with pip&lt;/h3&gt;
&lt;p&gt;Just for completeness, it is important to show that once you have your &lt;strong&gt;setup.py&lt;/strong&gt; file in place, you can also use pip to install it by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note two things: if you used the &lt;code&gt;python setup.py&lt;/code&gt; approach, you should first remove the files created on your &lt;code&gt;site-packages&lt;/code&gt; folder, or pip will fail with a cryptic message. Also, note the &lt;code&gt;.&lt;/code&gt; after the install, this is important to tell pip you want to install &lt;em&gt;this&lt;/em&gt; package. The install always takes the name of the package you would like to install. One of the advantages of using pip for installing is that you also get the uninstall for free. However, to uninstall you need to use the name you gave to your package:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip uninstall My-First-Setup-File
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you see that the name we gave to our package is independent of how we use it. We had to import &lt;code&gt;my_package&lt;/code&gt;, while the actual name is &lt;code&gt;My-First-Setup-File&lt;/code&gt;. This, in my opinion, can create a lot of headaches. For example, if you want to communicate with a serial device, you install a package called &lt;code&gt;PySerial&lt;/code&gt;, while to use it you have to &lt;code&gt;import serial&lt;/code&gt;. It may not seem like a big issue at the beginning until you find two packages with different names which define two different modules with the same name &lt;code&gt;serial&lt;/code&gt;.  Imagine we change the name of &lt;strong&gt;my_packe&lt;/strong&gt; to &lt;strong&gt;serial&lt;/strong&gt;. And we do the following:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bash
pip install .
pip install pyserial&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;If you explore the folder &lt;strong&gt;serial&lt;/strong&gt; within your &lt;strong&gt;site-packages&lt;/strong&gt; you will see that both your code and &lt;strong&gt;pyserial&lt;/strong&gt; are mixed up. There is no warning of this clash, and the results can be an absolute disaster, especially if the top-level &lt;code&gt;__init__.py&lt;/code&gt; file is used somehow. The example above may seem a bit far-fetched for some. But you would be surprised to know that there are two packages: &lt;strong&gt;pyserial&lt;/strong&gt; and &lt;strong&gt;serial&lt;/strong&gt; which are used for some very different tasks and both specify the same module name. &lt;/p&gt;
&lt;h3&gt;Installing from Github&lt;/h3&gt;
&lt;p&gt;One of the advantages of creating &lt;strong&gt;setup.py&lt;/strong&gt; files is that you can directly install packages available on Github (or on any other online repository). For example, if you would like to install the code of this tutorial, which can be &lt;a href="https://github.com/PFTL/website_example_code"&gt;found here&lt;/a&gt;, you can run:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install git+https://github.com/PFTL/website_example_code.git#subdirectory=code/38_creating_setup_py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are several things to note on the code above. First, it will not work on Windows as it is written. You will need to enclose the repository address with &lt;code&gt;"&lt;/code&gt; so it understands it is the path to a repository. Note that we have used &lt;code&gt;git+https&lt;/code&gt; because it is the simplest way of making it work. If you have configured your ssh keys properly, you can also use &lt;code&gt;pip install git+git&lt;/code&gt;, which can give you access to private repositories as well. We have used &lt;code&gt;github.com&lt;/code&gt;, but you can use any other version control platform you like, including Gitlab and bitbucket. The path up to &lt;code&gt;website_example_code.git&lt;/code&gt; is simply the location of the repository, but in our case, the &lt;strong&gt;setup&lt;/strong&gt; file is inside of a subdirectory, that is why we appended the &lt;code&gt;#subdirectory=code/38_creating_setup_py&lt;/code&gt; information. But if it is not the case, you can skip that extra information. &lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;In most repositories, the &lt;strong&gt;setup.py&lt;/strong&gt; is at the top level, and thus you won't need to specify a subdirectory to use it.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Now you see that it is very easy to share with others, you just need to put the code in a place that can be accessed by others. However, when you start sharing code, there are other things you need to be aware of. Imagine you update your code. In our case, we changed what &lt;strong&gt;function_c&lt;/strong&gt; does. If we upload the code to Github, and then you run the same command as above, buried within a lot of information, there will be a line saying:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;Requirement already satisfied (use --upgrade to upgrade)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This means that the code was not changed, because pip found that the package was already installed. You can run the same code with the extra &lt;code&gt;--upgrade&lt;/code&gt; argument, and you will see that indeed it updates the code. &lt;/p&gt;
&lt;p&gt;Just to close the discussion with pip installations, there is a very nice feature that allows you to install the package in editable mode, meaning that you can make changes and submit them to version control. This is ideal if you are willing to contribute to a package that is part of the requirements of your current project. In that case, you can run pip like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install -e git+git://github.com/PFTL/website_example_code.git#egg=my_test_package-1.0\&amp;amp;subdirectory=code/38_creating_setup_py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And if you explore your virtual environment, you will find a folder called &lt;strong&gt;src&lt;/strong&gt; in which the package is available. Not only that, but the package itself is a git repository you can use as any other repository. You will also find a file within &lt;em&gt;site-packages&lt;/em&gt; linking to the directory where the code is, including its subdirectory.  &lt;/p&gt;
&lt;h2&gt;Adding an entry point&lt;/h2&gt;
&lt;p&gt;So far everything is working great, and probably you have plenty of ideas in your head about what can be done with a setup file. But what we have seen up to now is only the beginning. In the examples above, we have always installed a package that could be imported from other packages. This is great for a lot of applications, but in a lot of situations, you would like to be able to run your program directly, without the need to import from another script. That is when entry points become your best friends. &lt;/p&gt;
&lt;p&gt;Let's creat a new file, called &lt;strong&gt;start.py&lt;/strong&gt; at the top directory, &lt;strong&gt;my_package&lt;/strong&gt;, and let's add the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from .mod_c.file_c import function_c


def main():
    function_c()
    print('This is main')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This file in itself does not do anything, but the function &lt;code&gt;main&lt;/code&gt; will generate an output of we run it. If we go back to &lt;strong&gt;setup.py&lt;/strong&gt;, we can add the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from setuptools import setup, find_packages

setup(
    name='My First Setup File',
    version='1.1',
    packages=find_packages(),
    entry_points={
        'console_scripts': [
            'my_start=my_package.start:main',
        ]
    }
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that we have added a new argument, called &lt;code&gt;entry_points&lt;/code&gt;. We want to have a console script, meaning something we can run as a command from the terminal. We call it &lt;code&gt;my_start&lt;/code&gt;, and then we specify the path to it in the form &lt;code&gt;module.file:function&lt;/code&gt;. The last argument must be a callable, something we can execute. If you install our package again:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;python setup.py develop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We will be able to run &lt;code&gt;my_start&lt;/code&gt; directly from the terminal:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ my_start
This is New function_b
This is main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you want to know where the command is located, you can run (Linux and Mac, not Windows):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;which my_start
[]/venv/bin/my_start
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Windows&lt;/strong&gt; users need to run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;where my_start
[]/venv/Scripts/my_start.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, the script is located inside the &lt;code&gt;bin&lt;/code&gt; folder of your virtual environment. One of the nicest things of doing this is that if you are on Windows it will also work. You see that it creates an executable &lt;code&gt;.exe&lt;/code&gt; file. The function you run as an entry point can be further extended with arguments, etc. but this is for another discussion. &lt;/p&gt;
&lt;p&gt;If you are building an application with a user interface, instead of using &lt;code&gt;console_scripts&lt;/code&gt; you can use &lt;code&gt;gui_scripts&lt;/code&gt;. On Windows, this will allow you to run the program without opening a terminal in the background, and this will look more professional. But is nothing you can't live without. &lt;/p&gt;
&lt;p&gt;Remember that you can add as many entry points as you wish. If your program can perform very different tasks, perhaps you would prefer to have different entry points instead of an endless list of arguments which alter the behavior. It is up to you to choose what you believe is the best approach. &lt;/p&gt;
&lt;p&gt;For consistency, there is one extra thing to mention. Right now, with the entry point, we have a script that runs a specific task, but we can't run our package directly from Python. Thus, let's create a file at the top-level directory of the package, called &lt;strong&gt;&lt;strong&gt;main&lt;/strong&gt;.py&lt;/strong&gt;, with the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from .mod_c.file_c import function_c


def main():
    function_c()
    print('This is main')


if __name__ == '__main__':
    main()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It's the same as our start file, but with the extra two lines at the end. Now, we can run our package directly:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;python -m my_package
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you look around other packages, you will see that many define a &lt;code&gt;__main__&lt;/code&gt; file and then an entry point using it. We could redefine our entry point, and it will look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;entry_points={
        'console_scripts': [
            'my_start=my_package.__main__:main',
        ]
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Adding dependencies&lt;/h2&gt;
&lt;p&gt;Right now we have a package that is completely independent of anything else around. Therefore, the next step is to add dependencies to the setup.py file. As an example, let's assume we want to have numpy (regardless of its version) and Django before version 3.0. We can add the following to the &lt;strong&gt;setup.py&lt;/strong&gt; file:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;install_requires=[
        'numpy',
        'django&amp;lt;3.0'
    ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You will see that if we run the setup script, python will automatically fetch the latest numpy version and Django 2.2 (even though 3.0 is available). Working with dependencies can be a nightmare, and pip is not great at solving conflicts. Imagine you have two packages which require different versions of some libraries, the one you install the latest is the one that prevails. And this is even without considering that those libraries have other requirements, etc. There are other package managers which are more powerful than pip and take into account all the dependencies to find the sweet spot that satisfies all the requirements. &lt;/p&gt;
&lt;h3&gt;Difference with requirements files&lt;/h3&gt;
&lt;p&gt;A common issue when people start working with setup files is that they wonder what is the role requirement files have if you can specify everything in the setup file. The general answer is that requirement files are normally used to keep track of an environment, and therefore they normally include the specific version of the libraries used. This ensures that you can reproduce almost the same environment that the person developing the code had. Setup files, on the other hand, should be more accommodating. In the end, what we want is to make it simple for users to get our code running. Therefore, normally they include the minimum version of libraries to run, or the maximum version, in case future changes of a library would break things. &lt;/p&gt;
&lt;p&gt;The reality is that there are no hard-written rules. You have to put yourself in the shoes of your users and decide what would make their life easier. Is it pin-pointing the versions of every library in the environment, or is it giving flexibility? If it would be a developer looking into your code, one of the options is to always download the code, install everything from &lt;strong&gt;requirements.txt&lt;/strong&gt; and then run setup.py. If things are well configured, the last step won't download anything, since all the dependencies will be present in our environment. And then you know both people have the same versions installed while developing. &lt;/p&gt;
&lt;p&gt;There is also the option of not adding any requirements in your setup and asking users to install everything in the requirements file to use your library. This approach is very user-unfriendly, but it also works. So, you see, there is a lot of flexibility for you to decide what approach you think is best in your particular situation. &lt;/p&gt;
&lt;h2&gt;Extra Dependencies&lt;/h2&gt;
&lt;p&gt;Setup files also give us the option to define extra dependencies, which are not always necessary, but which can enhance the functionality of our program in some cases. We simply define them as an extra argument for the setup function:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from setuptools import setup, find_packages

setup(
    name='My First Setup File',
    version='1.1',
    packages=find_packages(),
    entry_points={
        'console_scripts': [
            'my_start=my_package.__main__:main',
        ]
    },
    install_requires=[
        'numpy&amp;gt;1.18',
        'django&amp;lt;3.0'
    ],
    extras_require={
        'opt1': ['serial'],
        'opt2': ['pyserial'],
    }
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And to install them, we can run a pip command:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install .[opt1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install .[opt2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that this works also with libraries available on PyPI, for example, &lt;code&gt;scikit-learn&lt;/code&gt; can be installed with extra dependencies:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install scikit-learn[alldeps]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Extra dependencies are a great feature when you have dependencies that are hard to install in some systems, or which take a lot of resources, or which are conflicting, just like serial and pyserial above. Note that nothing prevents you from installing both &lt;code&gt;opt1&lt;/code&gt; &lt;strong&gt;and&lt;/strong&gt; &lt;code&gt;opt2&lt;/code&gt;, thus the conflict can still arise. &lt;/p&gt;
&lt;h2&gt;Where to next&lt;/h2&gt;
&lt;p&gt;This was an introduction to develop your first &lt;strong&gt;setup.py&lt;/strong&gt; file. The topic is far from over, but with what you have up to now, you can go a long way. Something very useful is to pay attention to the libraries you use and how they behave. For example, you can check the &lt;a href="https://github.com/scikit-learn/scikit-learn/blob/master/setup.py"&gt;setup file of scikit-learn&lt;/a&gt;, or of &lt;a href="https://github.com/django/django/blob/master/setup.py"&gt;Django&lt;/a&gt;. They can be much more complex than what you need, but they can also point you in the right direction if you are looking for inspiration on how to structure your code. If you are curious about more down-to-earth examples, you can see the one I've developed for the &lt;a href="https://github.com/PFTL/SimpleDaq/blob/master/setup.py"&gt;Python for the Lab workshop&lt;/a&gt;, or for &lt;a href="https://github.com/aquilesC/DisperPy/blob/master/setup.py"&gt;the startup in which I'm working&lt;/a&gt;. Many of the arguments of setup.py which are available (and almost trivial), such as &lt;code&gt;author&lt;/code&gt;, &lt;code&gt;website&lt;/code&gt; were skipped in this tutorial, since they don't bring much to the discussion, and you can quickly add them. &lt;/p&gt;
&lt;p&gt;An obvious step once you have your setup file in order is to release your code through &lt;strong&gt;PyPI&lt;/strong&gt;. This topic will be covered soon. Something we didn't discuss, and which I hope grabbed your attention is that when you run &lt;code&gt;python setup.py install&lt;/code&gt; some folders are created, such as &lt;code&gt;build&lt;/code&gt; and &lt;code&gt;dist&lt;/code&gt;. Go ahead and explore them, see what is inside and try to understand what is happening when you install the package as we have just done. &lt;/p&gt;
&lt;p&gt;Finally, another very interesting topic is what happens if you want to release your package to be installed through &lt;strong&gt;conda&lt;/strong&gt; instead of &lt;strong&gt;pip&lt;/strong&gt;. Conda is a great package manager, that allows you to install also non-python libraries and manage dependencies much more efficiently than what pip does. However, developing a package which is conda-installable requires some extra steps, which will also be covered later. &lt;/p&gt;</content><category term="blog"></category><category term="environment"></category><category term="path"></category><category term="setup"></category><category term="install"></category><category term="package"></category></entry><entry><title>Complete Guide to Imports in Python: Absolute, Relative, and More</title><link href="https://www.pythonforthelab.com/blog/complete-guide-to-imports-in-python-absolute-relative-and-more" rel="alternate"></link><published>2019-10-04T00:00:00+02:00</published><updated>2019-10-04T00:00:00+02:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2019-10-04:/blog/complete-guide-to-imports-in-python-absolute-relative-and-more</id><summary type="html">&lt;p&gt;Importing is not only a matter of using external libraries, it also allows you to keep your code clean and organized. In
this tutorial, we are going to discuss from the very basics of importing to complex topics such as lazy loading of
modules in packages.&lt;/p&gt;
&lt;h2&gt;Introduction to importing&lt;/h2&gt;
&lt;p&gt;In …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Importing is not only a matter of using external libraries, it also allows you to keep your code clean and organized. In
this tutorial, we are going to discuss from the very basics of importing to complex topics such as lazy loading of
modules in packages.&lt;/p&gt;
&lt;h2&gt;Introduction to importing&lt;/h2&gt;
&lt;p&gt;In Python it is important to distinguish between modules and packages in order to have a clear communication. Modules
are, in essence, files with a &lt;em&gt;.py&lt;/em&gt; extension. They can define variables, functions, classes, and they can also run
code. Packages are collections of modules in a hierarchical structure, which in the end means organizing the module
files in folders.&lt;/p&gt;
&lt;p&gt;If we have a file called &lt;strong&gt;module.py&lt;/strong&gt;, we can simply use the following syntax to import it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import module
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also use modules that are bundled with Python, such as &lt;code&gt;sys&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import sys
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case, &lt;code&gt;sys&lt;/code&gt; is a module that belongs to the &lt;code&gt;Python Standard Library&lt;/code&gt;. It provides functions to interact with
the interpreter itself. For example, we can use it to find out if any arguments where passed while executing a script.
We can create a file, &lt;strong&gt;test_argv.py&lt;/strong&gt;, with the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import sys

print(sys.argv)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we run it to see its output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;python test_argv.py -b 1
['test_argv.py', '-b', '1']
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Python comes bundled with plenty of libraries for different tasks. You can find them
all &lt;a href="https://docs.python.org/3/library/index.html"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Importing the entire &lt;code&gt;sys&lt;/code&gt; module may not be what we want since we are only using one of its elements. In this case,
we can also be selective with the importing procedure while keeping the same output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from sys import argv

print(argv)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using the full import or just a selection of what we need depends to a great extent on personal preferences, and on how
different packages where designed.&lt;/p&gt;
&lt;h2&gt;Importing *&lt;/h2&gt;
&lt;p&gt;In the examples above, we have either imported one entire module or just one element from &lt;code&gt;sys&lt;/code&gt;. To import more
elements from the same module, we can specify them on the same line:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from sys import argv, exit

print(argv)
exit()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can import as many things as we need from the same module. To avoid lines becoming too long and hard to read, it is
possible to stack the items vertically. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from sys import (api_version,
                 argv,
                 base_exec_prefix,
                 exit,
                 )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that in this case we must use a set of &lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt; to make a clear list of imports. It is also possible to import
all the elements from a module by using a &lt;code&gt;*&lt;/code&gt; in the statement, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from sys import *

print(api_version)
print(argv)
exit()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, this is a &lt;strong&gt;highly discouraged practice&lt;/strong&gt;. When we import things without control, some functions may get
overwritten without even realizing. The code becomes harder to read and understand. Let's see it with the following
example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from time import *
from asyncio import *

print('Here')
sleep(1)
print('After')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Most programmers will be familiar with the &lt;code&gt;sleep&lt;/code&gt; function from the &lt;code&gt;time&lt;/code&gt; module, which halts the execution of a
program for a given number of seconds. If we run the script, however, we will notice that there is no delay between the
lines &lt;code&gt;'Here'&lt;/code&gt; and &lt;code&gt;'After'&lt;/code&gt;. This can be puzzling at first, and for larger projects can indeed become daunting. In this
case, both &lt;code&gt;time&lt;/code&gt; and &lt;code&gt;asyncio&lt;/code&gt; define a function &lt;code&gt;sleep&lt;/code&gt; which behaves in very different ways. If in such a simple and
compact example the risks of the &lt;code&gt;*&lt;/code&gt; imports become evident, it is easy to understand why almost all developers avoid
using the &lt;code&gt;*&lt;/code&gt; in their programs.&lt;/p&gt;
&lt;p&gt;The case of &lt;code&gt;time&lt;/code&gt; and &lt;code&gt;asyncio&lt;/code&gt; is special, because both of them belong to the Python Standard Library and are very
well documented. However, not all programs are as organized and clean. Therefore, it becomes harder and harder to
remember all the modules and functions defined in packages. Moreover, some names are so handy (like &lt;code&gt;sleep&lt;/code&gt;), that it
is easy to find them defined in different packages and for many purposes.&lt;/p&gt;
&lt;p&gt;The script above becomes much clearer with the following syntax:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import time
import asyncio

print('Here')
asyncio.sleep(1)
print('After')
time.sleep(1)
print('Finally')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are no doubts of what is going on, and where problems may be arising, even if we haven't used the &lt;em&gt;asyncio&lt;/em&gt;
library before.&lt;/p&gt;
&lt;h2&gt;Importing As&lt;/h2&gt;
&lt;p&gt;Sometimes we face the situation in which we want to import specific functions from different modules but their names are
the same. For example, both &lt;code&gt;time&lt;/code&gt; and &lt;code&gt;asyncio&lt;/code&gt; define
&lt;code&gt;sleep&lt;/code&gt; and we are interested in using them. To avoid a name clash when importing, Python allows us to change the name
of what we are importing by doing the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from asyncio import sleep as async_sleep
from time import sleep as time_sleep

print('Here')
async_sleep(1)
print('After')
time_sleep(1)
print('Finally')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this way, we can use either &lt;code&gt;sleep&lt;/code&gt; from &lt;code&gt;asyncio&lt;/code&gt; or from &lt;code&gt;time&lt;/code&gt;avoiding name clashes. Of course this
flexibility must be taken seriously because it can also generate unreadable code. The following code would become very
hard to udnerstand for anybody reading it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from time import sleep as exit

exit(1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The use of the &lt;code&gt;import as&lt;/code&gt; is not only practical, in some cases it is the de-facto way of working. For
example, &lt;code&gt;numpy&lt;/code&gt;, &lt;code&gt;pandas&lt;/code&gt;, &lt;code&gt;matplotlib&lt;/code&gt; are almost always imported in the same way:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The three lines above are ubiquitous in many scientific programs. They are so common that code editors such as Pycharm
can suggest you to import numpy if they see a line that includes something like &lt;code&gt;np.&lt;/code&gt;. Changing the name of the import
can be useful not only to prevent name clashes, but also to shorten the notation. Instead of doing:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;matplotlib.pyplot.plot(x, y)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We simply have:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;plt.plot(x, y)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Different packages have different shortcuts. For example &lt;code&gt;PyQtGraph&lt;/code&gt; is normally shortened as &lt;code&gt;pg&lt;/code&gt;, and for sure
different fields use different abbreviations. Importing Numpy as &lt;code&gt;np&lt;/code&gt; or Pandas as &lt;code&gt;pd&lt;/code&gt; is not mandatory. However,
since it is what the community does, it will make the code much more readable.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The use of this notation is so widespread that, for example, even in StackOverflow numpy is used as &lt;code&gt;np&lt;/code&gt; without
even showing the import statement.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Importing your code&lt;/h2&gt;
&lt;p&gt;So far, we have seen how to import packages and modules developed by other people. Importing, however, is a great tool
to structure different parts of the code. It makes it easier to maintan and collaborate. Therefore, sooner or later we
are going to find ourselves importing our code. We can start simple and slowly build the complexity.&lt;/p&gt;
&lt;p&gt;We can create a file &lt;strong&gt;first.py&lt;/strong&gt;, with following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def first_function():
    print('This is the first function')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In a file called &lt;strong&gt;second.py&lt;/strong&gt;, we can add the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from first import first_function

first_function()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we run it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ python second.py
This is the first function
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That is as easy as it gets. We define a function in a file, but we use it in another file. Once we have many files, it
becomes handier to start creating some structure to organize the program. We can create a folder called &lt;strong&gt;package_a&lt;/strong&gt;,
and we add a new file, called &lt;strong&gt;third.py&lt;/strong&gt;. The folder structure is like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ tree
.
├── first.py
├── package_a
│   └── third.py
└── second.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In &lt;strong&gt;third&lt;/strong&gt; we create a new function, appropriately called &lt;code&gt;third_function&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def third_function():
    print('This is the third function')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The examples are very basic, but they already start to show some patterns and caveats in the importing procedures. If we
want to use the new function from the &lt;strong&gt;second.py&lt;/strong&gt;, we need to import it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from first import first_function
from package_a.third import third_function

first_function()
third_function()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we run the code, we'll get the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;This is the first function
This is the third function
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pay attention to the notation we used to import the &lt;code&gt;third_function&lt;/code&gt;. We specified the folder, in this case, &lt;code&gt;package_a&lt;/code&gt;
and then we referred to the file with a dot: &lt;code&gt;.&lt;/code&gt;. This is the way in which the hyerarchy of folders and files is
transformed into packages and modules in Python. In this case, replacing the folder separators by a &lt;code&gt;.&lt;/code&gt; we end up
having &lt;code&gt;package_a.third&lt;/code&gt;, and we stripped the &lt;code&gt;.py&lt;/code&gt; extension.&lt;/p&gt;
&lt;h2&gt;The use of the __init__ file&lt;/h2&gt;
&lt;p&gt;Most likely our code will not be isolated from other projects. When we install packages, they will have dependencies,
and very quickly we lose track of what is actually installed. We can understand where the problem arises wtih a very
simple example. We can assume that we have &lt;strong&gt;numpy&lt;/strong&gt; already installed but we are not aware of that. If we create a new
folder, called &lt;strong&gt;numpy&lt;/strong&gt;, with a file
called &lt;strong&gt;sleep.py&lt;/strong&gt;, the folder structure will end up looking like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;.
├── first.py
├── package_a
│   └── third.py
├── numpy
│   └── sleep.py
└── second.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And in the file &lt;strong&gt;sleep.py&lt;/strong&gt;, we can add the following function:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def sleep():
    print('Sleep')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the same way we did before, we can update &lt;strong&gt;second.py&lt;/strong&gt; to use the new function &lt;code&gt;sleep&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from numpy.sleep import sleep

sleep()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course the code above will raise many alarms, but the best is to run it to see what happens:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;Traceback (most recent call last):
  File &amp;quot;second.py&amp;quot;, line 3, in &amp;lt;module&amp;gt;
    from numpy.sleep import sleep
ModuleNotFoundError: No module named 'numpy.sleep'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The biggest challenge in this case is that the exception is utterly hard to understand. It is telling us that Python
tried to look for a module called &lt;code&gt;sleep&lt;/code&gt; in the &lt;em&gt;numpy&lt;/em&gt; package. If we open the folder &lt;em&gt;numpy&lt;/em&gt; we find the module
&lt;em&gt;sleep&lt;/em&gt;. Therefore, there must be something else going on. In this example it is clear that Python is looking for the
module &lt;em&gt;sleep&lt;/em&gt; within the official &lt;em&gt;numpy&lt;/em&gt; package and not in our folder.&lt;/p&gt;
&lt;p&gt;The quick solution to this problem is to create an empty file called &lt;strong&gt;__init__.py&lt;/strong&gt; in our numpy folder:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;.
├── first.py
├── package_a
│   └── third.py
├── numpy
│   ├── __init__.py
│   └── sleep.py
└── second.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can run the code without problems this time:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ python second.py
Sleep
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is important to understand what is going on and not just through quick solutions to see whether they work to voercome
the immediate problems. The quid is to know how Python looks for packages on the computer. The topic is complex, and
Python allows a great deal of customization.
The &lt;a href="https://docs.python.org/3/reference/import.html"&gt;official documentation&lt;/a&gt; shines some light into the matter once we
have experience.&lt;/p&gt;
&lt;p&gt;In short, Python will first look at whether we are trying to import, and check if it belongs to the standard library. If
the folder was &lt;code&gt;time&lt;/code&gt; instead of &lt;code&gt;numpy&lt;/code&gt;, the behavior would have been different. Adding the &lt;strong&gt;__init__.py&lt;/strong&gt; file
wouldn't make a difference. Once Python knows the module is not in the standard library, it will check for external
modules. First, it starts searching the current directory. Then, it moves to the directories where packages are
installed, for example, where numpy ends up after doing &lt;code&gt;pip install numpy&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This raises a very interesting question: why did our code fail in the first attempt and it started working only after
adding the &lt;strong&gt;__init__.py&lt;/strong&gt; file. In order for Python to consider that a folder is a package, it must contain an *
&lt;em&gt;__init__.py&lt;/em&gt;* file. This is by design, exactly to prevent unintended name clashes unless we explicitly want them.&lt;/p&gt;
&lt;p&gt;If Python does not find the package within the local or default installation directories, it moves to look into the
folders. That is why &lt;code&gt;package_a&lt;/code&gt; works even if we never defined the &lt;strong&gt;__init__.py&lt;/strong&gt; file.&lt;/p&gt;
&lt;p&gt;Bear in mind that once Python finds the package, it won't keep searching. Once it finds &lt;em&gt;numpy&lt;/em&gt; in our local folder, it
won't look for another numpy elsewhere. Therefore, we can't mix modules from different packages with the same name.&lt;/p&gt;
&lt;h3&gt;The PATH list of directories&lt;/h3&gt;
&lt;p&gt;A useful thing to do is to check the directories Python uses to look for modules and packages. We can see it by running
the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import sys

for path in sys.path:
    print(path)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That will list something between 4 and 6 different folders. Most of them are quite logical: where Python is installed,
the virtual environment folders, etc.&lt;/p&gt;
&lt;h3&gt;Adding Folder to the Path&lt;/h3&gt;
&lt;p&gt;An easy way of extending the capabilities of Python is to add folders to the list where it looks for packages. The first
option is to do it at runtime. We can easily append a directory to the
variable &lt;code&gt;sys.path&lt;/code&gt;. To add the current directory to the list, we can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import os
import sys

CURR_DIR = os.path.dirname(os.path.abspath(__file__))
print(CURR_DIR)
sys.path.append(CURR_DIR)
for path in sys.path:
    print(path)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can add any directory, not only the current one. In this approach, we modify the system path only while the program
runs. If we run two different programs, each will have its own path.&lt;/p&gt;
&lt;p&gt;Another option is to modify a variable in the operating system itself. This has the advantage that it can be made
permament and all programs will share the same information. For our application, we have to modify the &lt;strong&gt;PYTHONPATH&lt;/strong&gt;
environment variable. Environment variables are available on every
operating system, how to set and modify them varies.&lt;/p&gt;
&lt;p&gt;On &lt;strong&gt;Linux&lt;/strong&gt; or &lt;strong&gt;Mac&lt;/strong&gt;, the command to set these variables is &lt;code&gt;export&lt;/code&gt;. We can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;export PYTHONPATH=$PYTHONPATH':/home/user/'
echo $PYTHONPATH
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first line appends the folder &lt;code&gt;/home/user&lt;/code&gt; to the variable &lt;code&gt;PYTHONPATH&lt;/code&gt;. Note that we have used &lt;code&gt;:&lt;/code&gt; as a
directory separator.&lt;/p&gt;
&lt;p&gt;On &lt;strong&gt;Windows&lt;/strong&gt;, we need to right-click on "Computer", select "Properties". In the "Advanced System Settings" there is
the option "Environment variables". If &lt;code&gt;PYTHONPATH&lt;/code&gt; exists, we can modify it, if it does not exist, we can create it by
clicking on "New". Bear in mind that on Windows, you have to use &lt;code&gt;;&lt;/code&gt; to separate directories, since &lt;code&gt;:&lt;/code&gt; is part of the
folder path (e.g.: &lt;code&gt;C:\Users\Test\...&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;We can check whether the modifications to the system environment variables worked by running the same code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import sys

for path in sys.path:
    print(path)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Adding information to the Python Path is a great way of developing a structure on your own computer, with code in
different folders, etc. However, it is also important to note that it also makes harder to maintain. The environmental
variables in one computer are not the same in another, Python may be loading legacy code from an abscure place on the
computer. On the other hand, environmental variables are very useful in contexts like a web server, where the
definitions can be loaded before running a program.&lt;/p&gt;
&lt;p&gt;As a quick side-note, it is worth mentioning that Python allows to read environment variables at runtime:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import os

print(os.environ.get('PYTHONPATH'))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that on Windows, the changes to environment variables are permanent, but on Linux and Mac we need to
follow &lt;a href="https://stackoverflow.com/questions/3402168/permanently-add-a-directory-to-pythonpath"&gt;extra steps&lt;/a&gt; if we want
them to stay.&lt;/p&gt;
&lt;h3&gt;PYTHONPATH and Virtual Environments&lt;/h3&gt;
&lt;p&gt;When we work with virtual environments, we can modify environment variables when we activate or deactivate them. This
works seamlessly on Linux and Mac, but Windows users may require some tinkering to adapt the examples below.&lt;/p&gt;
&lt;p&gt;If we inspect the &lt;strong&gt;activate&lt;/strong&gt; script (located in the folder &lt;em&gt;venv/bin&lt;/em&gt;), we can get inspiration about what is done with
the &lt;code&gt;PATH&lt;/code&gt;variable, for example. The first step is to store the old variable, before modifying it, then we append
whatever we want. When we deactivate the virtual environment, we set the old variable back.&lt;/p&gt;
&lt;p&gt;Virtual environments have three hooks to achieve this behavior. Next to the &lt;strong&gt;activate&lt;/strong&gt; script, we can also see three
files called &lt;em&gt;postactivate&lt;/em&gt;, &lt;em&gt;postdeactivate&lt;/em&gt; and &lt;em&gt;predeactivate&lt;/em&gt;. We can modify
&lt;em&gt;postactivate&lt;/em&gt;, which should be empty, and add the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;PYTHONPATH_OLD=&amp;quot;$PYTHONPATH&amp;quot;
PYTHONPATH=$PYTHONPATH&amp;quot;:/home/user&amp;quot;
export PYTHONPATH
export PYTHONPATH_OLD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next time we activate the virtual environment, we will have the directory &lt;code&gt;/home/user&lt;/code&gt; added to the &lt;code&gt;PYTHONPATH&lt;/code&gt;. It
is a good practice to go back to the original version of the python path once we deactivate tne environment. We can do
it directly in the &lt;strong&gt;predeactivate&lt;/strong&gt; file:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;PYTHONPATH=&amp;quot;$PYTHONPATH_OLD&amp;quot;
unset $PYTHONPATH_OLD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We set the variable to the status it had before activating, and we remove the extra variable we created. Note that in
case we don't deactivate the environment, but simply close the terminal, the changes to the &lt;code&gt;PYTHONPATH&lt;/code&gt; won't be saved.
The &lt;em&gt;predeactivate&lt;/em&gt; script is important if you switch from one environment to another and keep using the same terminal.&lt;/p&gt;
&lt;h3&gt;PYTHONPATH and PyCharm&lt;/h3&gt;
&lt;p&gt;Users of &lt;a href="https://www.jetbrains.com/pycharm/"&gt;PyCharm&lt;/a&gt;, and probably most other IDE's around will be
similar, can change the environment variables directly from within the program. If we open the
&lt;strong&gt;Run&lt;/strong&gt; menu, and select &lt;strong&gt;Edit Configurations&lt;/strong&gt; we will be presented with the following menu:&lt;/p&gt;
&lt;p&gt;&amp;lt;:image:PyCharm_config.png&amp;gt;&lt;/p&gt;
&lt;p&gt;In between the options we can see "Add content roots to PYTHONPATH". This is what makes the imports work out of the box
when we are in Pycharm but if we run the same code directly from the terminal may give you some issues. We can also edit
the environment variables if we click on the small icon to the right of where it says "environment variables".&lt;/p&gt;
&lt;p&gt;Keeping an eye on the environment variables can avoid problems in the long run. Especially if, for example, two
developers share the computer. Although strange in many settings, lab computers are normally shared between people, and
the software can be edited by multiple users. Perhaps one sets environment variables pointing to specific paths which
are not what the second person is expecting.&lt;/p&gt;
&lt;h2&gt;Absolute Imports&lt;/h2&gt;
&lt;p&gt;In the examples of the previous sections, we imported a function &lt;em&gt;downstream&lt;/em&gt; in the file system. This means, that the
function was inside a folder next to the main script file. However, we should also study what happens if we want to
import from a sibling package. Imagine we have the following situation:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;├── __init__.py
├── pkg_a
│   ├──  mod_a.py
│   └── __init__.py
├── pkg_b
│   ├── mod_b.py
│   └── __init__.py
└── start.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have a &lt;strong&gt;start&lt;/strong&gt; file in the top-level directory and two packages, &lt;strong&gt;pkg_a&lt;/strong&gt; and &lt;strong&gt;pkg_b&lt;/strong&gt;. Each one has its own *
&lt;em&gt;__init__&lt;/em&gt;&lt;em&gt; file. The question is how can we have access to the contents of &lt;/em&gt;&lt;em&gt;mod_a&lt;/em&gt;&lt;em&gt; from withing &lt;/em&gt;&lt;em&gt;mod_b&lt;/em&gt;&lt;em&gt;. From
the &lt;/em&gt;&lt;em&gt;start&lt;/em&gt;* file, the import procedure is easy:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from pkg_a import mod_a
from pkg_b import mod_b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can create some dummy code in order to have a concrete example. First, in the file &lt;strong&gt;mod_a&lt;/strong&gt;, we can create a
function:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def simple():
    print('This is simple A')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which, from the &lt;strong&gt;start&lt;/strong&gt; file we can use as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from pkg_a.mod_a import simple

simple()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we want to use the same function within the &lt;strong&gt;mod_b&lt;/strong&gt;, the first thing we can try is to simply copy the same line.
Thus, in &lt;strong&gt;mod_b&lt;/strong&gt; we can try:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from pkg_a.mod_a import simple


def bsimple():
    print('This is simple B')
    simple()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To make it complete, we can trigger it directly from withing the &lt;strong&gt;start&lt;/strong&gt; file:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from pkg_b import mod_b

mod_b.bsimple()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we run it, we will get the output we were expecting:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ python start.py
This is simple B
This is simple
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, and this is very big, &lt;strong&gt;HOWEVER&lt;/strong&gt;, sometimes we don't want to run&lt;strong&gt;start&lt;/strong&gt;. Instead, we want to run directly *
&lt;em&gt;mod_b&lt;/em&gt;*. If we try to run it, the following happens:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ python mod_b.py
Traceback (most recent call last):
  File &amp;quot;mod_b.py&amp;quot;, line 1, in &amp;lt;module&amp;gt;
    from pkg_a.mod_a import simple
ModuleNotFoundError: No module named 'pkg_a'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And here we start to realize the headaches that the importing in Python can generate as soon as the program gets a bit
more sophisticated. In the end, the error was expected. When we run &lt;code&gt;python mod\_b.py&lt;/code&gt;, Python will try to
find &lt;code&gt;pkg\_a&lt;/code&gt; in the same folder, and not one level up. When we trigger &lt;code&gt;start&lt;/code&gt; there is no problem, because from
that directory both &lt;code&gt;pkg\_a&lt;/code&gt; and &lt;code&gt;pkg\_b&lt;/code&gt; are visible.&lt;/p&gt;
&lt;p&gt;The same problem will appear if we trigger python from any other location in the computer:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ python /path/to/project/start.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What we did in the examples above is called &lt;strong&gt;absolute imports&lt;/strong&gt;. It means that we specify the full path to the module
we want to import. What we have to remember is that the folder from which you trigger Python is the first place where
the program looks for modules. Then it goes to the paths stored in &lt;code&gt;sys.path&lt;/code&gt;. If we want the code to work, we need to
be sure that Python knows where &lt;strong&gt;pkg_a&lt;/strong&gt; and &lt;strong&gt;pkg_b&lt;/strong&gt; are stored.&lt;/p&gt;
&lt;p&gt;The proper way would be to include the folder in the &lt;strong&gt;PYTHONPATH&lt;/strong&gt; environment variable, as we explained earlier. A
&lt;em&gt;dirtier&lt;/em&gt; way would be to append the folder at runtime, we can add the following lines to &lt;strong&gt;mod_b.py&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import os
import sys

BASE_PATH = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(BASE_PATH)

from pkg_a.mod_a import simple
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is very similar to what we have done earlier. It is important to highlight that the definition of &lt;code&gt;BASE_PATH&lt;/code&gt; is
the full path to the folder one level above where the current file (&lt;strong&gt;mod_b.py&lt;/strong&gt;) is. Note also that we need to append
to the &lt;code&gt;sys.path&lt;/code&gt; before we try to import &lt;code&gt;pkg_a&lt;/code&gt;, or it will fail in the same way it did before.&lt;/p&gt;
&lt;p&gt;If we think for a second about this approach, we can quickly notice that it has several drawbacks. The most obvious one
is that we should add those lines to every single file you are working with. Another problem is that we are adding a
folder that contains many packages, which can give some collisions. Imagine we are a theoretical physicists working on
string theory and we develop a module called &lt;code&gt;string&lt;/code&gt;. The code would look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from string import m_theory
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And it will give us problems because &lt;code&gt;string&lt;/code&gt; belongs to Python's standard library.&lt;/p&gt;
&lt;p&gt;Therefore, it is always better to develop projects in their own folder, even if that forces a bit of a name repetition.
In the very simple case we are dealing with here, the structure would be like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;code
├── pkg_a
│   ├── docs
│   └── pkg_a
│       ├── __init__.py
│       └── mod_a.py
└── pkg_b
    ├── docs
    └── pkg_b
        ├── __init__.py
        └── mod_b.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the folder tree above we have a base folder &lt;strong&gt;code&lt;/strong&gt;. Inside there are two packages, &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;. Although the name
of the folders repeat (we have twice &lt;strong&gt;pkg_a&lt;/strong&gt;, twice &lt;strong&gt;pkg_b&lt;/strong&gt;, for example), there are several advantages to working
in this way. The most important one is the granularity. We can add &lt;code&gt;code/pkg_a&lt;/code&gt; or &lt;code&gt;code/pkg_b&lt;/code&gt; to
the &lt;code&gt;PYTHONPATH&lt;/code&gt;. Having control is always better than getting blanket results.&lt;/p&gt;
&lt;p&gt;The most important thing to remember is that in Python, absolute is &lt;em&gt;relative&lt;/em&gt;. While importing, we are not specifying a
path in the file system, but rather an import path. Therefore, the imports are always &lt;em&gt;relative&lt;/em&gt; to the PYTHONPATH, even
if called &lt;em&gt;absolute&lt;/em&gt;.&lt;/p&gt;
&lt;h2&gt;Relative Imports&lt;/h2&gt;
&lt;p&gt;Another option for importing modules is to define the &lt;em&gt;relative&lt;/em&gt; path. We can continue building on the example from the
previous section. Imagine We have a folder structure like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;code
├── pkg_a
│   ├── mod_a.py
│   └── __init__.py
├── pkg_b
│   ├──  mod_b.py
│   ├── __init__.py
│   └── pkg_a
│       ├──  mod_c.py
│       └── __init__.py
└── start.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let's assume that each &lt;code&gt;mod_X.py&lt;/code&gt; defines a function called &lt;code&gt;function_X&lt;/code&gt; (where X is the letter of the file). The
function simply prints the name of the function. It should be clear that if we want to import &lt;code&gt;function_c&lt;/code&gt;
from &lt;code&gt;file_c&lt;/code&gt;, the &lt;code&gt;start.py&lt;/code&gt; file should look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from pkg_b.pkg_a.mod_c import function_c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The situation becomes more interesting when we want to import &lt;code&gt;function_a&lt;/code&gt; in &lt;code&gt;mod_b&lt;/code&gt;. It is important to pay
attention because there are two different &lt;code&gt;pkg_a&lt;/code&gt; defined in our program. If we add
the following to &lt;code&gt;mod_b&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from pkg_a.mod_c import function_c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It would work, regardless of how we run the script:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ python pkg_b/mod_b.py
$ cd pkg_b
$ python mod_b.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But this is not what we wanted! We want &lt;code&gt;function_a&lt;/code&gt; from &lt;code&gt;mod_a&lt;/code&gt;. If we, however, add the following to &lt;code&gt;mod_b&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from pkg_a.mod_a import function_a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We would get the following error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ python pkg_b/mod_b.py
Traceback (most recent call last):
  File &amp;quot;pkg_b/mod_b.py&amp;quot;, line 1, in &amp;lt;module&amp;gt;
    from pkg_a.mod_a import function_a
ImportError: No module named pkg_a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case is where relative imports become very handy. From &lt;strong&gt;mod_b&lt;/strong&gt;, the module we want to import is one folder up.
To indicate that, we can use the &lt;code&gt;..&lt;/code&gt; notation in Python:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from ..pkg_a.mod_a import function_a


def function_b():
    print('This is simple B')
    function_a()


function_b()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Generally speaking, the first &lt;code&gt;.&lt;/code&gt; means &lt;em&gt;in this directory&lt;/em&gt;, while the second means going one
level up, etc. However, if we run the file, there will be problems. If we run the file, we get the following error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ python3 mod_b.py
Traceback (most recent call last):
  File &amp;quot;mod_b.py&amp;quot;, line 1, in &amp;lt;module&amp;gt;
    from ..pkg_a.mod_a import function_a
ValueError: attempted relative import beyond top-level package
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It doesn't matter if we change folders, if we move one level up, we will get the same problem:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ python3 pkg_b/mod_b.py
Traceback (most recent call last):
  File &amp;quot;mod_b.py&amp;quot;, line 1, in &amp;lt;module&amp;gt;
    from ..pkg_a.mod_a import function_a
ValueError: attempted relative import beyond top-level package
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At some point, this becomes nerve-wracking. It doesn't matter if we add folders to the PATH, create &lt;strong&gt;__init__.py&lt;/strong&gt;
files, etc. It all boils down to the fact that we are not treating our files as a module when we run it. To instruct
Python to run the file as part of a package, we would do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ python3 -m code.pkg_b.mod_b
This is function_b
This is function_a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Bear in mind that the only way of running the code like this is if python knows where to find the folder &lt;code&gt;code&lt;/code&gt;. And
this brings us back to the discussion of the PYTHONPATH variables. If we are in the folder that contains &lt;code&gt;code&lt;/code&gt; and run
Python from there, we won't see any problems. If we, however, are in any other folder, Python will follow to usual rules
to try to understand where &lt;code&gt;code&lt;/code&gt; is.&lt;/p&gt;
&lt;p&gt;There is one more important detail to discuss with relative imports. We can imagine that &lt;strong&gt;mod_c&lt;/strong&gt; has the following
code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from ..mod_b import function_b


def function_c():
    print('This is function c')
    function_b()


function_c()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since &lt;strong&gt;mod_c&lt;/strong&gt; is deeper in the tree, we can try to run it in different ways:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ python -m code.pkg_b.pkg_a.mod_c
$ python -m pkg_b.pkg_a.mod_c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, the second option is going to fail. &lt;strong&gt;mod_c&lt;/strong&gt; is importing &lt;strong&gt;mod_b&lt;/strong&gt; which in turn is importing &lt;strong&gt;mod_a&lt;/strong&gt;.
Therefore, Python needs to be able to go all the way to the root folder &lt;strong&gt;code&lt;/strong&gt;. Therefore, when we plan our code, we
should be mindful not only on how to write it, but on how the program is meant to be used.&lt;/p&gt;
&lt;p&gt;The last detail to cover is that we can't mix relative and absolute imports. For example, the following won't work:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from ..pkg_a.mod_a import function_a
from pkg_a.mod_c import function_c


def function_b():
    print('This is function_b')
    function_a()


function_b()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We will get the following error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ python -m code.pkg_b.mod_b
Traceback (most recent call last):
[...]
ModuleNotFoundError: No module named 'pkg_a'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we decide to run your code as a module (using the &lt;code&gt;-m&lt;/code&gt;), then all the imports relative. One way
of solving the problem would be to change the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from .pkg_a.mod_c import function_c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this way it becomes clear that we want are importing from &lt;code&gt;pkg_a&lt;/code&gt; which is in the same folder as &lt;strong&gt;mod_b&lt;/strong&gt;.&lt;/p&gt;
&lt;h2&gt;Mixing Absolute and Relative&lt;/h2&gt;
&lt;p&gt;It is possible mixing relative and absolute imports without any secrets to it. We can change
&lt;strong&gt;mod_b.py&lt;/strong&gt; like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from ..pkg_a.mod_a import function_a
from code.pkg_b.pkg_a.mod_c import function_c


def function_b():
    print('This is function_b')
    function_c()


function_b()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mixing relative and absolute is definitely a possibility. The question, as almost always, is why would we do it. The
fact that we can does not mean we should.&lt;/p&gt;
&lt;h2&gt;Absolute or Relative: Conclusions&lt;/h2&gt;
&lt;p&gt;Deciding whether we want to use absolute imports or relative imports is basically up to the taste of the developer or
the rules established by the group. If we are developing a package that has a lot of sub-packages and modules with
several layers of nesting, using absolute imports can make the code clearer. For example, this is how the same import
would look like in the two different cases:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from program.pkg_1.pkg_2.pkg_3.module import my_function
from .module import my_function
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For some people the first line is much clearer, there are no doubts about what are we importing. But it can get tiresome
to type the entire path all the time. However, it is important to consider that typing less is not the only factor at
play here.&lt;/p&gt;
&lt;p&gt;If we are planning on allowing some files to run directly we should be mindful about the requirements for the relative
imports. If we have many modules with similar names, sometimes the explicit path makes the code much clearer. It is
really up to the developer to have enough sensitivity to decide
whether the absolute import or the relative import makes the code clearer and the execution easier.&lt;/p&gt;
&lt;p&gt;The example code for this article can be
found &lt;a href="https://github.com/PFTL/website_example_code/tree/master/pftl_code/code/37_imports"&gt;on Github&lt;/a&gt;&lt;/p&gt;</content><category term="blog"></category><category term="importing"></category><category term="import"></category><category term="relative"></category><category term="absolute"></category><category term="package"></category></entry><entry><title>Handling and Sharing Data Between Threads</title><link href="https://www.pythonforthelab.com/blog/handling-and-sharing-data-between-threads" rel="alternate"></link><published>2019-08-06T00:00:00+02:00</published><updated>2019-08-06T00:00:00+02:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2019-08-06:/blog/handling-and-sharing-data-between-threads</id><summary type="html">&lt;p&gt;When working with threads in Python, you will find very useful to be
able to share data between different tasks. One of the advantages of
threads in Python is that they share the same memory space, and thus
exchanging information is relatively easy. However, some structures can
help you achieve …&lt;/p&gt;</summary><content type="html">&lt;p&gt;When working with threads in Python, you will find very useful to be
able to share data between different tasks. One of the advantages of
threads in Python is that they share the same memory space, and thus
exchanging information is relatively easy. However, some structures can
help you achieve more specific goals.&lt;/p&gt;
&lt;p&gt;In the previous article, we have covered &lt;a href="https://www.pythonforthelab.com/blog/starting-and-synchronizing-threads"&gt;how to start and synchronize
threads&lt;/a&gt; and now it is time to
expand the toolbox to handle the exchange of information between them.&lt;/p&gt;
&lt;h2&gt;Shared Memory&lt;/h2&gt;
&lt;p&gt;The first and most naive approach is to use the same variables in
different threads. We have already used this feature in the &lt;a href="https://www.pythonforthelab.com/blog/starting-and-synchronizing-threads"&gt;previous
tutorial&lt;/a&gt;, but without discussing
it explicitly. Let's see how we can use shared memory through a very
simple example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from threading import Thread, Event
from time import sleep

event = Event()

def modify_variable(var):
    while True:
        for i in range(len(var)):
            var[i] += 1
        if event.is_set():
            break
        sleep(.5)
    print('Stop printing')


my_var = [1, 2, 3]
t = Thread(target=modify_variable, args=(my_var, ))
t.start()
while True:
    try:
        print(my_var)
        sleep(1)
    except KeyboardInterrupt:
        event.set()
        break
t.join()
print(my_var)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The example above is almost trivial, but it has a very important
feature. We start a new thread by passing an argument, &lt;code&gt;my_var&lt;/code&gt;, which
is a list of numbers. The thread will increase the values of the numbers
by one, with a certain delay. In this example we use events to
graciously finish the thread, if you are not familiar with them, check
the &lt;a href="https://www.pythonforthelab.com/blog/starting-and-synchronizing-threads"&gt;previous tutorial&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The important piece of code in this example is the &lt;code&gt;print(my_var)&lt;/code&gt; line.
That print statement lives in the main thread, however, it has access to
the information being generated within a child thread. This behavior is
possible thanks to memory sharing between different threads. Being able
to access the same memory space is useful, but it can also pose some
risks. In the example above, we have started only one thread, but we are
not limited to that. We could, for example, start several threads:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;t = Thread(target=modify_variable, args=(my_var, ))
t2 = Thread(target=modify_variable, args=(my_var, ))
t.start()
t2.start()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And you would see that &lt;code&gt;my_var&lt;/code&gt; and its information is shared across all
threads. This is good for applications like the one above, in which it
doesn't matter which thread adds one to the variable. Or does it? Let's
slightly modify the code that runs in the thread. Let's remove the
&lt;code&gt;sleep&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def modify_variable(var):
    while True:
        for i in range(len(var)):
            var[i] += 1
        if event.is_set():
            break
        # sleep(.5)
    print('Stop printing')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, when we run the code, there will be no sleep in between one
iteration and the next. Let's run it for a short time, let's say 5
seconds, we can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from time import time
[...]

my_var = [1, 2, 3]
t = Thread(target=modify_variable, args=(my_var, ))
t.start()
t0 = time()
while time()-t0 &amp;lt; 5:
    print(my_var)
    sleep(1)
event.set()
t.join()
print(my_var)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I've suppressed the parts of the code which repeat. If you run this
code, you will get as outputs very large numbers. In my case, I got:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;[6563461, 6563462, 6563463]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is, however, a very important feature to notice. The three numbers
are consecutive. This is expected because the starting variable was
&lt;code&gt;[1, 2, 3]&lt;/code&gt; and we are adding one to each variable. Let's start a second
thread this time and see what the output is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;my_var = [1, 2, 3]
t = Thread(target=modify_variable, args=(my_var, ))
t2 = Thread(target=modify_variable, args=(my_var, ))
t.start()
t2.start()
t0 = time()
while time()-t0 &amp;lt; 5:
    try:
        print(my_var)
        sleep(1)
    except KeyboardInterrupt:
        event.set()
        break
event.set()
t.join()
t2.join()
print(my_var)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I've got as an output the following values:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;[5738447, 5686971, 5684220]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can first note that they are not larger than before, meaning that
running two threads instead of one could actually be slower for this
operation. The other thing to note is that the values are no consecutive
to each other! And this is a very important behavior that can appear
when working with multiple threads in Python. If you think really hard,
can you explain where this issue is coming from?&lt;/p&gt;
&lt;p&gt;In the &lt;a href="https://www.pythonforthelab.com/blog/starting-and-synchronizing-threads"&gt;previous tutorial&lt;/a&gt;, we
discussed that threads are handled by the operating system, which
decides when to spin one on or off. We have no control over what the
operating system decides to do. In the example above, since there is no
&lt;code&gt;sleep&lt;/code&gt; in the loop, the operating system will have to decide when to
stop one and start another thread. However, that does not explain
completely the output we are getting. It doesn't matter if one thread
runs first and stops, etc. we are always adding &lt;code&gt;+1&lt;/code&gt; to each element.&lt;/p&gt;
&lt;p&gt;The problem with the code above is in the line &lt;code&gt;var[i] += 1&lt;/code&gt;, which is
actually two operations. First, it copies the value from &lt;code&gt;var[i]&lt;/code&gt; and
ads &lt;code&gt;1&lt;/code&gt;. Then it stores the value back to &lt;code&gt;var[i]&lt;/code&gt;. In between these two
operations, the operating system may decide to switch from one task to
another. In such case, the value both tasks see in the list is the same,
and therefore instead of adding &lt;code&gt;+1&lt;/code&gt; twice, we do it only once. If you
want to do it even more noticeable, you can start two threads, one that
adds and one that subtracts from a list, and that would give you a quick
hint of which thread runs faster. In my case, I got the following
output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;[-8832, -168606, 2567]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But if I run it another time, I get:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;[97998, 133432, 186591]
&lt;/code&gt;&lt;/pre&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;You may notice that there is a delay between the &lt;code&gt;start&lt;/code&gt; of both
threads, which may give a certain advantage to the first thread started.
However, that alone cannot explain the output generated.&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;How to synchronize data access&lt;/h2&gt;
&lt;p&gt;To solve the problem we found in the previous examples, we have to be
sure that no two threads try to write at the same time to the same
variable. For that, we can use a &lt;code&gt;Lock&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from threading import Lock
[...]
data_lock = Lock()
def modify_variable(var):
    while True:
        for i in range(len(var)):
            with data_lock:
                var[i] += 1
        if event.is_set():
            break
        # sleep(.5)
    print('Stop printing')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that we added a line &lt;code&gt;with data_lock:&lt;/code&gt; to the function. If you run
the code again, you will see that the values we get are always
consecutive. The lock guarantees that only one thread will access the
variable at a time.&lt;/p&gt;
&lt;p&gt;The examples of increasing or decreasing values from a list are almost
trivial, but they point in the direction of understanding the
complications of memory management when dealing with concurrent
programming. Memory sharing is a nice feature, but it comes with risks
also.&lt;/p&gt;
&lt;h2&gt;Queues&lt;/h2&gt;
&lt;p&gt;One of the common situations in which threads are used is when you have
some slow tasks that you can't optimize. For example, imagine you are
downloading data from a website using. Most of the time the processor
would be idle. This means you could use that time for something else. If
you want to download an entire website (also called scraping), it would
be a good solution to download several pages at the same time. Imagine
you have a list of pages you want to download, and you start several
threads, each one to download one page. If you are not careful on how to
implement this, you may end up downloading twice the same, as we saw in
the previous section.&lt;/p&gt;
&lt;p&gt;Here is where another object can be very useful when working with
threads: &lt;strong&gt;Queues&lt;/strong&gt;. A queue is an object which accepts data in order,
i.e. you put data to it one element at a time. Then, the data can be
consumed in the same order, called First-in-first-out (FIFO). A very
simple example would be:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from queue import Queue

queue = Queue()
for i in range(20):
    queue.put(i)

while not queue.empty():
    data = queue.get()
    print(data)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example you see that we create a &lt;code&gt;Queue&lt;/code&gt;, then we put into the
queue the numbers from 0 to 19. Later, we create a &lt;code&gt;while&lt;/code&gt; loop that
gets data out of the queue and prints it. This is the basic behavior of
queues in Python. You should pay attention to the fact that numbers are
printed in the same order in which they were added to the queue.&lt;/p&gt;
&lt;p&gt;Coming back to the examples from the beginning of the article, we can
use queues to share information between threads. We can modify the
function such that instead of a list as an argument, it accepts a queue
from which it will read elements. Then, it will output the results to an
output queue:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from threading import Thread, Event
from queue import Queue
from time import sleep, time

event = Event()

def modify_variable(queue_in, queue_out):
    while True:
        if not queue_in.empty():
            var = queue_in.get()
            for i in range(len(var)):
                var[i] += 1
            queue_out.put(var)
        if event.is_set():
            break
    print('Stop printing')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To use the code above, we will need to create two queues. The idea is
that we can also create two threads, in which the input and output queue
are reversed. In that case, on thread puts its output on the queue of
the second thread and the other way around. This would look like the
following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;my_var = [1, 2, 3]
queue1 = Queue()
queue2 = Queue()
queue1.put(my_var)
t = Thread(target=modify_variable, args=(queue1, queue2))
t2 = Thread(target=modify_variable, args=(queue2, queue1))
t.start()
t2.start()
t0 = time()
while time()-t0 &amp;lt; 5:
    try:
        sleep(1)
    except KeyboardInterrupt:
        event.set()
        break
event.set()
t.join()
t2.join()
if not queue1.empty():
    print(queue1.get())
if not queue2.empty():
    print(queue2.get())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In my case, the output I get is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;[871, 872, 873]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Much smaller than everything else we have seen so far, but at least we
managed to shared data between two different threads, without any
conflicts. Where does this slow speed come from? Let's try with the
scientific approach which is to split the problem and look at each part.
One of the most interesting things is that we are checking whether the
queue is empty before trying to run the rest of the code. We can monitor
how much time it is actually spent running the important part of our
program:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def modify_variable(queue_in: Queue, queue_out: Queue):
    internal_t = 0
    while True:
        if not queue_in.empty():
            t0 = time()
            var = queue_in.get()
            for i in range(len(var)):
                var[i] += 1
            queue_out.put(var)
            internal_t += time()-t0
        if event.is_set():
            break
    sleep(0.1)
    print(f'Running time: {internal_t} seconds\n')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The only changes are the addition of a new variable in the function,
called &lt;code&gt;internal_t&lt;/code&gt;. Then, we monitor the time spent calculating and
putting to the new thread. If we run the code again, the output you
should get is something like:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;Running time: 0.0006377696990966797 seconds
Running time: 0.0003573894500732422 seconds
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This means that out of the 5 seconds in which our program runs, only
during about .9 milliseconds we are actually doing something. This is
.01% of the time! Let's quickly see what happens if we change the code
for using only one queue instead of two, i.e. the input and output queue
would be the same:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;t = Thread(target=modify_variable, args=(queue1, queue1))
t2 = Thread(target=modify_variable, args=(queue1, queue1))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With just that change, I've got the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;Running time: 4.290639877319336 seconds
Running time: 4.355865955352783 seconds
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That is much better! For the about of 5 seconds in which the program
runs, the threads run for a total of 8 seconds. Which is what one would
expect of parallelizing. Also, the output of the loops is much larger:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;[710779, 710780, 710781]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Can you try to guess what made our program so slow if we use two queues
but reasonably fast if we use the same queue for output and input? You
have to remember that when you use threads &lt;em&gt;blindly&lt;/em&gt; as we have done in
the previous example, we leave everything in the hands of the operating
system.&lt;/p&gt;
&lt;p&gt;We have no control of whether the OS decides to switch from a task to
another. In the code above, we check whether the queue is empty. It may
very well be that the operating system decides to give priority to a
task which is basically not doing anything, but waiting until there is
an element in the queue. If this happens out of synchronization, most of
the time the program will be just waiting to have an element in the
queue (it is always prioritizing the wrong task). While when we use the
same task for input and output, it doesn't matter which task it runs,
there will always be something to proceed.&lt;/p&gt;
&lt;p&gt;If you want to see whether the previous speculation is true or not, we
can measure it. We have only one &lt;code&gt;if&lt;/code&gt; statement to check
&lt;code&gt;queue.empty()&lt;/code&gt;, we can add an &lt;code&gt;else&lt;/code&gt; to accumulate the time the program
is actually not doing anything:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def modify_variable(queue_in: Queue, queue_out: Queue):
    internal_t = 0
    sleeping_t = 0
    while True:
        if not queue_in.empty():
            t0 = time()
            var = queue_in.get()
            for i in range(len(var)):
                var[i] += 1
            queue_out.put(var)
            internal_t += time()-t0
        else:
            t0 = time()
            sleep(0.001)
            sleeping_t += time()-t0
        if event.is_set():
            break
    sleep(0.1)
    print(f'Running time: {internal_t} seconds')
    print(f'Sleeping time: {sleeping_t} seconds')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the code above, if the queue is empty, the program will sleep for 1
millisecond. Of course, this is not the best, but we can assume that 1
millisecond will have no real impact on the overall performance of the
program. When I run the program above, using two different queues I get
the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;Running time: 0.0 seconds
Sleeping time: 5.001126289367676 seconds
Running time: 0.00018215179443359375 seconds
Sleeping time: 5.001835107803345 seconds
[4126, 4127, 4128]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Where it is clear that most of the time the program is just waiting
until more data is available on the queue. Since we are sleeping for 1
ms every time there is no data available, we are actually making the
program much slower. But I think it is a good example. We can compare it
with using the same queue for input and output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;Running time: 3.1206254959106445 seconds
Sleeping time: 1.3756272792816162 seconds
Running time: 3.253162145614624 seconds
Sleeping time: 1.136244535446167 seconds
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you see that even if we are wasting some time because of the sleep,
most of the time our routine is actually performing a calculation.&lt;/p&gt;
&lt;p&gt;The only thing you have to be careful when using the same queue for
input and output is that between checking whether the queue is empty and
actually reading from it, it could happen that the other thread grabbed
the result. This is described in the &lt;a href="https://docs.python.org/3/library/queue.html#queue.Queue.empty"&gt;Queue
documentation&lt;/a&gt;.
Unless we include a &lt;code&gt;Lock&lt;/code&gt; ourselves, the Queue can be read and written
by any threads. The Lock only comes into effect for the &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;put&lt;/code&gt;
commands.&lt;/p&gt;
&lt;h2&gt;Extra Options of Queues&lt;/h2&gt;
&lt;p&gt;Queues have some extra options, such as the maximum number of elements
they can hold. You can also define &lt;strong&gt;LIFO&lt;/strong&gt; (last-in, first-out) types
of queues, which you can read about &lt;a href="https://docs.python.org/3/library/queue.html#module-queue"&gt;in the
documentation&lt;/a&gt;.
What I find more useful about &lt;code&gt;Queues&lt;/code&gt; is that they are written in pure
Python. If you visit their &lt;a href="https://github.com/python/cpython/blob/3.7/Lib/queue.py"&gt;source
code&lt;/a&gt;, you can
learn a lot about synchronization in threads, &lt;a href="https://www.pythonforthelab.com/blog/learning-not-to-handle-exceptions"&gt;custom
exceptions&lt;/a&gt;, and
&lt;a href="https://www.pythonforthelab.com/blog/documenting-with-sphinx-and-readthedocs"&gt;documenting&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;What is important to note, is that when you work with multiple Threads,
sometimes you want to wait (i.e. block the execution), sometimes you
don't. In the examples above, we have always been checking whether the
Queue was empty before reading from it. But what happens if we don't
check it? The method &lt;code&gt;get&lt;/code&gt; has two options: &lt;code&gt;block&lt;/code&gt; and &lt;code&gt;timeout&lt;/code&gt;. The
first is used to determine whether we want the program to wait until an
element is available. The second is to specify the number of seconds we
want it to wait. After that amount of time, an exception is raised. If
we set &lt;code&gt;block&lt;/code&gt; to false, and the queue is empty, the exception is raised
immediately.&lt;/p&gt;
&lt;p&gt;We can change the function &lt;code&gt;modify_variable&lt;/code&gt; to take advantage of this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def modify_variable(queue_in: Queue, queue_out: Queue):
    internal_t = 0
    while True:
        t0 = time()
        var = queue_in.get()
        for i in range(len(var)):
            var[i] += 1
        queue_out.put(var)
        internal_t += time()-t0
        if event.is_set():
            break
    sleep(0.1)
    print(f'Running time: {internal_t} seconds\n')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this code, using different queues for input and output, I get the
following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;Running time: 4.914130210876465 seconds
Running time: 4.937211513519287 seconds

[179992, 179993, 179994]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which is much better than what we were getting before. But, this is not
really fair. A lot of time is spent just waiting in the &lt;code&gt;get&lt;/code&gt; function,
but we are still counting that time. If we move the line of
&lt;code&gt;t0 = time()&lt;/code&gt; right below the &lt;code&gt;get&lt;/code&gt;, the times the code is actually
running are very different:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;Running time: 0.7706246376037598 seconds
Running time: 0.763786792755127 seconds

[177807, 177808, 177809]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So now you see, perhaps we should have calculated the time differently
also in the previous examples, especially when we were using the same
queue for input and output.&lt;/p&gt;
&lt;p&gt;If we don't want to program to block while waiting for a get, we can do
the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from queue import Empty
[...]

    try:
        var = queue_in.get(block=False)
    except Empty:
        continue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or, we could specify a timeout, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;try:
    var = queue_in.get(block=True, timeout=0.001)
except Empty:
    continue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In that case, we either don't wait (&lt;code&gt;block==False&lt;/code&gt;) and we catch the
exception, or we wait for up to 1 millisecond (&lt;code&gt;timeout=0.001&lt;/code&gt;) and we
catch the exception. You can play around with these options to see if
the performance of your code changes in any way.&lt;/p&gt;
&lt;h2&gt;Queues to Stop Threads&lt;/h2&gt;
&lt;p&gt;Up to now, we have always used locks to stop threads, which is, I
believe, a very elegant way of doing it. However, there is another
possibility, which is to control the flow of threads by appending
special information to queues. A very simple example would be to add an
element &lt;code&gt;None&lt;/code&gt; to a queue, and when the function gets it, it stops the
execution. The code would look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;[...]

var = queue_in.get()
if var is None:
    break
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then, in the main part of the script, when we want to stop the
threads, we do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;queue1.put(None)
queue2.put(None)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you are wondering why you would choose one or the other option, the
answer is actually quite straightforward. The examples we are working
with, always have queues with 1 element at most. When we stop the
program, we know everything in the queue has been processed. Imagine,
however, that the program is processing a collection of elements, with
no relation between each other. This would be the case if you would be
downloading data from a website, for example, or processing images, etc.
You want to be sure you finish processing everything before stopping the
thread. In such a case, adding a special value to the queue guarantees
that all elements will be processed.&lt;/p&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;it is a very wise idea to be sure a queue is empty after you stop using
it. If, as before, you interrupt the thread by looking at the status of
a lock, the queue may be left with a lot of data in it, and thus the
memory will not be freed. A simple while-loop that gets all the elements
of a queue solves it.&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;IO Bound threads&lt;/h2&gt;
&lt;p&gt;The examples in this article are computationally intensive, and thus
they are right on the edge where using multi-threading is not applicable
and where all the problems arise (such as concurrency, etc.) We have
focused on the limits of multi-threading because if you understand them,
you will program with much more confidence. You won't be on your toes
hoping for a problem not to arise.&lt;/p&gt;
&lt;p&gt;An area where multi-threading excels is in IO (input-output) tasks. For
example, if you have a program which writes to the hard drive while it
is doing something else, the writing to the hard drive can be safely
offloaded to a separate thread, while the rest of the program keeps
running. This is also valid if the program waits for user input or
network resources to become available, downloads data from the internet,
etc.&lt;/p&gt;
&lt;h3&gt;Example downloading websites&lt;/h3&gt;
&lt;p&gt;To close this article, let's see an example of downloading websites
using threadings, queues, and locks. Even if some performance
improvements are possible, the example will show the basic building
blocks of almost any threading application of interest.&lt;/p&gt;
&lt;p&gt;First, let's discuss what we want to achieve. To keep the example
simple, we will download all the websites on a list, and we want to save
the downloaded information to the hard drive. The first approach would
be to create a for-loop that goes through the list. This code can be
found &lt;a href="https://github.com/PFTL/website/blob/master/example_code/32_threads_data/AI_download_data.py"&gt;on the Github
repository&lt;/a&gt;.
However, we would like to work with multiple threads.&lt;/p&gt;
&lt;p&gt;The architecture we propose therefore is: One Queue that hosts the
websites we want to download, one queue that hosts the data to be saved.
Some threads going to the websites to download, and each one outputs the
data to the other queue. Some threads which read the latter queue and
save the data to disk, taking care of not overwriting files. The modules
we are going to use for this example are:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import os
from queue import Queue
from threading import Lock, Thread
from urllib import request
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that we are using urllib to downloading data. We then create the
queues and the lock we are going to use:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;website_queue = Queue()
data_queue = Queue()
file_lock = Lock()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can proceed to define the functions which will run on separated
threads. For downloading data:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def download_data():
    while True:
        var = website_queue.get()
        if var is None:
            break
        response = request.urlopen(var)
        data = response.read()
        data_queue.put(data)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here you see that we used the strategy of checking whether the queue has
a special element, to be sure that we processed all the websites on the
queue before stopping the thread. We download the data from the website
and we put it on another queue to be later processed.&lt;/p&gt;
&lt;p&gt;The saving requires a bit more care because we have to be sure that no
two threads try to write to the same file:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def save_data():
    while True:
        var = data_queue.get()
        if var is None:
            break
        with file_lock:
            i = 0
            while os.path.exists(f'website_data_{i}.dat'):
                i += 1
            open(f'website_data_{i}.dat', 'w').close()
        with open(f'website_data_{i}.dat', 'wb') as f:
            f.write(var)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The approach is similar to the downloading of data. We wait until a
special element is present to stop the thread. Then we acquire a lock to
be sure no other thread is looking at the available files to write to.
The loop just checks which file number is available. We have to use a
lock here because there is a change two threads run the same lines at
the same time and find the available file to be the same.&lt;/p&gt;
&lt;p&gt;When we write to the file, we don't care about the lock, because we know
that only one thread will write to each file. That is why we create the
file on one line, while the lock is acquired:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;open(f'website_data_{i}.dat', 'w').close()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But we write the data on a separate line, without the lock:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with open(f'website_data_{i}.dat', 'wb') as f:
    f.write(var)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This may seem too convoluted for our purposes, and it is true. However,
it shows one possible approach in which several threads could be writing
to the hard drive at the same time because they are writing to different
files. Note that we have used &lt;code&gt;wb&lt;/code&gt; for the opening of the file. The &lt;code&gt;w&lt;/code&gt;
is because we want to write to the file (not append), and the &lt;code&gt;b&lt;/code&gt;
because the result of reading the &lt;code&gt;response&lt;/code&gt; is binary and not a string.
Then, we need to trigger the threads we want to download and save the
data. First, we create a list of websites we want to download. In this
case, Wikipedia homepages in different languages:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;website_list = [
    'https://www.wikipedia.org/',
    'https://nl.wikipedia.org/',
    'https://de.wikipedia.org/',
    'https://fr.wikipedia.org/',
    'https://pt.wikipedia.org/',
    'https://it.wikipedia.org',
    'https://ru.wikipedia.org',
    'https://es.wikipedia.org',
    'https://en.wikipedia.org',
    'https://ja.wikipedia.org',
    'https://zh.wikipedia.org',
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then we prepare the queues and trigger the threads:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;for ws in website_list:
    website_queue.put(ws)

threads_download = []
threads_save = []
for i in range(3):
    t = Thread(target=download_data)
    t.start()
    threads_download.append(t)
    t2 = Thread(target=save_data)
    t2.start()
    threads_save.append(t2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this, we create lists with the threads running for saving and
downloading. Of course, the numbers could have been different. Then, we
need to be sure we stop the downloading threads:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;for i in range(3):
    website_queue.put(None)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since we run 3 threads for downloading data, we have to be sure we
append 3 &lt;code&gt;None&lt;/code&gt; to the Queue, or some thread won't stop. After we are
sure the downloading finished, we can stop the saving:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;for t in threads_download:
    t.join()

for i in range(3):
    data_queue.put(None)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then we wait for the saving to finish:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;for t in threads_save:
    t.join()
print(f'Finished downloading {len(website_list)} websites')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we know all the threads have finished and the queues are empty. If
you run the program, you can see the list of 10 files created, with the
HTML of 10 different Wikipedia homepages.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;In the &lt;a href="https://www.pythonforthelab.com/blog/starting-and-synchronizing-threads"&gt;previous article&lt;/a&gt;, we have
seen how you can use threading to run different functions at the same
time, and some of the most useful tools you have available to control
the flow of different threads. In this article we have discussed how you
can share data between threads, exploiting both the fact of the shared
memory between threads and by using queues.&lt;/p&gt;
&lt;p&gt;Having access to shared memory makes programs very quick to develop, but
they can give rise to problems when different threads are
reading/writing to the same elements. This was discussed at the
beginning of the article, in which we explored what happens when using a
simple operator such as &lt;code&gt;=+&lt;/code&gt; to increase the values of an array by 1.
Then we explored how to use Queues to share data between threads, both
between the main thread and child threads as between child threads.&lt;/p&gt;
&lt;p&gt;To finish, we have shown a very simple example of how to use threads to
download data from a website and save it to disk. The example is very
basic, but we will expand it in the following article. Other IO
(input-output) tasks that can be explored are &lt;a href="https://www.pythonforthelab.com/blog/step-by-step-guide-to-building-a-gui"&gt;acquisition from
devices&lt;/a&gt; such as a camera, waiting
for user input, &lt;a href="https://www.pythonforthelab.com/blog/introduction-to-storing-data-in-files"&gt;reading from disk&lt;/a&gt;,
etc.&lt;/p&gt;
&lt;p&gt;Header Illustration by &lt;a href="https://dribbble.com/tsvety-designs"&gt;Tsvetelina
Stoynova&lt;/a&gt;&lt;/p&gt;</content><category term="blog"></category><category term="threading"></category><category term="data"></category><category term="queue"></category><category term="sharing"></category><category term="threads"></category><category term="async"></category><category term="multithreading"></category></entry><entry><title>Starting and Synchronizing Threads</title><link href="https://www.pythonforthelab.com/blog/starting-and-synchronizing-threads" rel="alternate"></link><published>2019-08-06T00:00:00+02:00</published><updated>2019-08-06T00:00:00+02:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2019-08-06:/blog/starting-and-synchronizing-threads</id><summary type="html">&lt;p&gt;If you have developed code for long enough, probably you have faced the
situation in which a task takes longer to complete and in the meantime,
your program can't perform any other task. Most likely you can't even
politely cancel what the program is doing, you will have to resort …&lt;/p&gt;</summary><content type="html">&lt;p&gt;If you have developed code for long enough, probably you have faced the
situation in which a task takes longer to complete and in the meantime,
your program can't perform any other task. Most likely you can't even
politely cancel what the program is doing, you will have to resort to
the Ctrl+C strategy. Fortunately, Python has different approaches to
overcome these issues.&lt;/p&gt;
&lt;p&gt;In this introduction, we are going to cover how you can use Threads to
develop a more flexible program. We have already discussed about
&lt;a href="https://www.pythonforthelab.com/blog/implementing-threads-for-measurements"&gt;threads&lt;/a&gt;, and we have used
them when &lt;a href="https://www.pythonforthelab.com/blog/step-by-step-guide-to-building-a-gui"&gt;developing a user
interface&lt;/a&gt;. In this article, we
are going to organize the information available for you to learn how to
be creative with threads in your own programs.&lt;/p&gt;
&lt;h2&gt;What are not Threads&lt;/h2&gt;
&lt;p&gt;If you are a native English speaker, the word &lt;em&gt;thread&lt;/em&gt; may bring to mind
a clear picture, which is not always the case if English is your second
language. Think about a sweater, it is made out of many threads that run
up and down, left and right, all intertwined. In a computer program, a
thread looks the same, is a logical path that runs from start to end,
but it doesn't need to be unique.&lt;/p&gt;
&lt;p&gt;It is important to note, however, that threads which belong to the same
process in Python do not run exactly at the same time. A processor with
a single core can perform one computation at a time. However, even
before the multi-core processors appeared, it was possible to have
several programs open and running. It is also possible to type a new
address in your browser while a website is loading, etc.&lt;/p&gt;
&lt;p&gt;The idea of threads is that each one can be executed in short pieces,
and the computer has the freedom to switch, very quickly, between them.
For a short time, it is checking your spelling, for a short time, it
renders a website, for a short time it writes to the hard drive, etc.
This is what gives programs a smooth feeling, and it is exactly what we
did to &lt;a href="https://www.pythonforthelab.com/blog/step-by-step-guide-to-building-a-gui"&gt;avoid the window freezing&lt;/a&gt;
when dealing with Qt.&lt;/p&gt;
&lt;p&gt;However, when the computation in one of the threads is very complex,
there won't be enough time to switch from one to the other. Downloading
data, waiting for user input, writing to the hard drive, those are not
computationally expensive tasks, and that is why you can run several of
those threads simultaneously. Rendering an image, for example in a
videogame, requires millions of complex calculations. Thus, threads
won't help you achieve a smoother program if one of the tasks you need
to run is computationally very expensive.&lt;/p&gt;
&lt;p&gt;This will become clearer when we start developing complex examples and
we explore the limitations and advantages of each approach we decide to
take.&lt;/p&gt;
&lt;h2&gt;A Simple Thread&lt;/h2&gt;
&lt;p&gt;When dealing with threads, the best is to start with a very simple
example. Let's create a function that takes longer to execute, but which
is not computationally very expensive. For example something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from time import sleep

def print_numbers(number, delay=1):
    for i in range(number):
        print(i)
        sleep(delay)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the function, for example by doing &lt;code&gt;print_numbers(10)&lt;/code&gt;, you
will see that the program takes 10 seconds to run and in the meantime,
your program is not able to do anything else. To be more strict, our
program has only one thread in which the function is executed.&lt;/p&gt;
&lt;p&gt;One possible approach would be to run the function on a separate thread.
The syntax would be as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from threading import Thread

t = Thread(target=print_numbers, args=(10,))
t.start()
print('Thread started')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To create a thread we specify which function is going to run in it. Pay
attention to the lack of &lt;code&gt;()&lt;/code&gt; when defining the target. We want to pass
the function itself, and not the result of the function to the thread.
To specify arguments, we can pass a tuple (or any iterable). If you run
the program, you will see an output like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;0
Thread started
1
2
3
4
5
6
7
8
9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Can you explain what is going on? You see first the 0, which gets
printed because of the line &lt;code&gt;t.start()&lt;/code&gt;, then the print statement is
executed, but the rest of the &lt;code&gt;print_numbers&lt;/code&gt; appears later. With this
approach, there is a lot that you can experiment with. Last syntax topic
to cover, if you want to pass a keyword argument (like the &lt;code&gt;delay&lt;/code&gt;), you
can simply do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;t = Thread(target=print_numbers, args=(10,), kwargs={'delay': .2})
t.start()
print('Thread started')
&lt;/code&gt;&lt;/pre&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;Perhaps you will see that not always the &lt;code&gt;Thread Started&lt;/code&gt; message
appears after the &lt;code&gt;0&lt;/code&gt;. That happens because in the example above you
have no control at all on the order in which commands will be executed.
If the operating system is busier, the result may slightly change, etc.
The starting of a thread may happen slightly later than the following
line on the main thread.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;The last basic behavior you need to be aware of is on how to wait until
the thread finishes. Perhaps you want to be sure a thread is finished
before you try to do something with its results, or you want to be sure
you can safely close the program, etc. This can be achieved with the
&lt;code&gt;join&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;t = Thread(target=print_numbers, args=(10,), kwargs={'delay': .2})
t.start()
print('Thread started')
t.join()
print('Thread finished')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You will see that the message &lt;code&gt;Thread finished&lt;/code&gt; will always be printed
after the execution of the function is done. Now you have the basic flow
for working with multiple threads. Remember that there is always going
to be a &lt;em&gt;main thread&lt;/em&gt;, which is the one that you create when running the
script, and from this one others are created.&lt;/p&gt;
&lt;p&gt;Of course, we are not limited to starting only one thread, we can create
several. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;t1 = Thread(target=print_numbers, args=(10,), kwargs={'delay':.5})
t2 = Thread(target=print_numbers, args=(5,))
t1.start()
t2.start()

t1.join()
t2.join()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you look at the output you will see that numbers are being printed at
the same time from both threads. Starting threads as t1, t2 is not the
most elegant solution, but for the time being it proves its point.&lt;/p&gt;
&lt;h2&gt;Shared Memory&lt;/h2&gt;
&lt;p&gt;One of the most important topics when working with threads is that of
shared memory. Most likely you have realized that when you develop a
program, you define variables, functions, etc. However, variables
defined in another program are not accessible. Each program has access
to a determined memory space. Threads share the same memory space and
thus can modify each other's data.&lt;/p&gt;
&lt;p&gt;Let's start by showing how you can modify the elements of a numpy array:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import numpy as np

def increase_by_one(array):
    array += 1

data = np.ones((100,1))
increase_by_one(data)

print(data[0])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What you see in the code above is that the function &lt;code&gt;increase_by_one&lt;/code&gt;
takes one argument and increases its value by one. If the argument is a
numpy array, it will increase the value of each element by one. What is
important to note, is that the function is not returning any value. This
can be done because arrays are mutable. You can check the article about
&lt;a href="https://www.pythonforthelab.com/blog/mutable-and-immutable-objects"&gt;mutable and immutable data
types&lt;/a&gt; in case you are
curious.&lt;/p&gt;
&lt;p&gt;Pay attention to the fact that if instead of an array, you use a number
as your data, the effect won't be the same. Let's see how we can use the
example above with threads:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;t = Thread(target=increase_by_one, args=(data,))
t.start()
t.join()
print(data[0])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What you see in the code above is very subtle, but very important also.
Data was defined on the main thread and is passed as an argument to the
thread. Inside the thread, the data gets modified, but that is happening
to the data on the main thread. This basically means that the data on
the main thread and the data on the child thread is actually the same.&lt;/p&gt;
&lt;p&gt;This behavior is very important because it is what allows you to quickly
get information out of a thread. If the function &lt;code&gt;increase_by_one&lt;/code&gt; would
have returned a value, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def increase_by_one(array):
    new_arr = array + 1
    return new_array
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There wouldn't have been a way of just getting the information out of
the child thread. Therefore, for working with threading you will also
need to design your code in such a way that allows you to achieve what
you want.&lt;/p&gt;
&lt;p&gt;Of course, the data can be shared between more threads. For example, we
can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from threading import Thread
import numpy as np


def increase_by_one(array):
    for i in range(10000):
        array += 1


def square(array):
    for i in range(10000):
        array /= 1.1


data = np.ones((100,1))

t = Thread(target=increase_by_one, args=(data,))
t2 = Thread(target=square, args=(data,))
t.start()
t2.start()
t.join()
t2.join()
print(data[0])
print(np.mean(data))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You see that in the example above, we defined two different functions,
one that increases the value in the array by 1 and the other which
divides it by 1.1. Each function performs the operation 10000 times. If
you run the code, you will see that at the end, the value of the first
element of the array and the mean value are being printed.&lt;/p&gt;
&lt;p&gt;Go ahead and run the program more than once. Do you get always the same
result? Most likely you don't. If you get the same result, increase the
number of times each operation is performed from 10000 until you see the
effect. You can also try lowering from 10000 and at some point, you will
see that the result is always the same.&lt;/p&gt;
&lt;p&gt;Are you able to explain what is going on?&lt;/p&gt;
&lt;p&gt;In the previous example, at the beginning of the article, there was
always a sleep statement. Sleep blocks the program execution, but the
processor is not doing anything. That gives plenty of opportunities for
other tasks to run. Remember that the switching from one thread to the
other is handled by the operating system.&lt;/p&gt;
&lt;p&gt;In the examples of this section, both functions are computationally
expensive. Even if they are silly examples, they don't give a break to
the processor (there is no sleep). Increasing the value of all the
elements of an array 10000 times takes a while to run, the same is true
for dividing by a value. However, what happens, is that at some point
the operating system decides to halt one thread and run the other. The
exact moment at which this happens is not under your control, but the
operating system's.&lt;/p&gt;
&lt;p&gt;Since the switch from one task to the other happens at apparently random
moments, the result you get is not the same. Remember that first adding
and then dividing is not the same than first dividing and then adding.
Having shared memory can be great, but you also have to be careful when
you are expecting a special result. For example, you may end up dividing
by zero only if a particular set of events happens in a special order.
It may very well be that when you test your program it works, but once
in a while, it will crash.&lt;/p&gt;
&lt;h2&gt;A More Extreme Example&lt;/h2&gt;
&lt;p&gt;Numpy is a highly optimized library that takes care of a lot of things
for you. In the examples above, every time we increase or divide the
values in an array, even if we don't see it, there is a loop under the
hood going through each individual element. One of the things numpy
takes care for us is that the loop never gets interrupted. It won't
happen that some elements are first increased and then divided, and some
elements are the opposite.&lt;/p&gt;
&lt;p&gt;However, we can force this behavior, to make very apparent what happens
when working with threads on changing elements on shared memory. First,
we can change the functions:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def increase_by_one(array):
    for i in range(len(array)):
        array[i] += 1

def divide(array):
    for i in range(len(array)):
        array[i] /= 1.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Compared to what we did before, this is a highly inefficient way of
achieving the same result, but it is useful to prove our point. Now, if
you run it like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;data = np.ones((100000,1))

t = Thread(target=increase_by_one, args=(data,))
t2 = Thread(target=divide, args=(data,))
t.start()
t2.start()
t.join()
t2.join()
print(np.max(data))
print(np.min(data))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You will see that the maximum value and the minimum value in your array
may not be the same. This means that for some elements the order of the
operation was reversed. Now you start seeing that threading has its
subtleties. The main problem is that since it is hard to anticipate the
exact flow, the outcome of the same program may change with each
execution.&lt;/p&gt;
&lt;p&gt;Debugging multi-threaded programs which are badly design is an
incredibly tough task.&lt;/p&gt;
&lt;h2&gt;Synchronizing Threads with Locks&lt;/h2&gt;
&lt;p&gt;In the example above, we saw that when running multiple threads, the
operating system has control on the order in which each is run. If we
run the code more than once, we could end up with different results. To
synchronize different threads, we can make use of &lt;code&gt;Locks&lt;/code&gt;. A lock is a
special object which can be &lt;code&gt;acquired&lt;/code&gt; and &lt;code&gt;released&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;When you try to acquire a lock, the program will wait until the lock is
released. This means that the lock can't be acquired more than once at
the same time. A lock allows you to explicitly wait until something
finishes running before something else runs. Let's see a very simple
implementation based on the example above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from threading import Lock

lock = Lock()

def increase_by_one(array):
    lock.acquire()
    for i in range(len(array)):
        array[i] += 1
    lock.release()


def divide(array):
    lock.acquire()
    for i in range(len(array)):
        array[i] /= 1.1
    lock.release()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The lock is created at the beginning. Now, you see that each function
starts by acquiring the lock. If it was already acquired, it will wait
there until it is released. This means that the for-loop which increases
each element by one or which divides each element needs to finish before
the other will be able to run.&lt;/p&gt;
&lt;p&gt;By using &lt;a href="https://www.pythonforthelab.com/blog/the-with-command-and-custom-classes"&gt;context managers&lt;/a&gt; the
syntax can become much simpler:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def increase_by_one(array):
    with lock:
        for i in range(len(array)):
            array[i] += 1

def divide(array):
    with lock:
        for i in range(len(array)):
            array[i] /= 1.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is a final detail that is worth mentioning. We could acquire the
lock in the main thread to prevent the execution of the two functions
until a certain moment. We could do something like the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;lock.acquire()
data = np.ones((100000,1))
t = Thread(target=increase_by_one, args=(data,))
t2 = Thread(target=divide, args=(data,))
t2.start()
t.start()
print('Threads are still not running')
data += 10
lock.release()
t.join()
t2.join()
print(np.max(data))
print(np.min(data))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case, the lock is acquired from the main thread. This means that
the other threads will be waiting until the lock is released to run, and
only one will run at a time. However, it is important to point out that
which thread runs first depends on the implementation of the operating
system.&lt;/p&gt;
&lt;h2&gt;Synchronizing Threads: RLocks&lt;/h2&gt;
&lt;p&gt;Locks can be very useful when you want to ensure that a certain block of
code will run completely before something else alters the data on which
you are working. There is, however, a caveat. The functions we defined
above, &lt;code&gt;increase_by_one&lt;/code&gt; and &lt;code&gt;divide&lt;/code&gt; both acquire a lock. Imagine that
we would like to execute one of those functions on the main code, and
prevent the other threads from running, we can try something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;lock.acquire()
data = np.ones((100000,1))
t = Thread(target=increase_by_one, args=(data,))
t2 = Thread(target=divide, args=(data,))
t2.start()
t.start()
increase_by_one(data)
lock.release()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you try to run the code, it will simply hang. Depending on your level
of experience with threading, it may be very hard to realize where the
problem is. A common approach would be to add print statements at key
positions to understand what runs and where it stops.&lt;/p&gt;
&lt;p&gt;In the example above, we start by acquiring the &lt;code&gt;lock&lt;/code&gt;. This will
prevent the threads from changing the data. However, when we explicitly
call &lt;code&gt;increase_by_one&lt;/code&gt;, it will also want to acquire the &lt;code&gt;lock&lt;/code&gt;. This
makes the program wait in that line indefinitely for the lock to be
released, but it won't happen.&lt;/p&gt;
&lt;p&gt;Another object that may be very helpful in this scenario is the &lt;code&gt;RLock&lt;/code&gt;,
or reentrant lock. The syntax will be very similar, we just need to do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from threading import RLock

lock = RLock()

[...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I've removed the repeated code for brevity. If you try again, you will
see that the program runs as expected. Reentrant locks are thread-aware,
this means that they block the execution, only if you try to acquire
them from a different thread, not from the same one. Since we acquired
the lock on the main thread, when we run the &lt;code&gt;increase_by_one&lt;/code&gt;, it will
not be blocked on the lock line.&lt;/p&gt;
&lt;p&gt;Re-entrant locks are a great tool when you may have functions that are
executed from different threads and you know it is safe to run them
within the same lock. You have to be very careful with the design of
your program to create code with an expected behavior. Sometimes RLocks
can be changed to Locks if the code is designed in a different way (or
vice versa), and you will have to decide what is healthier for the long
term.&lt;/p&gt;
&lt;h2&gt;Timeouts&lt;/h2&gt;
&lt;p&gt;A very common scenario when working with threads is that something
happens unexpectedly, either it happens before than expected, or an
exception is raised, or there is simply a bug in your code. In any case,
you will likely end up with threads which are blocked from running. And
thus, some resources may not be released in a timely fashion.&lt;/p&gt;
&lt;p&gt;To avoid these dead ends, we can implement timeouts for most blocking
operations. Let's see how to use a timeout for a &lt;code&gt;Lock&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def increase_by_one(array):
    l = lock.acquire(timeout=1)
    print('Lock: ', l)
    for i in range(len(array)):
        array[i] += 1

data = np.ones((100000,1))

t = Thread(target=increase_by_one, args=(data,))
lock.acquire()
t.start()
print('Before Sleeping')
sleep(5)
print('After sleeping')
t.join()
print(data[0])
print(np.mean(data))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code above is very similar to what we have been doing in the
previous examples. However, pay attention to the fact that we eliminated
the context manager from the &lt;code&gt;increase_by_one&lt;/code&gt; function, to make it
explicit. We've also added two print statements to show at which stage
the program is being delayed. If you run the code above, you should see
the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;Before Sleeping
Lock:  False
After sleeping
[2.]
2.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you see, that even if the lock is acquired by the main thread (and
never released), the thread which holds the &lt;code&gt;increase_by_one&lt;/code&gt; function
is executed correctly. You can alter the code to see what are the
different possibilities. It is important to note that the value for &lt;code&gt;l&lt;/code&gt;
within the function is &lt;code&gt;False&lt;/code&gt;. This allows you to monitor whether the
lock has timed out or not and act accordingly.&lt;/p&gt;
&lt;p&gt;Timeouts also work for &lt;code&gt;join&lt;/code&gt;. You have to be aware, though, that when
timeouts happen, you may be in a situation that you were not intending.
For example, if you are waiting for a lock and it times out, it means
that the intended state may not be met. In the examples above, it would
mean that we may try to increase and divide at the same time, without
being able to guarantee what happens first.&lt;/p&gt;
&lt;h2&gt;Events&lt;/h2&gt;
&lt;p&gt;Together with &lt;code&gt;Locks&lt;/code&gt;, &lt;code&gt;Events&lt;/code&gt; can be used to synchronize the behavior
of threads. Locks are useful because they can be acquired only once at a
time. However, this may not be what you need. Events, as the name
suggests, allow you to signal a specific condition which may be used by
several threads which were waiting for that event. Let's see a very
simple example, in which we run two threads to increase by one a value,
but we are waiting for the array to be populated before.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from threading import Thread, Event
import numpy as np

evnt = Event()

def increase_by_one(array):
    print('Waiting for event')
    l = evnt.wait()
    print('Increasing by one')
    for i in range(len(array)):
        array[i] += 1

data = np.zeros((100000,1))

t = Thread(target=increase_by_one, args=(data,))
t2 = Thread(target=increase_by_one, args=(data,))
t.start()
t2.start()
for i in range(len(data)):
    data[i] += 1
print('Data Ready. Setting event')
evnt.set()
t.join()
t2.join()
print(data[0])
print(np.mean(data))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What you see above, is that both threads are ready to run, but they will
wait until the event is set. By the way, the &lt;code&gt;wait&lt;/code&gt; command also accepts
a timeout argument. Then we prepare our data, by setting each element to
one. Once we are ready, we set the event which allows the threads to
stop waiting and start working.&lt;/p&gt;
&lt;p&gt;A very common scenario for this patter would be if you are waiting for a
connection to become available. Imagine you are communicating with a
database, you would like to run the threads once the communication is
established and not before. Resources which may take longer or shorter
to become available are clear indicators for using an &lt;code&gt;Event&lt;/code&gt; object.&lt;/p&gt;
&lt;h3&gt;Stopping Threads with Events&lt;/h3&gt;
&lt;p&gt;So far, we have always let the program run until its completion,
including the threads. However, a very common scenario is to have a
thread which will run forever, processing any data that comes its way.
For example, you may have a thread which continuously analysis the
content of tweets. At some point, you may want to stop the thread
without creating a keyboard interrupt. Events are ideal tools for this.
Let's see it with an example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from threading import Thread, Event
from time import sleep

import numpy as np

event = Event()

def increase_by_one(array):
    print('Starting to increase by one')
    while True:
        if event.is_set():
            break
        for i in range(len(array)):
            array[i] += 1
        sleep(0.1)
    print('Finishing')

data = np.ones((10000, 1))
t = Thread(target=increase_by_one, args=(data,))
t.start()
print('Going to sleep')
sleep(1)
print('Finished sleeping')
event.set()
t.join()
print(data[0])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the example above, based on what we have been always doing in this
tutorial, you see that there is a check within the loop. If the event is
set, then the loop will end. While the event is not set, the loop will
keep running forever. If we run the code, you will see that the thread
starts increasing by one, we wait for one second and we set the event to
break the loop.&lt;/p&gt;
&lt;p&gt;Since it takes at least 0.1 seconds to run each loop (there is a sleep),
and we wait 1 second to set the event, you can see that the final value
in the array is 10. You can experiment with different options, for
example, what happens if you remove the sleep in the function, do you
get much higher values? That gives you an idea of how fast your code is
running.&lt;/p&gt;
&lt;p&gt;Of course, you are not limited to stopping only one thread with an
event. You can use the same event in several threads. You are also not
constrained to set the event from the main thread. You can signal events
from threads, etc. We are going to see this in the following article,
where we will explore applications of threads.&lt;/p&gt;
&lt;p&gt;If you try to stop a threaded application by pressing Ctrl+C (or
Ctrl+Break if you are on Windows), you will notice that the thread which
is stopped is normally the main thread, but the other threads keep
running. When you start having several threads running at the same time,
it is important to start including into your design how you will handle
the finalization of your program, both intentionally and not
intentionally.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;In this article, we have seen the basics of working with threads. We
have seen how you can start multiple threads and how to synchronize
them. You have to remember that threads are not running simultaneously,
and therefore you can't run your code faster, but it gives you a lot of
flexibility when there are tasks that are slow and not computationally
expensive.&lt;/p&gt;
&lt;p&gt;The examples that we have seen in this tutorial are almost trivial and
most are based on performing highly inefficient tasks, such as
increasing the values in an array one by one. If you want to continue
learning about threads, you can head to the following tutorial on &lt;a href="https://www.pythonforthelab.com/blog/handling-and-sharing-data-between-threads"&gt;how
to handle data with threads in
Python&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Header Illustration by &lt;a href="https://dribbble.com/tsvety-designs"&gt;Tsvetelina
Stoynova&lt;/a&gt;&lt;/p&gt;</content><category term="blog"></category><category term="threads"></category><category term="async"></category><category term="multithreading"></category><category term="parallel"></category></entry><entry><title>Monkey Patching and its consequences</title><link href="https://www.pythonforthelab.com/blog/monkey-patching-and-its-consequences" rel="alternate"></link><published>2019-06-18T00:00:00+02:00</published><updated>2019-06-18T00:00:00+02:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2019-06-18:/blog/monkey-patching-and-its-consequences</id><summary type="html">&lt;p&gt;Monkey patching is a technique that allows you to alter the behavior of
objects at runtime. Even though it can be a very useful feature, it can
also make your code much harder to understand and debug, and therefore
you have to be careful with how you implement monkey patching …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Monkey patching is a technique that allows you to alter the behavior of
objects at runtime. Even though it can be a very useful feature, it can
also make your code much harder to understand and debug, and therefore
you have to be careful with how you implement monkey patching. In this
article, we are going to see some examples of how you can use monkey
patching to solve quickly specific problems. We are also going to
discuss the consequences of monkey patching in the context of larger
projects.&lt;/p&gt;
&lt;p&gt;Monkey patching is tightly related to the idea of &lt;a href="https://www.pythonforthelab.com/blog/mutable-and-immutable-objects"&gt;mutability in
Python&lt;/a&gt;. Custom objects are
mutable, and therefore their attributes can be replaced without creating
a new copy of the object. To quickly recap those ideas, we can do the
following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    a = 1
    b = '2'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then we can use the code like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;var1 = MyClass()
var2 = var1

var1.a = 2
var1.b = '3'

print(var2.a)
# 2
print(var2.b)
# '3'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we go line by line, you see that we create an object using &lt;code&gt;MyClass&lt;/code&gt;
and we call it &lt;code&gt;var1&lt;/code&gt;. We then copy the object to another variable,
called &lt;code&gt;var2&lt;/code&gt;. We change the values stored in &lt;code&gt;var1&lt;/code&gt;, but we observe
that the values stored in &lt;code&gt;var2&lt;/code&gt; have also changed. This is simply
because, in Python, the variable is only a label. In the line
&lt;code&gt;var2 = var1&lt;/code&gt; we have just copied the label, but both are pointing to
the same underlying object.&lt;/p&gt;
&lt;p&gt;Python also allows you to change attributes in the class itself, not in
the instance of the class. We can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;var1 = MyClass()
var2 = MyClass()
print(var1.a)
# 1
MyClass.a = 2
print(var1.a)
# 2
print(var2.a)
# 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What we see is that if we directly alter the value of any of the
attributes of the class, the instances inherit this change. This is both
very useful and very dangerous, since you may be altering the value of
attributes of objects which you were not intending to modify. There is
one last behavior that is important to point out, and refers to mixing
the two approaches we have followed before:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;var1 = MyClass()
var2 = var1

var1.a = 2
var1.b = '3'

MyClass.a = 3

print(var1.a)
# 2
print(var2.a)
# 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Even if you change the attribute &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;3&lt;/code&gt;, you don't see this change
appearing on the instances of the class. The root cause of this lays in
the ideas behind &lt;a href="https://www.pythonforthelab.com/blog/mutable-and-immutable-objects"&gt;mutable and
immutable&lt;/a&gt; data types in
Python. Since you altered the value of &lt;code&gt;var1.a&lt;/code&gt;, now the attribute is
pointing to an object different from the object the class attribute
points to. If this last line doesn't make sense, go to the articles
linked earlier on mutable and immutable data types.&lt;/p&gt;
&lt;p&gt;Finally, the last case I wanted to point out is what happens if you keep
a reference to the attribute &lt;code&gt;a&lt;/code&gt; before you modify it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;var1 = MyClass()
var2 = var1

var3 = var1.a
[...]
print(var3)
# 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I have skipped the code in which you change the value of the attributes.
Now you see that if you actually store &lt;code&gt;var1.a&lt;/code&gt; in the variable &lt;code&gt;var3&lt;/code&gt;,
this variable is actually modified when you change the value stored
directly in the class. All this behavior actually makes sense, if you
think that variables only store references to objects and not the object
itself and that when you change an immutable variable, you create a new
reference.&lt;/p&gt;
&lt;p&gt;All the examples above refer to monkey patching in one way or another.
You can see that we are changing the values of a class during runtime.
We have tried to highlight some of the consequences, expected or not, of
changing the value of an attribute later in the execution of the program
and not in the definition itself.&lt;/p&gt;
&lt;p&gt;The examples above can be extended if we consider that methods are
attributes which behave exactly like &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; in our examples above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    a = 1
    b = '2'

    def get_value(self):
        return self.a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We instantiate the class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;var1 = MyClass()
print(var1.get_value())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we should see that everything is working as expected. We then define
a new function that we would like to use to replace &lt;code&gt;get_value&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def get_new_value(cls):
    return cls.b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the function above, I've replaced &lt;code&gt;self&lt;/code&gt; by &lt;code&gt;cls&lt;/code&gt; just to make it
more evident, but you are free to use whatever keyword makes more sense
in your context. And we replace the method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;MyClass.get_value = get_new_value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you use it, you will get:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;print(var1.get_value())
# 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You see that we have replaced the &lt;code&gt;get_value&lt;/code&gt; after the &lt;code&gt;var1&lt;/code&gt; has been
defined. If we would define a new object, it seems reasonable to expect
that we would get the same output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;var2 = MyClass()
print(var2.get_value())
# 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we would have defined the two distinct objects before changing the
method, the outcome would have been the same. What you see is that you
can overwrite the method of the class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;var1 = MyClass()
var2 = MyClass()

MyClass.get_value = get_new_value

print(var1.get_value())
print(var2.get_value())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The examples at the beginning of the article, when we were using an
integer or a string as attributes are still valid. You can check what
happens if you copy the object, you store it as a new variable, and then
you overwrite the method. There are no mysteries, methods are attributes
such as integers or strings. The main difference is that they take
inputs.&lt;/p&gt;
&lt;p&gt;In the example above, we have replaced the method at the class-level. If
we want to replace the method at an instance level, then the approach
would be slightly different. Note that if we do it at a class-level, all
the instances will get the changes, and this may not be what we want. We
can do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import types

class MyClass:
    a = 1
    b = '2'

    def get_value(self):
        return self.a

def get_new_value(cls):
    return cls.b

var1 = MyClass()
var2 = MyClass()
var1.get_value = types.MethodType(get_new_value, var1)
print(var1.get_value())
# 2
print(var2.get_value())
# 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You see in this example that we have altered the behavior of the method
of &lt;code&gt;var1&lt;/code&gt; but not of &lt;code&gt;var2&lt;/code&gt;. Note that we are importing &lt;code&gt;types&lt;/code&gt; at the
beginning of the script. The rest is the same we have already done, with
one exception when we replace the &lt;code&gt;get_value&lt;/code&gt; method. Because we are
changing a method of an instance, it needs to be of the proper type. We
can quickly see the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; type(get_new_value)
&amp;lt;class 'function'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; type(MyClass.get_value)
&amp;lt;class 'function'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; type(var1.get_value)
&amp;lt;class 'method'&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The main difference between a method and a function is that the first
one receives as first argument the instance itself (the &lt;code&gt;self&lt;/code&gt;). We have
therefore to transform a function into a method before replacing it on
an instance. Pay attention that this is not the case when you change the
class itself.&lt;/p&gt;
&lt;h2&gt;Module-level monkey patching&lt;/h2&gt;
&lt;p&gt;The last pattern that I would like to discuss is monkey-patching at the
module level. So far, the attributes and methods we have used, they all
belonged to a custom class. However, it is not the only possibility.
First, in a file called &lt;strong&gt;module.py&lt;/strong&gt; we can add the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def print_variable(var):
    print(var)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And in a second file called &lt;strong&gt;script.py&lt;/strong&gt; we add:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import module

var1 = 1

AE_module.print_variable(var1)
# 1
def print_plus_one(var):
    print(var+1)

AE_module.print_variable = print_plus_one
AE_module.print_variable(var1)
# 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You see that monkey patching works also for modules. When you try to
achieve this kind of patching, you have to be careful with the order in
which importing happens in Python. If you use the &lt;strong&gt;__init__.py&lt;/strong&gt;
files to load modules, and there is some dependency between each other,
when you monkey patch, it may be that it is too late for the program.
Similar to what happens when you alter the value of an attribute of an
object and then you change the value at a class-level.&lt;/p&gt;
&lt;p&gt;If you remember that Python imports modules only once, then the patching
can take very interesting forms. You can create a new file, called
&lt;strong&gt;module2.py&lt;/strong&gt; and add the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import module


def another_print(var):
    module.print_variable(var+1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You see that we are using the &lt;code&gt;print_variable&lt;/code&gt; from the original module.
We are just adding &lt;code&gt;+1&lt;/code&gt; before printing. We can alter the file
&lt;strong&gt;script.py&lt;/strong&gt; to include this new module:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import module
import module2

var1 = 1

module.print_variable(var1)
# 1

def print_plus_one(var):
    print(var+1)

module.print_variable = print_plus_one

module.print_variable(var1)
# 2
module2.another_print(var1)
# 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You see that by changing the &lt;code&gt;print_variable&lt;/code&gt; on our main script, we
have also altered what is happening on our second module. There are a
lot of things you can start thinking about after seeing these patterns.&lt;/p&gt;
&lt;h2&gt;When (not) to Monkey Patch&lt;/h2&gt;
&lt;p&gt;Monkey patching is very powerful and it shows how flexible Python is. In
the end, everything is derived from the same principles of understanding
different data types and what variables mean in Python. However, it may
be very hard to understand when would you use these patterns in your own
programs.&lt;/p&gt;
&lt;p&gt;As a general rule, the best is not to monkey patch. If you want to alter
the behavior of a program, for example, you can define child classes for
the ones you want to alter. The problem with monkey-patching is that the
behavior of a program becomes much harder to understand. In the example
above, when you call &lt;code&gt;module2.another_print&lt;/code&gt; you are seeing an output
which is very hard to understand. If you check the module, you won't see
why you would get &lt;code&gt;3&lt;/code&gt; and not &lt;code&gt;2&lt;/code&gt;. Tracing back where the behavior was
changed is very complicated. If you inspect the variables, you will see
that there is nothing wrong, and &lt;code&gt;var1&lt;/code&gt; is still &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;However, sometimes there can be a great benefit. For example,
calculating Fast Fourier Transforms with numpy can be slower than with
other implementations. Imagine you would like to use PyFFTW, but you
don't want to re-write all your program. You can monkey-patch your code!
See the example below (taken &lt;a href="http://hgomersall.github.io/pyFFTW/sphinx/tutorial.html"&gt;from the
docs&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import pyfftw
import numpy

numpy.fft = pyfftw.interfaces.numpy_fft
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, whenever you use the FFT routines provided by numpy, they will be
automatically replaced by those of PyFFTW. This can have a huge impact
on your program, and it only took one line of code! This is a special
example but there are other situations in which you may consider monkey
patching.&lt;/p&gt;
&lt;p&gt;A common situation is with testing. Sometimes you want to test your code
in an environment which lacks some functionality, or you want to prevent
that because of the test you actually modify a live database. In that
case, before doing the test you can change the methods that communicate
with a database. If you work in a lab, a very common situation is when
you want to avoid communicating with a device while you are testing your
program.&lt;/p&gt;
&lt;p&gt;Exactly how to achieve this behavior will depend on your situation, but
with the examples above you already have a clear picture of what the
strategy could be.&lt;/p&gt;
&lt;p&gt;Header Photo by &lt;a href="https://unsplash.com/@shashanksahay?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText"&gt;Shashank
Sahay&lt;/a&gt;
on Unsplash&lt;/p&gt;
&lt;p&gt;The code found in this article is &lt;a href="https://github.com/PFTL/website/tree/master/example_code/34_monkey_patching"&gt;available on
Github&lt;/a&gt;.
Any comment, improvement, or suggestion can be &lt;a href="https://github.com/PFTL/website/issues/new"&gt;submitted
here&lt;/a&gt;&lt;/p&gt;</content><category term="blog"></category><category term="functions"></category><category term="methods"></category><category term="monkey patching"></category><category term="replacing"></category><category term="extending"></category><category term="mutable"></category><category term="immutable"></category></entry><entry><title>Duck Typing, or how to check variable types</title><link href="https://www.pythonforthelab.com/blog/duck-typing-or-how-to-check-variable-types" rel="alternate"></link><published>2019-06-11T00:00:00+02:00</published><updated>2019-06-11T00:00:00+02:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2019-06-11:/blog/duck-typing-or-how-to-check-variable-types</id><summary type="html">&lt;p&gt;The name duck typing has its root in &lt;a href="https://en.wikipedia.org/wiki/Duck_typing"&gt;the
expression&lt;/a&gt; &lt;em&gt;If it walks like
a duck and it quacks like a duck, then it must be a duck&lt;/em&gt;. Which means
that if you want to know whether you are dealing with a duck or not, you
only care about how …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The name duck typing has its root in &lt;a href="https://en.wikipedia.org/wiki/Duck_typing"&gt;the
expression&lt;/a&gt; &lt;em&gt;If it walks like
a duck and it quacks like a duck, then it must be a duck&lt;/em&gt;. Which means
that if you want to know whether you are dealing with a duck or not, you
only care about how it looks like and how it behaves rather than
actually checking to what species the animal belongs.&lt;/p&gt;
&lt;p&gt;The code that we develop in this article is available &lt;a href="https://github.com/PFTL/website/tree/master/example_code/33_duck_typing"&gt;on
Github&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The analogy translates &lt;em&gt;almost&lt;/em&gt; literally to Python. Python is a
dynamically typed language. This means that you don't need to specify
what type of variables you are dealing with. The following lines are
perfectly valid Python code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;var1 = 'This is a string'
var1 = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see above, &lt;code&gt;var1&lt;/code&gt; changed from a string to an integer without
any problems. We didn't need to specify whether &lt;code&gt;var1&lt;/code&gt; was going to be
of either type. Without going to the details about what variables truly
mean in Python, we can see that it is very convenient because it saves
us from a lot of typing. On the other hand, it means that we can't be
sure what variable type a function will receive until an error is
raised, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def increase_by_one(value)
    return value + 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we run the function &lt;code&gt;increase_by_one&lt;/code&gt; with &lt;code&gt;var1&lt;/code&gt; it will work only
if &lt;code&gt;var1&lt;/code&gt; is a number (integer or float), but it will give us a
&lt;code&gt;TypeError&lt;/code&gt; if we run it with a string. Statically typed languages would
have warned us about this problem at compilation time and would have
prevented us from some headaches down the line.&lt;/p&gt;
&lt;p&gt;One easy solution would be to check whether the &lt;code&gt;value&lt;/code&gt; is either an
integer or a float. We can improve our function, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def increase_by_one(value):
    if isinstance(value, int) or isinstance(value, float):
        return value + 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we try to run the function with a string, it will not do anything and
it will return &lt;code&gt;None&lt;/code&gt;. If we run the function with either an integer or
a float, it will return the value increased by one. This behavior is
more or less what we would expect.&lt;/p&gt;
&lt;h2&gt;What is duck typing?&lt;/h2&gt;
&lt;p&gt;So, you may wonder after this long preamble, what is actually duck
typing. Imagine that we now have a numpy array, and we use the function
&lt;code&gt;increase_by_one&lt;/code&gt; with it, what do you expect to happen?&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import numpy as np

var1 = np.array((0, 1, 2))
print(increase_by_one(var1))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You get &lt;code&gt;None&lt;/code&gt;, but is that what you were expecting? If you think about
it, we forced the output because we designed the function to only work
on integers and floats, while an array is neither of them. However, if
we go back to the old version of the function before we implemented the
verification, we would get:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def increase_by_one(value):
    return value + 1

print(increase_by_one(var1))
# [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can see that the function &lt;code&gt;increase_by_one&lt;/code&gt; works also on arrays.
The idea of &lt;strong&gt;duck typing&lt;/strong&gt; is that we don't care about what type of
variable &lt;code&gt;value&lt;/code&gt; is, provided that we can add 1 to it. In Python, this
is translated to try to add 1 to &lt;code&gt;value&lt;/code&gt; and if an exception is raised,
we deal with it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def increase_by_one(value):
    try:
        value += 1
    except TypeError:
        return None
    return value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, the function will run with all types of variables which accept
being added by one. At the beginning we assumed only floats and integers
were able to be added by one, then we found that numpy arrays are also
working, and you can find that there are even more possibilities around.&lt;/p&gt;
&lt;h2&gt;Custom Classes&lt;/h2&gt;
&lt;p&gt;Duck typing becomes crucial when you develop your custom classes. Python
exposes a lot of syntactic sugar which allow you to customize how things
behave under certain operations. To keep up with the example above,
let's develop a class which allows being increased by one:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class AddOne:
    def __init__(self, value):
        self.value = str(value)

    def __add__(self, other):
        self.value += str(other)
        return self

    def __str__(self):
        return self.value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we can use it like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;var1 = AddOne('0')
print(increase_by_one(var1))
# 01
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What you see now, is that our class defines the behavior of adding. In
this case, the class will concatenate whatever value we add to the
initial string that we have defined. That is why we see that the output
is &lt;code&gt;01&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Duck typing means that our function will run every time there is a way
of adding a &lt;code&gt;1&lt;/code&gt; to the object. The example in these sections is almost
trivial, so we can see something which is much more relevant.&lt;/p&gt;
&lt;h2&gt;Complex Data Structures&lt;/h2&gt;
&lt;p&gt;When you develop larger programs, it is almost impossible not to need
configuration variables. Storing configuration parameters in
dictionaries is very handy because it is very explicit. Let's make it
very simple:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;configuration = {
    'param1': 10,
    'param2': 5
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we also develop an Experiment class, which will use the
configuration and will verify whether we have supplied all the needed
parameters:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Experiment:
    def __init__(self, config):
        self.configuration = config

    def check_config(self):
        if not {'param1', 'param2'} &amp;lt;= set(self.configuration.keys()):
            raise Exception('The configuration does not include the mandatory fields')
        print('Config seems OK')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You see that we have developed &lt;code&gt;check_config&lt;/code&gt; which uses sets to check
whether both parameters are within the keys of the dictionary. In other
words, we verify whether the set &lt;code&gt;{'param1', 'param2'}&lt;/code&gt; is a subset of
all the keys in the configuration.&lt;/p&gt;
&lt;p&gt;We can add one last method to check whether the parameters are within an
acceptable range:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def check_config_range(self):
    if self.configuration['param1'] &amp;gt; 10:
        raise Exception('param1 cannot be larger than 10')
    if self.configuration['param2'] &amp;gt; 5:
        raise Exception('param2 cannot be larger than 5')
    print('Range seems OK')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can test the code by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;exp = Experiment(configuration)
exp.check_config()
exp.check_config_range()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, where does duck typing come into effect?. In the code above we have
assumed that the configuration would be a dictionary, but we are not
bound to that. Imagine that we want to improve how we deal with
configurations. We can develop our custom class to handle the reading
from a file, perhaps logging changes to parameters, etc. And we want it
to be compatible with the &lt;code&gt;Experiment&lt;/code&gt; class that we have already
developed. Therefore, the duck-typing here works the other way around.
We know what the class needs in order to work properly, we just develop
a solution around it.&lt;/p&gt;
&lt;p&gt;If you look at the code of &lt;code&gt;Experiment&lt;/code&gt;, you see that it uses the
configuration in two different places. First, when it checks that both
&lt;code&gt;param1&lt;/code&gt; and &lt;code&gt;param2&lt;/code&gt; are present, through the method &lt;code&gt;keys&lt;/code&gt;. We know
that we will need a class that supports that method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Config:
    def __init__(self):
        ...

    def keys(self):
        ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We also know that when we want to use the parameters, we access them
through &lt;code&gt;configuration['param1']&lt;/code&gt;, and to achieve this, we will need to
tweak the magic method &lt;code&gt;__getitem__&lt;/code&gt;. Let's add one more requirement,
and is that we want to instantiate this class with a filename, which
will be read by the class and the data will be loaded. For simplicity,
we force the configuration file to be in YAML format. Thus, our &lt;code&gt;Config&lt;/code&gt;
class will look like this (you need pyyaml installed for this to work):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import yaml

class Config:
    def __init__(self, filename):
        with open(filename, 'r') as f:
            self._config = yaml.load(f.read(), Loader=yaml.FullLoader)

    def keys(self):
        return self._config.keys()

    def __getitem__(self, item):
        return self._config[item]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we go step by step, you can see that when we instantiate the class,
we ask for a filename, which we will open and we will load its contents
into an attribute called &lt;code&gt;_config&lt;/code&gt;. Note that Python doesn't have true
private attributes for classes (i.e. attributes that can be accessed
only within the class but not from outside). As a convention, attributes
starting with an underscore, such as &lt;code&gt;_config&lt;/code&gt; signal that they are not
supposed to be used directly, but we can't easily enforce it.&lt;/p&gt;
&lt;p&gt;Since &lt;code&gt;_config&lt;/code&gt; will be a dictionary, the implementation of the &lt;code&gt;keys&lt;/code&gt;
method will be trivial, we just use the default dictionary method.
&lt;code&gt;__getitem__&lt;/code&gt; is, however much more interesting. The &lt;code&gt;__getitem__&lt;/code&gt;
method in Python is the one that regulates what happens when you do
something like &lt;code&gt;c['param1']&lt;/code&gt;. &lt;code&gt;item&lt;/code&gt; in this case will be &lt;code&gt;param1&lt;/code&gt;, and
we want to retrieve that item from the &lt;code&gt;_config&lt;/code&gt; dictionary. If you want
to test this implementation, first, you need to create a file
&lt;strong&gt;config.yml&lt;/strong&gt; with the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;param1: 10
param2: 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then you can run:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;c = Config('config.yml')
print(c['param1'])
print(c['[param2'])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course, if you would like to change the value of 'param1' or
'param2', you will get an error. Covering this topic is beyond duck
typing, so keep tuned because we are going to discuss it in a later
tutorial.&lt;/p&gt;
&lt;p&gt;Now we can put everything together, our custom configuration class and
the experiment class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;c = Config('config.yml')
exp = Experiment(c)
exp.check_config()
exp.check_config_range()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you see that you are running the &lt;code&gt;Experiment&lt;/code&gt; with a configuration
which is not a dictionary but a custom designed class, and it works as
expected.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;If you look for the definition of duck typing, you will typically find
that in Python, it is common not to verify to which data type a variable
belongs. If those variables behave as expected, then you shouldn't
worry. In the beginning, we saw that this is very handy because it
allowed us to use a function on variables which we didn't originally
intend, such as numpy array or custom classes.&lt;/p&gt;
&lt;p&gt;In the second part, we saw that you can plan your code the other way
around. If you assume that duck typing is a common practice (i.e. that
the libraries you use don't verify the type of variables, but only their
functioning), you can design your own classes in such a way that they
behave as a specific data type. Our example was a class that mimics how
dictionaries work, and which we used as an argument in a different
object, which had no idea of our custom data type.&lt;/p&gt;
&lt;p&gt;Example code for this article can be found &lt;a href="https://github.com/PFTL/website/tree/master/example_code/33_duck_typing"&gt;on
Github&lt;/a&gt;.
You can also find the &lt;a href="https://github.com/PFTL/website/blob/master/content/blog/33_duck_typing.rst.md"&gt;source code for this
article&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Header image by &lt;a href="https://unsplash.com/@joshstyle?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText"&gt;JOSHUA
COLEMAN&lt;/a&gt;
on Unsplash&lt;/p&gt;</content><category term="blog"></category><category term="functions"></category><category term="methods"></category><category term="dynamic language"></category><category term="typing"></category><category term="types"></category></entry><entry><title>Introduction to Python Lambda Functions</title><link href="https://www.pythonforthelab.com/blog/intro-to-python-lambda-functions" rel="alternate"></link><published>2019-03-17T00:00:00+01:00</published><updated>2019-03-17T00:00:00+01:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2019-03-17:/blog/intro-to-python-lambda-functions</id><summary type="html">&lt;p&gt;Some time ago, Python introduced in its syntax the possibility to define
functions using &lt;code&gt;lambda&lt;/code&gt; instead of &lt;code&gt;def&lt;/code&gt;. These functions are called
anonymous and are very common in other languages such as Javascript.
However, in Python, they seem a bit obscure and are often either
overlooked or misused. In this …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Some time ago, Python introduced in its syntax the possibility to define
functions using &lt;code&gt;lambda&lt;/code&gt; instead of &lt;code&gt;def&lt;/code&gt;. These functions are called
anonymous and are very common in other languages such as Javascript.
However, in Python, they seem a bit obscure and are often either
overlooked or misused. In this article, we are going to introduce the
lambda functions and discuss where and how to use it.&lt;/p&gt;
&lt;p&gt;To define a function, you can use the following syntax:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def average(x, y):
    return (x+y)/2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, if you would like to calculate the average of two numbers, you can
simply do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;avg = average(2, 5)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In such case, &lt;code&gt;avg&lt;/code&gt; would have a value of &lt;code&gt;3.5&lt;/code&gt;. We could also define
&lt;code&gt;average&lt;/code&gt; like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;average = lambda x, y: (x+y)/2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you test this function, you will see that the output is exactly the
same. It is important to point out that the syntax is very different
between &lt;code&gt;def&lt;/code&gt; and &lt;code&gt;lambda&lt;/code&gt;. First, we define the arguments &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;
without any parenthesis. Then, we define the operation that we want to
apply. Note that the &lt;code&gt;return&lt;/code&gt; is implicit when you use a lambda
function.&lt;/p&gt;
&lt;p&gt;There are, however, more fundamental differences. Lambda functions must
be expressed on only one line, and they have no docstring. If you try
&lt;code&gt;help(average)&lt;/code&gt; on each definition above, you will see that the output
is very different. Moreover, there is no way of documenting what the
second version of &lt;code&gt;average&lt;/code&gt; is actually doing.&lt;/p&gt;
&lt;p&gt;Functionally speaking, both ways of defining &lt;code&gt;average&lt;/code&gt; give the same
result. So far, the difference between them is very subtle. The main
advantage of &lt;em&gt;lambda&lt;/em&gt; (or anonymous) functions is that they don't need a
name. Moreover, assigning a name like what we did above is considered
bad practice, as we will discuss later on. Let's now see in what context
you would like to use a lambda function instead of a normal function.&lt;/p&gt;
&lt;p&gt;Most tutorials focus on lambda functions for sorting a list. We can do
the same before going to other topics. Imagine that you have the
following list:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;var = [1, 5, -2, 3, -7, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Imagine you would like to sort the values, you can do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;sorted_var = sorted(var)
# [-7, -2, 1, 3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That is easy enough. But what would happen if you would like to sort the
values based on the distance to a given number? You need to apply a
function to each number, such as &lt;code&gt;abs(x-1)&lt;/code&gt; if you are computing the
distance to 1, and sort the values based on the output. Fortunately
&lt;code&gt;sorted&lt;/code&gt; allows you to do that using the keyword argument &lt;code&gt;key=&lt;/code&gt;. We
could do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def distance(x):
    return abs(x-1)

sorted_var = sorted(var, key=distance)
# [1, 3, -2, 4, 5, -7]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another option would be to use a lambda function:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;sorted_var = sorted(var, key=lambda x: abs(x-1))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both examples are going to produce the exact same output. There is no
functional difference between defining a function using &lt;code&gt;def&lt;/code&gt; or using
&lt;code&gt;lambda&lt;/code&gt;. I can argue that the second example is slightly shorter than
the first one. Also, it makes the code more readable, since you can
immediately see what are you doing to each element (&lt;code&gt;abs(x-1)&lt;/code&gt;) instead
of digging through your code to see where &lt;code&gt;distance&lt;/code&gt; was defined.&lt;/p&gt;
&lt;p&gt;Another possibility is to use it in combination with &lt;code&gt;map&lt;/code&gt;. Map is a way
of applying a function to every element on a list. For example, based on
the example above, we can do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;list(map(distance, var))
# [0, 4, 3, 2, 8, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or, using the lambda expressions:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;list(map(lambda x: abs(x-1), var))
# [0, 4, 3, 2, 8, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which gives the exact same output and, again, one can argue which one is
easier to read. The examples above are what you may see in other
tutorials. Probably is what you will see if you go through
StackOverflow. One of the possibilities is to use lambda functions in
combination with Pandas.&lt;/p&gt;
&lt;h2&gt;Pandas and Lambda Functions&lt;/h2&gt;
&lt;p&gt;The example data was inspired by
&lt;a href="https://data36.com/pandas-tutorial-1-basics-reading-data-files-dataframes-data-selection/"&gt;this&lt;/a&gt;
example and can be found
&lt;a href="https://github.com/PFTL/website/blob/master/example_code/30_lambdas/example_data.csv"&gt;here&lt;/a&gt;.
Create a file &lt;strong&gt;example_data.csv&lt;/strong&gt; with the following content:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csv"&gt;animal,uniq_id,water_need
elephant,1001,500
elephant,1002,600
elephant,1003,550
tiger,1004,300
tiger,1005,320
tiger,1006,330
tiger,1007,290
tiger,1008,310
zebra,1009,200
zebra,1010,220
zebra,1011,240
zebra,1012,230
zebra,1013,220
zebra,1014,100
zebra,1015,80
lion,1016,420
lion,1017,600
lion,1018,500
lion,1019,390
kangaroo,1020,410
kangaroo,1021,430
kangaroo,1022,410
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To read the data as a DataFrame, we can simply do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import pandas as pd

df = pd.read_csv('example_data.csv', delimiter = ',')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Imagine you would like to capitalize the first letter of each animal's
name on the data frame, you can do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;df['animal'] = df['animal'].apply(lambda x: x.capitalize())
print(df.head())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And you will see the results. Of course, lambda functions can become
much more complex. You can apply them to an entire series instead of
single values, you can combine them with other libraries such as numpy
or scipy and perform complex transformations to your data.&lt;/p&gt;
&lt;p&gt;One of the biggest advantages of lambda functions is that if you are
using Jupyter notebooks, you can see the changes right away. You don't
need to open another file, run a different, cell, etc. If you go to the
&lt;a href="https://pandas.pydata.org/pandas-docs/version/0.22/generated/pandas.DataFrame.apply.html"&gt;Pandas
documentation&lt;/a&gt;
you will see that lambdas are used quite often.&lt;/p&gt;
&lt;h2&gt;Qt Slots&lt;/h2&gt;
&lt;p&gt;Another common example of using lambdas is in combination with the Qt
library. We have written an &lt;a href="https://www.pythonforthelab.com/blog/step-by-step-guide-to-building-a-gui"&gt;introductory article on
Qt&lt;/a&gt; in the past. Feel free to
browse through it if you are not familiar with how building user
interfaces work. A very minimal example, that just shows a button, it
looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from PyQt5.QtWidgets import QApplication, QPushButton

app = QApplication([])

button = QPushButton('Press Me')
button.show()

app.exit(app.exec())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you would like to trigger an action when pressing the button, that
action has to be defined as a function. If we want to print something to
screen when the button gets pressed, we can simply add the following
line right before &lt;code&gt;app.exit&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;button.clicked.connect(lambda x: print('Pressed!'))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the program again, every time you press the button you will
see the &lt;code&gt;Pressed!&lt;/code&gt; appearing on the screen. Again, using lambda
functions as slots for signals can speed up your coding and make your
programs easier to read. However, lambda functions also need to be
considered with caution.&lt;/p&gt;
&lt;h2&gt;Where to use lambda functions&lt;/h2&gt;
&lt;p&gt;Lambda functions can only have 1 line. This forces developers to use
them only in contexts where the behavior can be achieved without a
complex syntax. In the examples above, you can see that the lambda
functions are very simple. If it would have required to open a socket,
exchange some information, process the received data, etc. probably it
wouldn't have been possible to do it on a single line.&lt;/p&gt;
&lt;p&gt;The natural scenario where lambda functions can be used is as arguments
for other functions that require callables as arguments. For example,
the &lt;code&gt;apply&lt;/code&gt; of a Pandas Data Frame requires a function as an argument.
Connecting signals in Qt also requires a function. If the function that
we are going to apply or execute is simple, and we are not going to
re-use it, writing it as an anonymous function may be a very convenient
way.&lt;/p&gt;
&lt;h2&gt;Where not to use lambda functions&lt;/h2&gt;
&lt;p&gt;Lambda functions are anonymous, therefore, if you are assigning a name
to them, such as when we did:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;average = lambda x, y: (x+y)/2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It means there is something you are doing wrong. If you need to assign a
name to the function, so you can use it in different places of your
program, use the standard &lt;code&gt;def&lt;/code&gt; syntax. There is a lengthy discussion on
the abuse of lambda functions in Python &lt;a href="https://treyhunner.com/2018/09/stop-writing-lambda-expressions/"&gt;on this
blog&lt;/a&gt;.
The one that I have seen quite often, especially by people who have just
learned about lambdas, is this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;sorted_var = sorted(var, key=lambda x: abs(x))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This innocent example may be hard to wrap around if it's the first time
that you see lambda functions. But what you have is that you are
wrapping a function (&lt;code&gt;abs&lt;/code&gt;) within another function. It would be like
doing:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def func(x):
    return abs(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What is the advantage compared to just doing &lt;code&gt;abs(x)&lt;/code&gt;? Indeed, no
advantage, this means that we can also sort a list like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;sorted_var = sorted(var, key=abs)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you pay attention to the example that we've developed earlier, we
used &lt;code&gt;abs(x-1)&lt;/code&gt; exactly to avoid this redundancy.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;Lambda (or anonymous) functions are a tool that is slowly getting more
popular in Python programs. That is why it is very important that you
can understand what it means. You have to remember that there is nothing
that the lambda syntax allows you to do that it wouldn't be possible to
do without them. It is more a matter of convenience, syntax economy, and
perhaps readability.&lt;/p&gt;
&lt;p&gt;In other programming languages, such as JavaScript, anonymous functions
are used very often and have a much richer syntax than in Python. I
don't believe Python will head the same way, but in any case, they are a
tool that can help you not only with your current programs but they can
also help you understand what is going on if you ever tinker with other
languages.&lt;/p&gt;
&lt;p&gt;Header Photo by &lt;a href="https://unsplash.com/photos/YkYcdn4EbDs?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText"&gt;Ivana
Cajina&lt;/a&gt;
on Unsplash&lt;/p&gt;</content><category term="blog"></category><category term="functions"></category><category term="methods"></category><category term="arguments"></category><category term="packing"></category><category term="unpacking"></category><category term="args"></category><category term="kwargs"></category></entry><entry><title>What are args and kwargs and when to use them</title><link href="https://www.pythonforthelab.com/blog/what-are-args-and-kwargs-and-when-to-use-them" rel="alternate"></link><published>2019-03-10T00:00:00+01:00</published><updated>2019-03-10T00:00:00+01:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2019-03-10:/blog/what-are-args-and-kwargs-and-when-to-use-them</id><summary type="html">&lt;p&gt;If you have worked with Python for long enough, probably you have
encountered code that uses &lt;code&gt;*args&lt;/code&gt; and &lt;code&gt;**kwargs&lt;/code&gt; as arguments in
functions. Even if you haven't, it is a very neat feature that allows
you to achieve great flexibility while developing code. In this article,
we are going to …&lt;/p&gt;</summary><content type="html">&lt;p&gt;If you have worked with Python for long enough, probably you have
encountered code that uses &lt;code&gt;*args&lt;/code&gt; and &lt;code&gt;**kwargs&lt;/code&gt; as arguments in
functions. Even if you haven't, it is a very neat feature that allows
you to achieve great flexibility while developing code. In this article,
we are going to discuss what and how to use flexible arguments in
functions.&lt;/p&gt;
&lt;h2&gt;Args&lt;/h2&gt;
&lt;p&gt;Let's quickly see how &lt;code&gt;*args&lt;/code&gt; work in a function:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def test_function(*args):
    print(type(args))
    for arg in args:
        print(arg)

test_function('a', 'b', 1, 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which will output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;lt;class 'tuple'&amp;gt;
a
b
1
2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What you are seeing is that &lt;code&gt;test_function&lt;/code&gt; can take any number of
arguments. When you use the &lt;code&gt;*&lt;/code&gt; in front of a variable, it will convert
any number of inputs into a tuple. You can access each argument
according to its index. For example, you could get the first value by
doing &lt;code&gt;args[0]&lt;/code&gt;, etc. Remember that when you develop functions, it is
the order of the inputs that matter.&lt;/p&gt;
&lt;p&gt;It is also possible to mix explicit arguments with &lt;code&gt;*args&lt;/code&gt;, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def test_function(first, second, *args):
    print(first)
    print(second)
    for arg in args:
        print(arg)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The main difference here is that &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt; are mandatory.
This two options would work fine:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;test_function('first', 2, 'a', 'b', 'c')
test_function('first', 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;while this one would throw an exception:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;test_function('first')
[...]
TypeError: test_function() missing 1 required positional argument: 'second'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So far, it is clear that you can use &lt;code&gt;*args&lt;/code&gt; to accept a variable number
of arguments in a function. But the other path is also possible. Imagine
you have a tuple and you would like to use it as arguments for a
function. For example, let's assume we have a function like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def fixed_args(first, second):
    print(first)
    print(second)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can use the function like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;vars = ('First', 'Second')
fixed_args(*vars)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which is very convenient in a lot of different situations, especially
when you may have so many inputs that it wouldn't be practical to try to
do something like:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;fixed_args(vars[0], vars[1])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is important to note here that Python doesn't force you to use
&lt;code&gt;*args&lt;/code&gt; in its syntax as an argument for a function. You are free to
choose whatever variable name you would like. However, &lt;code&gt;*args&lt;/code&gt; is a
convention that almost every developer follows. Using it will make your
code much more readable and understandable by others and your future
self.&lt;/p&gt;
&lt;p&gt;The action of transforming a tuple (or a list) to different inputs of a
function is called unpacking. But we are not limited to tuples and
lists. We can go one step further and use a generator, such as &lt;code&gt;range&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def test_function(first, second):
    print(first)
    print(second)

a = range(1, 3)
test_function(*a)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Working with generators is a different topic, that I will cover in
another tutorial, but for the time being, it is important to note that
the &lt;code&gt;*&lt;/code&gt; can have a great impact when used in combination with the
arguments of functions.&lt;/p&gt;
&lt;h2&gt;Kwargs&lt;/h2&gt;
&lt;p&gt;The idea of &lt;code&gt;kwargs&lt;/code&gt; is very similar to that of &lt;code&gt;args&lt;/code&gt;, but instead of a
tuple or a list, these are keyword-arguments. This means that instead of
the order in which they appear, the importance is in the label that each
variable has. A quick example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def test_kwargs(**kwargs):
    for key, value in kwargs.items():
        print(key, '=&amp;gt;', value)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case, &lt;code&gt;test_kwargs&lt;/code&gt; takes a variable number of
keyword-variables. To use it, we can do something like the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;test_kwargs(first=1, second=2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which outputs:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;first =&amp;gt; 1
second =&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you try to run the function without keywords, it will through an
exception. In the same way that when &lt;code&gt;*args&lt;/code&gt; was used as the argument of
a function, the inputs were transformed to a tuple, &lt;code&gt;**kwargs&lt;/code&gt; are
transformed to a dictionary. Here, the important detail is the use of
the &lt;code&gt;**&lt;/code&gt; instead of the single &lt;code&gt;*&lt;/code&gt;. Of course, you can mix required and
variable inputs, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def test_function(first, **kwargs):
    print(first)
    print('Number kwargs: ', len(kwargs))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which will give you the following outputs:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; test_function(1)
1
Number kwargs:  0
&amp;gt;&amp;gt;&amp;gt;test_function(1, second=2, third=3)
1
Number kwargs:  2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the same way, as we used &lt;code&gt;*args&lt;/code&gt; to unpack a tuple, we can unpack a
dictionary. Let's first consider a function with some required
arguments:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def test_unpack(first, second, third):
    print(first)
    print(second)
    print(third)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And for unpacking a dictionary, we can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;vars = {'second': 2,
    'first': 1,
    'third': 3}

test_unpack(**vars)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which will give as output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;1
2
3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pay attention to the fact that we are not defining the variables in any
special order, but the importance is in the keywords used for building
the dictionary. We could have also done:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;vars = (2, 1, 3)
test_unpack(*vars)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which would produce the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;2
1
3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you have a broad idea of how the &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;**&lt;/code&gt; operators work to pack
and unpack arguments in functions. What you have to remember is that the
&lt;code&gt;*&lt;/code&gt; can be used to transform a tuple or list to the arguments of a
function in a specific order. On the other hand, the &lt;code&gt;**&lt;/code&gt; can be used to
transform a dictionary to keyword arguments of functions, in which the
order is not important but the label is.&lt;/p&gt;
&lt;p&gt;On the other hand, functions that accept arguments with either &lt;code&gt;*&lt;/code&gt; or
&lt;code&gt;**&lt;/code&gt; can have a variable number of arguments. The first works for
arguments in a certain order, while the latter works for
keyword-arguments. After reading the above sections, you can be tempted
to start using &lt;code&gt;args&lt;/code&gt; and &lt;code&gt;kwargs&lt;/code&gt; in your functions. However, you have
to be aware of the implications.&lt;/p&gt;
&lt;h2&gt;When not to use args and kwargs&lt;/h2&gt;
&lt;p&gt;When you expand your programming toolbox, there is a common desire to
use what you have just learned at every possibility that you encounter.
However, you have to be aware of the consequences and advantages of
using &lt;code&gt;args&lt;/code&gt; and &lt;code&gt;kwargs&lt;/code&gt; in your code. Let's consider, for example, a
function that calculates the area of a triangle. We could define it like
this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def area(base, height):
    return base*height/2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you look at the code above, you can easily understand what is going
on. If you want to use what you have just learned, we can re-write the
code to:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def area(*args):
    return args[0]*args[1]/2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both examples can be used in the same way, but I hope you do agree that
the latter is harder to understand. Moreover, the function can be called
with any number of arguments. If you are using a Python IDE such as
Pycharm, VS Code, they show you what arguments a function takes, but if
you have &lt;code&gt;*args&lt;/code&gt; you will have no idea what needs to be supplied.&lt;/p&gt;
&lt;h2&gt;When to use args and kwargs&lt;/h2&gt;
&lt;p&gt;Imagine someone else is using your code. The functions developed earlier
have only two lines and you can quickly read through them. But if you
have developed a much more complex function, how would someone reading
your code understand how many arguments and which ones to supply? The
same objections apply when you use &lt;code&gt;kwargs&lt;/code&gt;. Good code is also code that
can be read and quickly understood.&lt;/p&gt;
&lt;h3&gt;Decorators&lt;/h3&gt;
&lt;p&gt;Keeping in mind that it is impossible to make a comprehensive list of
situations when it is worth using kwargs and args, we can discuss some
examples. The first that comes to mind is when you are dealing with
&lt;a href="https://www.pythonforthelab.com/blog/how-to-use-decorators-part-2"&gt;decorators&lt;/a&gt;. To give a
very short summary, a decorator is a function that wraps another one in
order to extend its functionality without changing the core behavior.
Going back to the example of the area, the function&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def area(base, height):
    return base*height/2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Works for any pair of numbers, also negative ones. Imagine that we would
like to check whether the arguments of the function are non-negative,
but we don't want to change the function itself, we can develop a
decorator:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from functools import wraps

def check_positive(func):
    @wraps(func)
    def func_wrapper(*args):
        for arg in args:
            if type(arg) is int or type(arg) is float:
                if arg &amp;lt; 0:
                    raise Exception(&amp;quot;Function {} takes only positive arguments&amp;quot;.format(func.__name__))
            else:
                raise Exception(&amp;quot;Arguments of {} must be numbers&amp;quot;.format(func.__name__))
        return func(*args)

    return func_wrapper
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you are not familiar with decorators or the code above seems
confusing, I recommend you check &lt;a href="https://www.pythonforthelab.com/blog/how-to-use-decorators-part-2"&gt;this
article&lt;/a&gt;. To use this
decorator, we would simply do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;@check_positive
def area_positive(base, height):
    return base*height/2

print(area_positive(1, 2))
print(area_positive(-1, 2))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now you will see that an exception will be thrown with the second
line using a negative value for the base. If you pay attention, notice
that we have used &lt;code&gt;*args&lt;/code&gt; in the decorator. This allows us to use the
same decorator for any function, not only the area. Imagine we would
like to calculate the perimeter of a triangle, we could simply do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;@check_positive
def perimeter(side1, side2, side3):
    return side1+side2+side3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;*args&lt;/code&gt; (or &lt;code&gt;**kwargs&lt;/code&gt;) are incredibly useful to have a flexible
decorator. If you go to the article linked earlier, you will see that
the first couple of examples always use a fixed number of arguments,
thus making the decorator applicable only to certain cases.&lt;/p&gt;
&lt;h2&gt;Inheritance&lt;/h2&gt;
&lt;p&gt;Another very common scenario where &lt;code&gt;args&lt;/code&gt; and &lt;code&gt;kwargs&lt;/code&gt; is very handy is
when you are working with classes. In order to expand the functionality
of classes developed by others, a common pattern is to inherit them and
override the methods you would like to change. This is very frequent
when you are dealing with large libraries or frameworks. For example, if
you are developing a &lt;a href="https://www.pythonforthelab.com/blog/step-by-step-guide-to-building-a-gui"&gt;Qt
application&lt;/a&gt;, you will find
yourself with code like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MainWindow(QMainWindow):
    def __init__(self, *args):
        super(MainWindow, self).__init__(*args)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The rest of the code will do the specific parts of your application. The
snippet above shows that we don't need to look at the original code to
see what arguments are passed, etc. They are simply relayed to the
original &lt;code&gt;QMainWindow&lt;/code&gt; class when instantiating. Moreover, if there is
code downstream that is already using &lt;code&gt;QMainWindow&lt;/code&gt;, we can use
&lt;code&gt;MainWindow&lt;/code&gt; as a drop-in replacement, without the need to explicitly
change every time the class is used.&lt;/p&gt;
&lt;p&gt;If you are familiar with frameworks such as &lt;strong&gt;Django&lt;/strong&gt; and you are
overriding a method such as &lt;code&gt;save&lt;/code&gt; (you can see &lt;a href="https://docs.djangoproject.com/en/2.1/ref/models/instances/#django.db.models.Model.save"&gt;the docs
here&lt;/a&gt;),
you can use the following syntax on your own model:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def save(self, **kwargs):
    # Your custom code goes here
    super().save(**kwargs)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this way, your code is future proof. Perhaps today you are not using
some of the arguments that &lt;code&gt;save&lt;/code&gt; takes, but by taking a flexible number
of them, you know that if tomorrow you decide to start using some, your
program will not break. Pay attention to the fact that we used only
&lt;code&gt;**kwargs&lt;/code&gt;. This is a choice to force the use of keyword arguments,
mainly because it is a function with a lot of arguments, each with a
default value, and we may be interested in altering only one of them.&lt;/p&gt;
&lt;h2&gt;Flexibility&lt;/h2&gt;
&lt;p&gt;Sometimes flexibility in the number of arguments is needed. A classical
example is Python's &lt;code&gt;dict&lt;/code&gt;. When you create a dictionary, you can use
the following syntax:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;a = dict(one=1, two=2, three=3)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, the arguments of &lt;code&gt;dict&lt;/code&gt; are not fixed. You could have as well
used:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;b = dict(first=1, second=2, third=3)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The fact that dict can take any keyword argument set is an asset. If you
look at &lt;a href="https://docs.python.org/3.7/library/stdtypes.html#dict"&gt;the
documentation&lt;/a&gt;,
it explicitly shows you that dict can be called with &lt;code&gt;dict(**kwarg)&lt;/code&gt;. If
you look at &lt;a href="https://docs.djangoproject.com/en/2.1/_modules/django/db/models/base/#Model"&gt;Django's
Model&lt;/a&gt;,
you will also see that the &lt;code&gt;__init__&lt;/code&gt; method takes &lt;code&gt;args&lt;/code&gt; and &lt;code&gt;kwargs&lt;/code&gt;.
This is because the framework wanted to have a great degree of
flexibility while instantiating a class. If you look at the code, you
will see that there are a lot of checks and loops in order to prepare
the object based on the available arguments.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;Having a variable number of arguments in functions and methods can help
you develop a much more flexible code. However, this normally comes at a
cost in readability. Understanding where it can be useful to use &lt;code&gt;*args&lt;/code&gt;
or &lt;code&gt;*kwargs&lt;/code&gt; in your functions requires practice and, more importantly,
reading other's code. You may find great examples if you just look
around the libraries you are already using and you wonder how is it
possible that sometimes you use a different number of arguments.&lt;/p&gt;
&lt;p&gt;The opposite path, of using the &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;**&lt;/code&gt; syntax to pass a tuple or a
dictionary as arguments to a function can greatly simplify your code. A
very simple example would be what happens when you import data using
&lt;code&gt;pyyaml&lt;/code&gt;, for example. You end up with a dictionary, that perhaps you
would like to directly pass to a function. Unpacking arguments is very
useful, especially when you are not in control of the functions that you
are using.&lt;/p&gt;
&lt;p&gt;The source version of this article is available &lt;a href="https://github.com/PFTL/website/blob/master/content/blog/29_args_kwargs.rst.md"&gt;on
Github&lt;/a&gt;.
The code examples are &lt;a href="https://github.com/PFTL/website/tree/master/example_code/29_args_kwargs"&gt;available
here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Header photo by &lt;a href="https://unsplash.com/photos/XJXWbfSo2f0?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText"&gt;Luca
Bravo&lt;/a&gt;
on Unsplash&lt;/p&gt;</content><category term="blog"></category><category term="functions"></category><category term="methods"></category><category term="arguments"></category><category term="packing"></category><category term="unpacking"></category><category term="args"></category><category term="kwargs"></category></entry><entry><title>Using pyZMQ for inter-process communication: Part 2</title><link href="https://www.pythonforthelab.com/blog/using-pyzmq-for-inter-process-communication-part-2" rel="alternate"></link><published>2019-03-05T00:00:00+01:00</published><updated>2019-03-05T00:00:00+01:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2019-03-05:/blog/using-pyzmq-for-inter-process-communication-part-2</id><summary type="html">&lt;p&gt;In this article, we are going to cover how you can leverage the
possibilities of ZMQ to exchange data between different processes in
Python. We have covered the &lt;a href="https://www.pythonforthelab.com/blog/using-pyzmq-for-inter-process-communication-part-1"&gt;basics of pyZMQ&lt;/a&gt;
in part 1. This is a fairly advanced tutorial, in which we are not only
going to use pyZMQ …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In this article, we are going to cover how you can leverage the
possibilities of ZMQ to exchange data between different processes in
Python. We have covered the &lt;a href="https://www.pythonforthelab.com/blog/using-pyzmq-for-inter-process-communication-part-1"&gt;basics of pyZMQ&lt;/a&gt;
in part 1. This is a fairly advanced tutorial, in which we are not only
going to use pyZMQ, but also the multiprocessing library,
&lt;a href="{filename}02_HDF5_python.rst.md"&gt;HDF5&lt;/a&gt;, and
&lt;a href="https://www.pythonforthelab.com/blog/step-by-step-guide-to-building-a-gui"&gt;openCV&lt;/a&gt;. We are going to acquire
images from the webcam as fast as possible, we are going to save the
data to disk during the acquisition, and we are going to perform some
basic analysis.&lt;/p&gt;
&lt;p&gt;The idea of this article is to put together several of the topics
covered in the past. If you find that some of the contents are
confusing, I strongly suggest you check the other articles to clarify
the topics. We are going to develop one main Python script with some
extra files that will allow us to keep everything organized. To specify
file names, I will use &lt;strong&gt;bold&lt;/strong&gt;. The code, as always, &lt;a href="https://github.com/PFTL/website/tree/master/example_code/26_ZMQ"&gt;can be found on
Github&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Architecture&lt;/h2&gt;
&lt;p&gt;What we want to achieve is a program that acquires images from a camera
and at the same time it saves them to the hard drive and is able to
perform basic analysis on the frames. We want everything to happen
simultaneously, even if the frames are being acquired faster than what
we can save to the disk. We would also like to have the flexibility of
turning on and off the saving or the analysis without having to change a
lot the code base.&lt;/p&gt;
&lt;p&gt;Since we are going to run everything as a single-script (with some
package imports), the best idea is to use the &lt;a href="https://www.pythonforthelab.com/blog/using-pyzmq-for-inter-process-communication-part-1/#id9"&gt;publisher/subscriber
pattern&lt;/a&gt;.
We will have a central publisher which will be able to broadcast every
frame that is acquired, and subscribers which will get the frames and
perform special operations on them.&lt;/p&gt;
&lt;h2&gt;Camera Control&lt;/h2&gt;
&lt;p&gt;We are going to use almost &lt;a href="https://www.pythonforthelab.com/blog/step-by-step-guide-to-building-a-gui/"&gt;the same
code&lt;/a&gt;
that we developed when we saw how to build a user interface for a camera
with PyQt5. We will wrap OpenCV in a custom class that will allow us to
quickly acquire movies, frames, etc. Therefore, in a file called
&lt;strong&gt;camera.py&lt;/strong&gt;, let's put the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import cv2


class Camera:
    def __init__(self, cam_num):
        self.cam_num = cam_num
        self.cap = None
        self.frame_shape = []

    def initialize(self):
        self.cap = cv2.VideoCapture(self.cam_num)

    def get_frame(self):
        ret, frame = self.cap.read()
        return frame

    def acquire_movie(self, num_frames):
        movie = []
        for _ in range(num_frames):
            movie.append(self.get_frame())
        return movie

    def close_camera(self):
        self.cap.release()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a very simple class, that can be used like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;cam = Camera(0)
cam.initialize()
frame = cam.get_frame()
movie = cam.acquire_movie(20)
cam.close_camera()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code is simple enough to get started very quickly. But you can
already see that there are some drawbacks. The first is that when we
want to acquire a movie the code blocks. If we would like to do anything
else in the program, we won't be able. The fastest way to overcome this
limitation is to use &lt;a href="https://www.pythonforthelab.com/blog/implementing-threads-for-measurements/"&gt;threads or
processes&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Multi-Threading&lt;/h3&gt;
&lt;p&gt;Remember that the core idea of a thread is that it still runs on the
same core, and therefore it just gives time for other tasks to use the
same resources. If you have an operation that takes a lot of computing
power, different threads will not speed up the program. On the other
hand, different processes can be spawned across different cores, and
therefore you can use the full computing power of your PC. However,
there are other things that have to be taken into account when choosing
threads or processes.&lt;/p&gt;
&lt;p&gt;Threads are running inside the same process and their memory space is
shared. This is the approach we followed in the &lt;a href="https://www.pythonforthelab.com/blog/step-by-step-guide-to-building-a-gui/"&gt;PyQt
tutorial&lt;/a&gt;.
For example, we could change the &lt;code&gt;Camera&lt;/code&gt; class in order to run the
movie acquisition inside a thread while retaining control on when to
stop the acquisition:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def acquire_movie(self):
    movie = []
    self.stop_movie = False
    while not self.stop_movie:
        movie.append(self.get_frame())
    return movie
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we would use it like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from time import sleep
from threading import Thread

cam = Camera(0)
cam.initialize()
movie_thread = Thread(target=cam.acquire_movie)
movie_thread.start()
sleep(10)
cam.stop_movie = True
cam.close_camera()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We created a new thread called &lt;code&gt;movie_thread&lt;/code&gt; in which the loop for
acquiring a movie will run. After starting it, we wait 10 seconds and we
change the attribute &lt;code&gt;stop_movie&lt;/code&gt; in order to stop the loop. You can see
that from one thread we are able to change the value of an attribute
which is being used in another thread. This approach is very
straightforward, and also allows us to get the data out, instead of
simply using &lt;code&gt;movie&lt;/code&gt;, we can use &lt;code&gt;self.movie&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def acquire_movie(self):
    self.movie = []
    self.stop_movie = False
    while not self.stop_movie:
        self.movie.append(self.get_frame())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pay attention to the fact that we are not returning any value since we
don't need that anymore. The data is available as an attribute of the
class itself. After acquiring 10 seconds, we have access to the frames
by simply doing the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;print(cam.movie)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This also opens the door to monitor the progress, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from time import sleep, time
from threading import Thread

cam = Camera(0)
cam.initialize()
movie_thread = Thread(target=cam.acquire_movie)
movie_thread.start()
t0 = time()
while time()-t0&amp;lt;10:
    print(f'Total frames: {len(cam.movie)}')
    sleep(0.5)
cam.stop_movie = True
cam.close_camera()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So now you can see that while the movie is being acquired, you can
monitor how many frames are available. This looks already very good, is
you can forgive the &lt;code&gt;append&lt;/code&gt; which is a bottleneck for this kind of
applications.&lt;/p&gt;
&lt;h3&gt;Multi-Processing&lt;/h3&gt;
&lt;p&gt;Threads work, but what about Processes? The syntax is extremely similar:
we should just replace &lt;code&gt;Thread&lt;/code&gt; for &lt;code&gt;Process&lt;/code&gt;. However, we would face
several issues if we try to do this. Because the memory is not shared
between different processes, we will not be able to stop the acquisition
by changing an attribute to a class. We will see later that this is not
an issue because there are proper multiprocessing tools to achieve this
behavior. On the other hand, we wouldn't be able to monitor the number
of frames acquired because &lt;code&gt;cam.movie&lt;/code&gt; wouldn't be accessible from the
main process. But we could still find ways around this.&lt;/p&gt;
&lt;p&gt;Unfortunately, that is not all. The biggest drawback of
&lt;code&gt;multiprocessing&lt;/code&gt; is that the way Windows and Linux start new processes
is very different. In Linux, when you do
&lt;code&gt;Process(target=cam.acquire_movie)&lt;/code&gt;, the process is going to receive a
copy of the &lt;code&gt;cam&lt;/code&gt; object, including the attributes that you generated
when instantiating, etc. On the other hand, on Windows, the process will
receive a fresh python interpreter, and therefore the &lt;code&gt;cam&lt;/code&gt; class would
not be instantiated.&lt;/p&gt;
&lt;p&gt;If you are &lt;strong&gt;on Linux&lt;/strong&gt;, the following works:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from time import sleep, time
from multiprocessing import Process

cam = Camera(0)
cam.initialize()
movie_process = Process(target=cam.acquire_movie)
movie_process.start()
t0 = time()
while time()-t0&amp;lt;10:
    # print(f'Total frames: {len(cam.movie)}')
    sleep(0.5)
movie_process.terminate()
cam.close_camera()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The acquisition will be running on a different thread, which we force to
finish after 10 seconds. If you are on Windows, however, you will get a
very cryptic exception that looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;Traceback (most recent call last):
  File &amp;quot;/home/aquiles/Documents/Web/PythonForTheLab/pftl/example_code/26_ZMQ/camera.py&amp;quot;, line 50, in &amp;lt;module&amp;gt;
    movie_process.start()
  File &amp;quot;/usr/lib64/python3.6/multiprocessing/process.py&amp;quot;, line 105, in start
    self._popen = self._Popen(self)
  File &amp;quot;/usr/lib64/python3.6/multiprocessing/context.py&amp;quot;, line 223, in _Popen
    return _default_context.get_context().Process._Popen(process_obj)
  File &amp;quot;/usr/lib64/python3.6/multiprocessing/context.py&amp;quot;, line 284, in _Popen
    return Popen(process_obj)
  File &amp;quot;/usr/lib64/python3.6/multiprocessing/popen_spawn_posix.py&amp;quot;, line 32, in __init__
    super().__init__(process_obj)
  File &amp;quot;/usr/lib64/python3.6/multiprocessing/popen_fork.py&amp;quot;, line 19, in __init__
    self._launch(process_obj)
  File &amp;quot;/usr/lib64/python3.6/multiprocessing/popen_spawn_posix.py&amp;quot;, line 47, in _launch
    reduction.dump(process_obj, fp)
  File &amp;quot;/usr/lib64/python3.6/multiprocessing/reduction.py&amp;quot;, line 60, in dump
    ForkingPickler(file, protocol).dump(obj)
TypeError: can't pickle cv2.VideoCapture objects
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It took me an extremely long time to debug a program that I had
developed on Linux and that was crashing on Windows because of no
apparent reason. The &lt;a href="https://docs.python.org/3/library/multiprocessing.html"&gt;Python
documentation&lt;/a&gt;
has some insights, but understanding what is actually written and its
consequences are not trivial.&lt;/p&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;If you plan to use the multiprocessing library with programs that should
run both on Windows and on Linux you have to be aware of the differences
and learn how to structure your code.&lt;/p&gt;
&lt;p&gt;This doesn't mean that we will not be able to run multi-processing
programs on Windows, it just means that we have to structure our code
carefully in order to make it cross-platform. For this particular
application, we will keep the camera acquisition in the main processes,
using threads, and thus it will be compatible with Windows out of the
box. We will use the multiprocessing library for the next section.&lt;/p&gt;
&lt;h2&gt;Publisher&lt;/h2&gt;
&lt;p&gt;Now we know how to acquire a movie, but we still need to do something
with the data other than simply accumulating it on a variable until the
movie is over. Since we want to attach different tasks to the frames, we
will use the &lt;a href="https://www.pythonforthelab.com/blog/using-pyzmq-for-inter-process-communication-part-1/#publisher-subscriber"&gt;Publisher/Subscriber
pattern&lt;/a&gt;
available through &lt;strong&gt;pyZMQ&lt;/strong&gt;. We will start by developing the publisher
which will broadcast every frame.&lt;/p&gt;
&lt;p&gt;Here, some decisions have to be made. One is how we plan to make the
information available to the publisher. An approach that works very
nicely in multi-processing applications is to have a queue object. The
publisher will consume this queue and will broadcast the information.
For our application, this means that the camera class will append each
frame to a specific queue, and the publisher will use it. Let's start by
creating a new file called &lt;strong&gt;publisher.py&lt;/strong&gt; with the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt; import zmq
 from time import sleep}
def publisher(queue, event, port):
    port_pub = port
    context = zmq.Context()
    with context.socket(zmq.PUB) as socket:
        socket.bind(&amp;quot;tcp://*:%s&amp;quot; % port_pub)
        while not event.is_set():
            while not queue.empty():
                data = queue.get()  # Should be a dictionary {'topic': topic, 'data': data}
                socket.send_string(data['topic'], zmq.SNDMORE)
                socket.send_pyobj(data['data'])
        sleep(0.005)  # Sleeps 5 milliseconds to be polite with the CPU
        socket.send_string('stop')
        sleep(1)  # Gives enough time to the subscribers to update their status
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pay attention to the fact that we have chosen to develop a function
instead of a class. This is the choice you have to make in order to make
your code compatible with Windows. Since functions do not store state,
it doesn't matter the method for starting processes employed, it only
matters which arguments are used.&lt;/p&gt;
&lt;p&gt;The main block of code is two nested &lt;code&gt;while&lt;/code&gt; loops. You can see that
innermost one iterates over every element in the queue. It assumes that
they will all be dictionaries including a &lt;code&gt;topic&lt;/code&gt; and some kind of
&lt;code&gt;data&lt;/code&gt;. Remember that when you use the PUB/SUB pattern, you can specify
which topics are consumed by which subscribers.&lt;/p&gt;
&lt;p&gt;The outer &lt;code&gt;while&lt;/code&gt; loop uses the &lt;code&gt;event&lt;/code&gt;, which is a multiprocessing
&lt;code&gt;Event&lt;/code&gt; object. In the camera example above we used an attribute to stop
a loop. However, if we want to use a separate Process, we can't follow
the same approach. An
&lt;a href="https://docs.python.org/3.6/library/threading.html#threading.Event"&gt;Event&lt;/a&gt;
is an object that handles a flag: it is either set to true or not. It is
very useful for synchronizing different processes, or as in this case,
to stop the execution of a loop. The event can be shared safely between
threads and processes, and therefore can be set or cleared anywhere in
our program.&lt;/p&gt;
&lt;p&gt;Now we will need to change the &lt;code&gt;Camera&lt;/code&gt; class in order to put the movie
frames to a queue. The fastest way of achieving this would be to modify
the &lt;code&gt;acquire_movie&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def acquire_movie(self, queue):
    self.stop_movie = False
    while not self.stop_movie:
        queue.put({'topic': 'frame', 'data':self.get_frame()})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can now run the code like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from multiprocessing import Queue, Process, Event
from time import sleep, time

from camera import Camera
from publisher import publisher

from threading import Thread

cam = Camera(0)
cam.initialize()

pub_queue = Queue()
stop_event = Event()
publisher_process = Process(target=publisher, args=(pub_queue, stop_event, 5555))
publisher_process.start()
camera_thread = Thread(target=cam.acquire_movie, args=(pub_queue,))
camera_thread.start()
t0 = time()
while time()-t0&amp;lt;5:
    print('Still acquiring')
    sleep(1)
cam.stop_movie = True
stop_event.set()
publisher_process.join()
print('Bye')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code, I believe, is self-explanatory if you look at it carefully. We
initialize the camera, create the queue where the frames are going to be
located, create a process for the publisher to run on its own and we
start it. The arguments that the publisher takes, are the queue from
which to fetch frames, the stop event, and the port. We also start the
camera movie acquisition on a separated thread and give as an argument
the same queue that the publisher uses. This allows us to share
information between different processes.&lt;/p&gt;
&lt;p&gt;Remember that when you have a queue, every time you do &lt;code&gt;queue.get()&lt;/code&gt;,
the element you are fetching is being destroyed from the queue. This
means that if you want to share the same information between more
threads or processes, you would either make more queues or find a better
solution, as we will do later.&lt;/p&gt;
&lt;p&gt;In the program above, note that we stop the camera with
&lt;code&gt;cam.stop_movie = True&lt;/code&gt;, but we need to use &lt;code&gt;stop_event.set()&lt;/code&gt; to do the
same with the publisher. This is a manifestation of the difference
between threads and processes and their possibility to share memory. The
statement &lt;code&gt;publisher_process.join()&lt;/code&gt; will wait there until the process
finishes. This is a good way of being sure that we gave enough time to
the publisher to finish with what it was doing before our program stops.&lt;/p&gt;
&lt;p&gt;When you work with multiprocessing (or multi-threading) you have to be
careful with how you end things. If your program crashes, it may happen
that you generated orphan processes that keep running in the background
even if your main program exited. You can find these processes by
inspecting the tasks running on your computer. If this ever happens,
close them by hand, because they will keep occupying the same resources
such as the socket port or the file that we will use for saving data.&lt;/p&gt;
&lt;p&gt;So far we are not doing anything, the publisher is broadcasting data,
but there is no one to do anything with it. It is time to add our first
subscriber.&lt;/p&gt;
&lt;h2&gt;Analyse Data: Subscriber 1&lt;/h2&gt;
&lt;p&gt;Imagine that you want to analyze the frames while you are acquiring a
movie. We are going to do a very silly analysis of computing the
maximum, minimum, and average value of the pixels present. Since we
already have the publisher, we can create a subscriber to consume the
data being broadcast. Since analyzing data can be computationally
expensive, it is important to be able to run such tasks in different
processes, and therefore, we will need to make subscribers also
multi-processing compatible. In a new file called &lt;strong&gt;subscribers.py&lt;/strong&gt;, we
can put the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import numpy as np
import zmq

def analyze_frames(port, topic, event):
    context = zmq.Context()
    with context.socket(zmq.SUB) as socket:
        socket.connect(f&amp;quot;tcp://localhost:{port}&amp;quot;)
        topic_filter = topic.encode('utf-8')
        socket.setsockopt(zmq.SUBSCRIBE, topic_filter)
        socket.setsockopt(zmq.SUBSCRIBE, ''.encode('utf-8'))
        i = 0
        min = []
        max = []
        avg = []
        while True:
            topic = socket.recv_string()
            data = socket.recv_pyobj()  # flags=0, copy=True, track=False)
            if isinstance(data, str):
                break
            data = np.sum(data, 2)
            min.append(np.min(data))
            max.append(np.max(data))
            avg.append(np.mean(data))
            i+=1
    np.save('summary', np.array([min, max, avg]))
    print(f'Analysed {i} frames')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This code is also very simple to understand. It is similar to how the
publisher works, but instead of a queue, we determine which topic this
subscriber is going to be listening to. In this case we use a
&lt;code&gt;while True&lt;/code&gt; loop, because the &lt;code&gt;recv_string()&lt;/code&gt; and &lt;code&gt;recv_pyobk()&lt;/code&gt;
methods are blocking. This means that if the publisher is not sending
anything, even if we set the &lt;code&gt;Event&lt;/code&gt;, it will not be used by the
subscriber.&lt;/p&gt;
&lt;p&gt;We choose the option of the publisher broadcasting a string in order to
force the subscribers to finish. If you are developing larger programs,
you have to be very systematic in order to force all the processes to
gracefully finish and not forgetting any running in the background when
your program stops. The main loop is very clear, we just calculate the
three values and append them to a list. When the subscriber finishes, we
save the data to a file.&lt;/p&gt;
&lt;p&gt;Let's update our main script in order to use this subscriber:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from multiprocessing import Queue, Process, Event
from time import sleep, time

from camera import Camera
from publisher import publisher
from subscribers import analyze_frames
from threading import Thread

cam = Camera(0)
cam.initialize()

pub_queue = Queue()
stop_event = Event()
publisher_process = Process(target=publisher, args=(pub_queue, stop_event, 5555))
publisher_process.start()
analyzer_process = Process(target=analyze_frames, args=(5555, 'frame', stop_event))
analyzer_process.start()
sleep(2)
camera_thread = Thread(target=cam.acquire_movie, args=(pub_queue,))
camera_thread.start()
t0 = time()
while time()-t0&amp;lt;5:
    print('Still acquiring')
    sleep(1)
cam.stop_movie = True
pub_queue.put({'topic': 'frame', 'data': 'stop'})
camera_thread.join()
analyzer_process.join()
stop_event.set()
publisher_process.join()
print('Bye')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are a few things to pay attention here. One is that we have added
a &lt;code&gt;sleep(2)&lt;/code&gt; after starting the analyzer process. This is to give enough
time for the sockets to initialize before starting the measurement.
There could be better ways of doing this, but let's not waste time with
some premature optimization. Since we are working with 3 things
happening simultaneously, i.e. the camera acquisition, the publisher and
the analyzer, we have to be very careful about how we handle each step.&lt;/p&gt;
&lt;p&gt;After 5 seconds, the first thing we do is to stop the movie, as always,
with &lt;code&gt;stop_movie = True&lt;/code&gt;. Then we add to the queue of the publisher data
which is a string and will force the subscriber to finish when it gets
it. We wait for the camera thread to really finish, and then we wait for
the analyzer process to finish. Only after that, we stop the publisher.
The reason for this is that in the publisher loop you could escape the
loop before reading all the data from the queue.&lt;/p&gt;
&lt;p&gt;If you develop this kind of applications long enough, you will start
realizing how important it is to be systematic in your approach to
handle processes and threads and you will start developing your own
standards for finishing subscribers, etc.&lt;/p&gt;
&lt;p&gt;So far so good. You can see that there should be a new file created,
with information about the frames that you have acquired. Explore it to
see that everything is there as expected. You can block the camera while
you acquire a movie and see that the average drops, for example.&lt;/p&gt;
&lt;h2&gt;Save Data: Subscriber 2&lt;/h2&gt;
&lt;p&gt;What we have up to now could be easily achieved with a queue. The camera
acquires frames, puts it in a queue and the queue is consumed by another
process which analyses it. However, if we would like to add another
process which, for example, saves the data while it is being generated,
we would need to create another queue and refactor the camera class,
etc. Moreover, if we would like to sometimes analyze, sometimes save and
sometimes both (or none), we would need to add a lot of verifications to
our code, making it very hard to reuse.&lt;/p&gt;
&lt;p&gt;Now, since we have the publisher available, adding a second process to
save the data while we acquire it is very straightforward. We are going
to use &lt;a href="https://www.pythonforthelab.com/blog/how-to-use-hdf5-files-in-python/"&gt;HDF5
files&lt;/a&gt;
because they are very versatile for this kind of applications, but you
are free to adapt the code to whatever fits your needs. We can add the
following to the &lt;strong&gt;subscribers.py&lt;/strong&gt; file:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import h5py
from time import sleep

def save_movie(port, topic, frame_shape, dtype):
    f = h5py.File('movie.hdf5', 'w')
    dset = f.create_dataset(&amp;quot;default&amp;quot;, frame_shape+(1,), maxshape=frame_shape+(None,), dtype=dtype)
    context = zmq.Context()
    with context.socket(zmq.SUB) as socket:
        socket.connect(f&amp;quot;tcp://localhost:{port}&amp;quot;)
        topic_filter = topic.encode('utf-8')
        socket.setsockopt(zmq.SUBSCRIBE, topic_filter)
        socket.setsockopt(zmq.SUBSCRIBE, ''.encode('utf-8'))
        i = 0
        while True:
            topic = socket.recv_string()
            data = socket.recv_pyobj()  # flags=0, copy=True, track=False)
            if isinstance(data, str):
                break
            dset[:,:,:,i] = data
            i += 1
            dset.resize(frame_shape+(i+1,))
        sleep(1)  # Gives enough time for the publishers to finish sending data before closing the socket
    f.flush()
    print(f'Acquired {i} frames')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, we need to port and topic, as we will always do for a subscriber.
However, we are going to need to frame shape and type of data in order
to create the HDF5 dataset. Pay attention to two things: first, we are
creating the file with the &lt;code&gt;w&lt;/code&gt; option, meaning that we are going to
overwrite anything pre-existent. This is not a good approach for a real
application, but it is up to you to find what is best in your own case.
Second, we create a dataset with an extra dimension (because it is a
movie) and with the &lt;code&gt;maxshape&lt;/code&gt; option set to &lt;code&gt;None&lt;/code&gt; in the time
dimension. This will allow us to acquire movies for as long as we need.&lt;/p&gt;
&lt;p&gt;This is not the most efficient way of handling the task, we could
pre-allocate memory, save in chunks, compress the data, etc. But it
works fine. Since we are saving a movie, we will have 4-dimensional
data: 2 for space, 1 for color (R, G, B) and 1 for time. With h5py this
can be handled immediately, while other approaches such as what Pandas
does may be more convoluted.&lt;/p&gt;
&lt;p&gt;The rest of the function is more or less self-explanatory. To run the
program with this added subscriber, we should only add a new process.
For brevity, I will skip the majority of the code, but I hope you can
understand where the following statements go:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;frame = cam.get_frame()
saver_process = Process(target=save_movie, args=(5555, 'frame', frame.shape, frame.dtype))
saver_process.start()
[...]
saver_process.join()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the program again, you will see that there is a new file
appearing on your hard drive called &lt;strong&gt;movie.hdf&lt;/strong&gt;. Since writing to the
hard drive is handled by the operating system, you will see that it may
lag behind compared to the acquisition. This means that the saving can
finish much later than your real acquisition. The &lt;code&gt;save_movie&lt;/code&gt; includes
a &lt;code&gt;flush&lt;/code&gt; statement at the end, that guarantees that everything is going
to be written before the function ends.&lt;/p&gt;
&lt;p&gt;Now you see that if we want to attach a new process to our program, we
can do it without any complications. The main script only requires a
couple of lines and the behavior of the program is greatly enhanced. In
the same way, if we want to switch on or of different tasks, we can do
it without fundamentally altering the basic code.&lt;/p&gt;
&lt;h2&gt;ZMQ and Queues&lt;/h2&gt;
&lt;p&gt;With the example above you may be wondering what would happen if one of
the subscribers is slower than the rate at which we are generating data.
If you go to the chapter on &lt;a href="http://zguide.zeromq.org/php:chapter5"&gt;Advanced Pub/Sub
patterns&lt;/a&gt; you will see that ZMQ
has a very strong opinion about how it should be handled. In a nutshell:
let the subscriber crash. In principle, every subscriber will build up
its own queue in case it lags behind. The reasoning behind this is that
subscribers are likely to be running in a different computer and if it
crashes, the core of the application is still intact.&lt;/p&gt;
&lt;p&gt;This approach is, however, not useful for applications running in only
one PC, in which running out of memory will cause also the core
application to crash. Because of the architecture of ZMQ, it is not
possible to monitor the length of the queue in the subscriber.
Therefore, you have to be very careful about how to structure your
program in order to be sure that you will not be accumulating data
beyond the capacity of your computer.&lt;/p&gt;
&lt;p&gt;ZMQ implements a parameter called High Water Level (HWL) which instructs
both publishers and subscribers when to start dropping information. To
set the HWL on the publisher, you would add the following line before
the &lt;code&gt;bind&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;socket.setsockopt(zmq.SNDHWM, 5)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This means that if the publisher accumulates more than 5 frames on its
own queue, it will begin dropping the frames (i.e. not sending them). By
default, ZMQ has a value of 1000 frames which may be too high for
images. The disadvantage, however, is that there is no way of knowing
when (and how many) frames are being dropped.&lt;/p&gt;
&lt;p&gt;One of the options would be to implement a solution on the subscriber
side. For example, if frames would be numbered, the subscriber could
verify that each frame is the previous +1 and that it is not skipping
any. This works fine for patterns with only one publisher per
subscriber, and where topics are well defined beforehand. Another
possibility would be to monitor how long it takes for the subscriber to
process data, and abort its execution if it is longer than a predefined
value. This is called the &lt;a href="http://zguide.zeromq.org/py:suisnail"&gt;suicidal
snail&lt;/a&gt; and you can find some
examples and discussion on the ZMQ documentation.&lt;/p&gt;
&lt;p&gt;As you see, it is not a trivial task. If monitoring the length of the
queue that is being built up is important in your application, you will
need to find solutions that include a broker, such as
&lt;a href="https://www.rabbitmq.com/"&gt;RabbitMQ&lt;/a&gt; but which I believe is not the
proper solution for stand-alone desktop apps.&lt;/p&gt;
&lt;h2&gt;Serializing Python Objects&lt;/h2&gt;
&lt;p&gt;I find the solution outlined in the previous sections very elegant. With
a bit of cleaning up, it can work as a generalized signal/slot type of
pattern, multi-processing compatible and even able to distribute tasks
over the network. However, there is something that is important to keep
an eye on, especially if you are generating a high volume of data:
serializing and deserializing python objects.&lt;/p&gt;
&lt;p&gt;PyZMQ comes with two methods that are very handy: &lt;code&gt;send_pyobj&lt;/code&gt; and
&lt;code&gt;recv_pyobj&lt;/code&gt;. Under the hood, pyZMQ is using Pickle to serialize the
objects on one end and deserialize it on the other. Moreover, when we
are storing information on the &lt;code&gt;Queue&lt;/code&gt;, python is already serializing
the object. Therefore, in our pattern we are serializing the frame to
put in the &lt;code&gt;queue&lt;/code&gt;, deserializing at the &lt;code&gt;publisher&lt;/code&gt;, serializing to
broadcast, and deserializing at the &lt;code&gt;subscriber&lt;/code&gt;. This operation has a
high penalty and can be greatly improved by carefully planning the code.&lt;/p&gt;
&lt;h2&gt;Zero-Copy Messages&lt;/h2&gt;
&lt;p&gt;In the examples above, the objects that we are passing around are numpy
arrays. This means that there is another improvement possible: using
&lt;a href="https://pyzmq.readthedocs.io/en/latest/serialization.html"&gt;the
zero-copy&lt;/a&gt;
possibilities of ZMQ. Both subscribers use the exact same information
and neither of them does any in-place substitution. However, each frame
appears in several places: the camera, the queue, the publisher and the
two subscribers. In reality, we only need the data itself, we don't need
to be passing it from one place to another.&lt;/p&gt;
&lt;p&gt;Moreover, since each acquired frame will have the same properties as the
previous one (same shape, same type, etc.), it is possible to write very
efficient code. Using buffers goes beyond the scope of this article, but
I plan on writing a tutorial on them sometime soon. For the time being,
this is the example that appears on the pyZMQ docs:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import numpy

def send_array(socket, A, flags=0, copy=True, track=False):
    &amp;quot;&amp;quot;&amp;quot;send a numpy array with metadata&amp;quot;&amp;quot;&amp;quot;
    md = dict(
        dtype = str(A.dtype),
        shape = A.shape,
    )
    socket.send_json(md, flags|zmq.SNDMORE)
    return socket.send(A, flags, copy=copy, track=track)

def recv_array(socket, flags=0, copy=True, track=False):
    &amp;quot;&amp;quot;&amp;quot;recv a numpy array&amp;quot;&amp;quot;&amp;quot;
    md = socket.recv_json(flags=flags)
    msg = socket.recv(flags=flags, copy=copy, track=track)
    buf = buffer(msg)
    A = numpy.frombuffer(buf, dtype=md['dtype'])
    return A.reshape(md['shape'])
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;In this tutorial, we have seen how to use pyZMQ in a real application
that shares data across different processes. In this specific case, the
processes live on the same computer, but nothing limits us from finding
solutions where the data is shared across the network and handled by
different computers. The main objective of the tutorial was to show you
how you can build programs that are very flexible.&lt;/p&gt;
&lt;p&gt;We have seen that if you develop a proper base, choosing a ZMQ pattern
like pub/sub you can quickly switch on/off subscribers that deal with
the information available. We haven't discussed it, but it is also
possible for subscribers to send data to the publisher to be consumed by
downstream processes. The possibilities are endless.&lt;/p&gt;
&lt;p&gt;However, ZMQ is a fairly complex tool and therefore reading
its documentation &amp;lt;http://zeromq.org/&amp;gt; is very important. There
are a wealth of patterns that can be implemented to make the program
more robust, faster, etc. Remember that premature optimization may be a
liability more than a feature.&lt;/p&gt;
&lt;p&gt;The code for this tutorial can be found on
&lt;a href="https://github.com/PFTL/website/tree/master/example_code/26_ZMQ"&gt;Github&lt;/a&gt;,
as well as &lt;a href="https://github.com/PFTL/website/blob/master/content/blog/26_ZMQ.rst.md"&gt;the article
itself&lt;/a&gt;.
If you have any comments or suggestions, you are welcome to create them
&lt;a href="https://github.com/PFTL/website/issues"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Header photo by &lt;a href="https://unsplash.com/photos/ISG-rUel0Uw?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText"&gt;Thomas
Jensen&lt;/a&gt;
on Unsplash&lt;/p&gt;</content><category term="blog"></category><category term="ZMQ"></category><category term="Socket"></category><category term="Communication"></category><category term="Parallel"></category><category term="Data"></category></entry><entry><title>Building a CRM with Jupyter Notebooks</title><link href="https://www.pythonforthelab.com/blog/building-a-crm-with-jupyter-notebooks" rel="alternate"></link><published>2019-02-12T00:00:00+01:00</published><updated>2019-02-12T00:00:00+01:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2019-02-12:/blog/building-a-crm-with-jupyter-notebooks</id><summary type="html">&lt;p&gt;This tutorial is going to be off-topic compared to the others on the
website. It was born out of a question regarding how to send
personalized e-mails to several people on a list, and I thought it could
be useful to post a tutorial online. This will help people interested …&lt;/p&gt;</summary><content type="html">&lt;p&gt;This tutorial is going to be off-topic compared to the others on the
website. It was born out of a question regarding how to send
personalized e-mails to several people on a list, and I thought it could
be useful to post a tutorial online. This will help people interested in
building a simple Customer Relationship Manager (CRM) and it will also
show scientists that the skills they develop while working in the lab
can be used in various contexts.&lt;/p&gt;
&lt;p&gt;Let's first discuss what we want to achieve. A CRM is a tool that allows
users to send e-mails to customers and keep track of their answers. It
could be much more complex than that, integrating with a phone, social
media accounts, billing platforms, etc. but for our purposes, we will
keep it to what a normal person (like me) needs. It should be able to
send the same e-mail to several people but with a certain degree of
personalization, for example, saying &lt;em&gt;Dear John&lt;/em&gt; instead of a generic
&lt;em&gt;Dear Customer&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The CRM should prevent me from sending the same e-mail twice to the same
person and should be able to show me all the e-mails I have exchanged
with that person. It should also allow me to segment customers, making
it possible for me to send e-mails just to groups of people, for
example, the ones who took the Python For The Lab course and those who
are interested in it. The ones who bought the book and those who only
asked for the free chapter, etc. Let's get started!&lt;/p&gt;
&lt;h2&gt;The Choices&lt;/h2&gt;
&lt;p&gt;First, we will need a way of sending and receiving e-mail. If you are a
GMail user, you can check &lt;a href="https://support.google.com/mail/answer/7104828?hl=en"&gt;this
guide&lt;/a&gt; and &lt;a href="https://www.digitalocean.com/community/tutorials/how-to-use-google-s-smtp-server"&gt;this
other
one&lt;/a&gt;
on how to set up the server (you will need this information later on, so
keep it in hand). If you want to use a custom domain to send and receive
e-mail, I strongly suggest you use
&lt;a href="https://www.dreamhost.com/r.cgi?181470/promo/dreamsavings50/"&gt;Dreamhost&lt;/a&gt;
which is what I use myself (if you use the link, you will get a 50U\$
discount and at the same time you will help me keep this website
running). If you expect to send more than 100 e-mails per hour, I
suggest you check &lt;a href="https://aws.amazon.com/ses/"&gt;Amazon SES&lt;/a&gt; which is
very easy to set up and has reasonable pricing.&lt;/p&gt;
&lt;p&gt;Next, we need to define how to send e-mails. The fact that we are going
to use Python is out of the question. But here we have several choices
to make. I believe the best is to use Jupyter notebooks. They have the
advantage of allowing you to run different pieces of code, see the
output inline, etc. It is easier to have interaction through a Jupyter
notebook than through plain scripts. Building a user interface (either a
desktop app or a web app) would be too time-consuming for a minimum
increase in usability.&lt;/p&gt;
&lt;p&gt;We have now a web server, a platform, we only need to define how to
store the data. For this, I will choose SQLite. I have written in the
past about how to &lt;a href="15_Storing_data_3.rst.md"&gt;store data using SQLite&lt;/a&gt;, but
in this article, we are going one step further by introducing an ORM, or
Object Relational Mapping, which will greatly simplify our work when
defining tables, accessing data, etc.&lt;/p&gt;
&lt;h2&gt;Jupyter Notebooks&lt;/h2&gt;
&lt;p&gt;If you are familiar with the Jupyter notebooks, just skip this section
and head to the next one. If you are not familiar with them, I will give
you a very quick introduction. First, you need to install the needed
package. If you are an Anaconda user, you have Jupyter by default. If
you are not, you should start by creating a &lt;a href="03_Virtual_Environment.rst.md"&gt;Virtual
Environment&lt;/a&gt;, and then do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install jupyter
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The installation will take some time because there are many packages to
download, but don't worry, it will be over soon. Then, you can simply
run the following command:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;jupyter notebook
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you are not inside a virtual environment, or the command above fails,
you can also try the following command, directly on your terminal:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;python -m jupyter notebook
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After you run the command, your web browser should open. Bear in mind
that you will use as base folder the folder where you run the command
above. Just select new from the top-right button and start a new Python
3 notebook.&lt;/p&gt;
&lt;p&gt;You should be welcomed by a screen like this:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Empty Jupyter Notebook" class="center-img" src="/images/27_images/01_jupyter.jpg"&gt;&lt;/p&gt;
&lt;p&gt;The arrow indicates the name of the notebook. You can edit it to
something more descriptive than Untitled. For example,
&lt;strong&gt;Test_Notebook&lt;/strong&gt;. The line that you see in green is where your input
should go. Let's try a simple print statement, like what you see in the
image below. To run the code, you can either press Shift+Enter or click
the play button that says run, while the cursor is still in the cell.&lt;/p&gt;
&lt;p&gt;&lt;img alt="First Cell" class="center-img" src="/images/27_images/02_jupyter.jpg"&gt;&lt;/p&gt;
&lt;p&gt;The advantage of Jupyter notebooks is that they also keep the output
when you share them. You can see &lt;a href="https://github.com/PFTL/website/blob/master/example_code/27_CRM/Test_Notebook.ipynb"&gt;this example
notebook&lt;/a&gt;
on Github. And they allow you to embed markdown text in order to
document what you are doing.&lt;/p&gt;
&lt;p&gt;If you haven't used Jupyter notebooks before, now it is a great chance
to get started. They are very useful for prototyping code that later can
become an independent program. From now on, I will not stress every
single time that the code should go into a notebook, but you should
assume it.&lt;/p&gt;
&lt;p&gt;As always, all the code for this project &lt;a href="https://github.com/PFTL/website/tree/master/example_code/27_CRM"&gt;can be found
here&lt;/a&gt;.
The majority of the code that goes into the Jupyter notebooks can also
be copy-pasted into plain Python script files. Just keep in mind that
the order in which you can run cells is up to you and not necessarily
from top to bottom as is the case for scripts.&lt;/p&gt;
&lt;h2&gt;Sending Email&lt;/h2&gt;
&lt;p&gt;The most basic function of any customer relationship manager is to be
able to send e-mails. Having just this functionality is already useful
in a lot of different situations, not only professionally but also for
private tasks. For example, you can invite your friends to a party by
addressing them by name: '&lt;em&gt;Dear Brian,&lt;/em&gt;'. In order to be able to send
e-mails, you need to be able to configure an SMTP server.&lt;/p&gt;
&lt;p&gt;If you are a Google User you can check &lt;a href="https://www.digitalocean.com/community/tutorials/how-to-use-google-s-smtp-server"&gt;this
guide&lt;/a&gt;,
or you can &lt;a href="https://www.dreamhost.com/r.cgi?181470/promo/dreamsavings50/"&gt;sign up to
Dreamhost&lt;/a&gt;
or &lt;a href="https://aws.amazon.com/ses/"&gt;Amazon Services&lt;/a&gt;. If you want to use a
custom domain, the Dreamhost way is the easiest and quickest. You can
read the &lt;a href="https://help.dreamhost.com/hc/en-us/articles/214918038-Email-client-configuration-overview"&gt;documentation for configuring your
e-mail&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let's start by creating a configuration file in which we will store some
useful parameters. Create an empty file in the same directory where you
will be working and call it &lt;strong&gt;config.yml&lt;/strong&gt;. You can use Jupyter to
create this file, just select &lt;em&gt;Text File&lt;/em&gt; after clicking on &lt;em&gt;New&lt;/em&gt;. And
in the file, put the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;EMAIL:
  username: my_username
  password: my_password
  port: 1234
  smtp_server: smtp.server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The format of this file is called YAML, which is a very simple markup
language in which blocks are indented by &lt;strong&gt;2 spaces&lt;/strong&gt;. Replace the
different variables by what you need, i.e., replace &lt;code&gt;my_username&lt;/code&gt; with
the username of your server, etc. My choice of putting this information
on a different file is that now I can share my Jupyter notebooks without
exposing my password. In order to work with YAML files in Python, you
will need to install &lt;code&gt;pyyaml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install pyyaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we are ready to start. Let's create a new Python notebook. Let's
call it, for example, &lt;strong&gt;simple_crm&lt;/strong&gt;. The first thing to do is to load
the configuration:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;import pyyaml

with open('config.yml', 'r') as config_file:
    config = yaml.load(config_file)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you are not familiar with the &lt;code&gt;with&lt;/code&gt; command you can check &lt;a href="16_context_manager.rst.md"&gt;this
article about the context manager&lt;/a&gt;. If you want
to explore how your variable &lt;code&gt;config&lt;/code&gt; looks like, you can simply write
it in a different cell and press Ctrl+Enter. The result is a dictionary
with the needed parameters for sending e-mail. So, let's get to it.&lt;/p&gt;
&lt;p&gt;First, let's compose a short message and subject:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;msg_sbj = 'Testing my brand new CRM with Jupyter notebooks'
msg_text = '''This is the body of the message that will be sent.\n
Even if basic, it will prove the point.\n\n
Hope to hear again from you!'''
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, the way of composing the message requires to import a special
module of Python called &lt;code&gt;email&lt;/code&gt;. The code would look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

me = &amp;quot;Aquiles &amp;lt;my@from.com&amp;gt;&amp;quot;
you = &amp;quot;Aquiles &amp;lt;your@to.com&amp;gt;&amp;quot;
msg = MIMEMultipart()
msg['From'] = me
msg['To'] = you
msg['Subject'] = msg_sbj
msg.attach(MIMEText(msg_text, 'plain'))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We first create a &lt;code&gt;msg&lt;/code&gt;, which will be ready to send both plain and HTML
e-mails. We specify the &lt;code&gt;from&lt;/code&gt;, &lt;code&gt;to&lt;/code&gt;, and &lt;code&gt;subject&lt;/code&gt; of the email.
Remember that if you specify the wrong &lt;code&gt;from&lt;/code&gt;, your message has a high
chance of being filtered either by your SMTP provider or the receiver's
server as spam. Be sure you use the proper e-mail from-address that you
have configured.&lt;/p&gt;
&lt;p&gt;The last line attaches the plain version of the e-mail to the message.
We will see that it is also possible to send more complex messages, with
a plain text version and an HTML version. Now that we have our e-mail
ready, we need to send it.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;import smtplib

with smtplib.SMTP(config['EMAIL']['smtp_server'], config['EMAIL']['port']) as s:
    s.ehlo()
    s.login(config['EMAIL']['username'],config['EMAIL']['password'])
    s.sendmail(me, you, msg.as_string())
    s.quit()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, you see that we start the SMTP connection using the configuration
parameters that were defined on the &lt;strong&gt;config.yml&lt;/strong&gt; file. The &lt;code&gt;ehlo&lt;/code&gt;
command is a way of telling the server &lt;em&gt;hello&lt;/em&gt; and start the exchange of
information. We then log in and finally send the message. See that we
defined both the sender and receiver twice: they are used in the
&lt;code&gt;sendmail&lt;/code&gt; command, but also they are defined within the &lt;code&gt;msg&lt;/code&gt; object.&lt;/p&gt;
&lt;p&gt;If you used real e-mails, you should by now receive the example message.&lt;/p&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;Sometimes GMail does not deliver messages that you send to yourself from
different aliases. If nothing arrives, you can try to send an e-mail to
a different address which you control.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Now, imagine you would like to personalize the message before sending
it. For example, we would like to address the recipient by name. We can
improve our message, to make it look like a template, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;msg_text = '''Hello {name},
This is the body of the message that will be sent.
Even if basic, it will prove the point.
Hope to hear again from you!'''
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And you can use it like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;msg_text.format(name='Aquiles')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which will output the message exactly as you expected. If you now would
like to send a message to different people, you could simply do a
for-loop. Remember that before generating the message body, you replace
the name by the name of your contact as shown in the code above.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;I will not go into the details of how to implement the loop because we
will work on this later on, in a much more complete solution.&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;Adding HTML to the message&lt;/h2&gt;
&lt;p&gt;Now it is time to make your messages more beautiful by adding HTML to
them. Coding HTML e-mails is a complicated subject because there are
many things to take into account. First, e-mail clients work differently
from each other, meaning that the way your e-mail is displayed depends
on how it is opened. Screen sizes change, and therefore your e-mail
should have a fixed width or it will look very ugly on some devices.
Being aware of these problems, I would suggest you check ready-made
templates developed by designers who took care of all of this.&lt;/p&gt;
&lt;p&gt;In this tutorial, we are going to use
&lt;a href="https://tedgoas.github.io/Cerberus/"&gt;Cerberus&lt;/a&gt; which, among other
things, is open source and free. If you unzip the contents, you will
find 3 important files: &lt;strong&gt;cerberus-fluid.html&lt;/strong&gt;,
&lt;strong&gt;cerberus-responsive.html&lt;/strong&gt;, and &lt;strong&gt;cerberus-hybrid.html&lt;/strong&gt;. Those are
three different templates which you can use. We are going to use the
responsive version.&lt;/p&gt;
&lt;p&gt;You should open the files with your browser in order to have an idea of
how they look. Also, check the source code to understand how you can
utilize different elements, change the color, etc. The documentation is
your best friend. I have stripped down a bit the template. You can find
it
&lt;a href="https://github.com/PFTL/website/blob/master/example_code/27_CRM/base_email.html"&gt;here&lt;/a&gt;.
For practical purposes it doesn't really matter, you can use the
original also.&lt;/p&gt;
&lt;p&gt;What we will do is keep the e-mail template as a separated file, so we
don't pollute the notebook that much. In order to add it to our message,
we need to do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;with open('base_email.html') as f:
    msg_html = f.read()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then, the only two things we need to add to the message is the
following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;msg = MIMEMultipart('alternative')
msg.attach(MIMEText(msg_html, 'html'))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pay attention that we need to initialize the message with the argument
&lt;code&gt;'alternative'&lt;/code&gt;. If we fail to do this, the message will include both
the text and the HTML versions one after the other.&lt;/p&gt;
&lt;p&gt;The idea of attaching both the text and the HTML version of the e-mail
is that we keep in mind that not all people accept HTML messages. You
can configure most e-mail clients to use only plain text messages. This
is a good way of preventing trackers from spying on you and makes
e-mails easier to read. Moreover, it can make phishing attempts easier
to spot.&lt;/p&gt;
&lt;p&gt;The e-mail, if you attach both versions, will be shown as HTML if the
client supports it and will fall back to the text version if it doesn't.
In general lines, we can say that adding HTML versions of your messages
is up to you, adding the text version should be mandatory.&lt;/p&gt;
&lt;h2&gt;Receiving Email&lt;/h2&gt;
&lt;p&gt;Sending e-mails is half of what a CRM should do. The other half is
checking e-mails. This will allow the system to store messages
associated with the people with whom you interact. This will allow you
to check, for example, who never replied to your questions. We will
start by updating the configuration file since we now need to add the
POP3 server:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;EMAIL:
  username: my_username
  password: my_password
  port: 1234
  smtp_server: smtp.server
  pop_server: pop.server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you would need a different username or password for the POP server,
you can add them also to the config file. Remember that you will need to
reload the configuration file in order to have the new variable
available.&lt;/p&gt;
&lt;p&gt;Reading from the server is relatively easy:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;import poplib
server = poplib.POP3(config['EMAIL']['pop_server'])
server.user(config['EMAIL']['username'])
server.pass_(config['EMAIL']['password'])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the block again and it works out correctly, you will see the
following message:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;b'+OK Logged in.'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we need to download the list of messages that are available on the
server:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;resp, items, octets = server.list()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Bear in mind that if there are no messages available, you won't be able
to do anything else. You can always send one or more e-mails to yourself
in order to test the code. Items will hold information regarding the
available messages. If you explore the &lt;code&gt;items&lt;/code&gt; variable, you will see an
output like the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;[b'1 34564', b'2 23746', b'3 56465']
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case, the server has 3 available messages. The first number is
the id of the message, while the second is its size. If we want to
retrieve the first message, for example, we can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;msg = server.retr('1')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you explore the &lt;code&gt;msg&lt;/code&gt;, you will see it is a tuple with 3 elements.
The message itself is stored in &lt;code&gt;msg[1]&lt;/code&gt;. However, it is a list, full of
information regarding the message you have downloaded. Without going
into too much detail, first, you need to transform the list into a
single array, and then we can use the mail tools to parse the
information into a usable format:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;import email

raw_email = b'\n'.join(msg[1])
parsed_email = email.message_from_bytes(raw_email)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You are free to explore each step independently to try to understand
what is available in your message. The &lt;code&gt;parsed_email&lt;/code&gt; has a lot of
information, not only regarding who sent the message and to whom but
also the server used, spam filtering options, etc. We would like to show
the contents of the e-mail, both the HTML and the text formats, so we
can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;for part in parsed_email.walk():
    if part.get_content_type() == 'text/plain':
        print(part.get_payload()) # prints the raw text
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will go through all the available information in the message, and
if it finds it is of type &lt;code&gt;text/plain&lt;/code&gt;, it will print it to the screen.
You can change it to &lt;code&gt;text/html&lt;/code&gt; and it will show the other version, if
available.&lt;/p&gt;
&lt;p&gt;As you can see, retrieving e-mails is relatively more complex than
sending e-mails. There are also some other concerns regarding what you
do with the messages you downloaded. For example, you can leave them on
the server, thus they will be available from other clients as well. You
can also choose to delete them from the server after reading, etc. Each
pattern has advantages and disadvantages, so that will be up to the
workflow you are considering.&lt;/p&gt;
&lt;p&gt;The code up to here can be found on &lt;a href="https://github.com/PFTL/website/blob/master/example_code/27_CRM/simple_CRM_01.ipynb"&gt;this
notebook&lt;/a&gt;.
Now we are going to focus a bit more onto expanding the usability of our
tools.&lt;/p&gt;
&lt;h2&gt;Using a Database&lt;/h2&gt;
&lt;p&gt;In the previous sections, we have seen how you can send and receive
e-mails with Python directly from a Jupyter notebook. Now it is time to
focus onto a different topic. It is important when you want to establish
relationships with customers, to have a way of storing information
persistently. For example, you would like to keep an agenda of contacts,
you would like to know when was the last time you contacted someone,
etc.&lt;/p&gt;
&lt;p&gt;In order to achieve a high level of flexibility, we are going to use a
database to store all our information. Fortunately, Python supports
SQLite databases out of the box. We have discussed about them in a
&lt;a href="https://www.pythonforthelab.com/blog/storing-data-with-sqlite"&gt;different article&lt;/a&gt; that may be
useful for you to check if you want to dig into the details. We are
going to use a library called SQLAlchemy, which will allow us to define
relationships between elements much faster. You can install it like any
other Python package:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install sqlalchemy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first thing we will do is creating a new notebook to explore how to
use the database from within Jupyter. Let's start by importing all the
needed modules:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;from sqlalchemy import create_engine
from sqlalchemy import Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, we create the database engine:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;engine = create_engine('sqlite:///crm.db', echo=True)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the engine supports other types of databases, not only SQLite.
However, SQLite is by far the easiest to work with for small
applications such as ours.&lt;/p&gt;
&lt;p&gt;We also define a declarative base, that will allow us to define classes
that will be mapped to tables:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;Base = declarative_base()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now it is time to define what information we want to store to the
database. For the CRM it seems reasonable to start by defining
customers. The advantage of using SQLAlchemy is that instead of working
directly on the database, we can do that through the engine and the
base. To define what information we want to store, we have to define a
class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;class Customer(Base):
    __tablename__ = 'customers'
    id = Column(Integer, primary_key=True)
    name = Column(String)
    last_name = Column(String)
    email = Column(String)

    def __repr__(self):
        return &amp;quot;&amp;lt;Customer(name='{}', last_name='{}', email='{}')&amp;gt;&amp;quot;.format(
        self.name, self.last_name, self.email)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I think the code above it is self-explanatory. We define the name of the
table we want to use. Each attribute defined with &lt;code&gt;Column&lt;/code&gt; will be
transformed into a column in the table, of the specified type, in our
case we have &lt;code&gt;Integer&lt;/code&gt; for &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; for all the rest. In order
to create the table, we have to run the following command:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;Base.metadata.create_all(engine)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You will see a lot of content appearing on the screen. If you are
familiar with SQL you will notice the commands that are being executed.
Now what we have is a very nice relationship between a class
(&lt;code&gt;Customer&lt;/code&gt;) and a table (&lt;code&gt;customers&lt;/code&gt;) on our database. Let's create our
first customer:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;first_customer = Customer(name='Aquiles', last_name='Carattino', email='aquiles@uetke.com')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now we need to add it to the database. This is achieved through the
creation of a session:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;from sqlalchemy.orm import sessionmaker
Session = sessionmaker(bind=engine)
session = Session()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The last step is to add the customer to the database:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;session.add(ed_user)
session.commit()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that is all. If you know how to explore the database with an
external tool, you will see the data that we have just added. You can
follow the steps above for as many customers as you want. To retrieve
information from the database, we can use the session and the &lt;code&gt;Customer&lt;/code&gt;
class directly. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;one_customer = session.query(Customer).filter_by(name='Aquiles').first()
print(one_customer)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It will give you as output the information of your customer. Pay
attention to the fact that when you filter in this way, the options are
case sensitive. We will not cover all the details regarding how to use
SQLAlchemy, especially because &lt;a href="https://docs.sqlalchemy.org/en/latest/index.html"&gt;their
documentation&lt;/a&gt; is very
extensive, but it is important to see how to search with partial
information, for example looking by parts of the name:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;one_customer = session.query(Customer).filter(Customer.name.like('aqui%')).first()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will find all customers with a name that starts with &lt;code&gt;aqui&lt;/code&gt;,
regardless of their case. There is a detail that it is also very
important and that I haven't mentioned yet, the &lt;code&gt;first()&lt;/code&gt; that appears
at the end. Let's see what happens if you have two customers in the
database, and they have similar names so that the command above gets
both of them:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;second_customer = Customer(name='Aquileo', last_name='Doe', email='aquileo@doe.com')
session.add(second_customer)
session.commit()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let's remove the &lt;code&gt;first()&lt;/code&gt;, and let's run the same command as before:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;answer = session.query(Customer).filter(Customer.name.like('aqui%'))
print(answer)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Will give you as output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;&amp;lt;sqlalchemy.orm.query.Query at 0x7f003da05390&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The answer is not a list of customers, but an object called Query. If
you want to go through each element, you can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;for c in answer:
    print(c)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The idea of the query is that it knows how many elements are there but
it didn't load the information to memory. This makes it incredibly handy
if you are working with very large databases.&lt;/p&gt;
&lt;p&gt;With a bit of creativity, you can already merge what we learned before
in order to send e-mails to all the customers in your database. Before
discussing how to implement that, I would like to focus on one more
topic, which is how to add tags to the customers and keep track of the
sent messages.&lt;/p&gt;
&lt;h2&gt;Database Relationships&lt;/h2&gt;
&lt;p&gt;One of the features we want to have in our CRM is to be able to keep
track of the sent messages, so we can avoid sending twice the same
e-mail to the same person, or we can check how long it was since we sent
the last message, etc. We will define a new class called &lt;code&gt;Message&lt;/code&gt; in
which we will hold the information of every message sent. It will look
like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;from sqlalchemy import Text, Date, ForeignKey
from sqlalchemy.orm import relationship

class Message(Base):
    __tablename__ = 'messages'
    id = Column(Integer, primary_key=True)
    name = Column(String)
    text = Column(Text)
    date = Column(Date)

    customer_id = Column(Integer, ForeignKey('customers.id'))
    customer = relationship(&amp;quot;Customer&amp;quot;, back_populates=&amp;quot;messages&amp;quot;)

    def __repr__(self):
        return &amp;quot;&amp;lt;Message(name='{}', date='{}', customer='{}')&amp;gt;&amp;quot;.format(
        self.name, self.date, self.customer)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Bear in mind that the imports complement the ones of the previous
section, they do not replace the others but are new for this piece of
code. The beginning is very similar to the previous class, but the main
difference is the part referring to the customers. Each message will be
sent to a specific customer. To make this bridge, we use the
&lt;code&gt;ForeignKey&lt;/code&gt;. This means that the value that is going to be stored in
&lt;code&gt;customer_id&lt;/code&gt; has to be an existing customer id. In this way, we can add
more dimensions to our plain tables.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;relationship&lt;/code&gt; is a way of telling SQLAlchemy where the data is
going to be accessed. Having the id of the customer is handy, but it is
better if we have direct access to the information. In such a case, if
we would like to know the name of the customer who got the message, we
can do something like &lt;code&gt;message.customer.name&lt;/code&gt;. The opposite relationship
is also valid, and we need to add it. We can simply do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;Customer.messages = relationship('Message', order_by=Message.id, back_populates='customer').
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then you just need to update the engine:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;Base.metadata.create_all(engine)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, let's create some messages to understand how we can use this new
strategy. We first need to get at least one customer, so we can assign
the messages to it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;from datetime import datetime

c = session.query(Customer).first()
new_message = Message(name='Welcome', text='Welcome to the new CRM', date=datetime.now(), customer=c)
session.add(new_message)
session.commit()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We get the first customer from the table, and then we create a new
message. This is just an example, but in principle, the variable &lt;code&gt;text&lt;/code&gt;
could be much longer. If we want to retrieve this message from the
database, we can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;message = session.query(Message).first()
print(message)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now you will see that you have the information not only about this
message but also about the customer to whom the message was sent. You
can also try the other way around, see all the messages sent to a
particular customer, by doing the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;c = session.query(Customer).first()
print(c.messages)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And you will get a list of all the messages that were sent. Now you have
an idea of how this can very quickly start to be a useful tool, not just
a mere exercise.&lt;/p&gt;
&lt;p&gt;The relationship between messages and customers is called many-to-one
because a customer can have many messages associated with it, but each
message will be associated with a single customer. There is also another
relationship possible, which is called many-to-many. This would be the
case of having lists of customers. A customer can belong to several
lists, and at the same time, each list can contain several customers.&lt;/p&gt;
&lt;p&gt;If you think that a database is nothing more than a collection of tables
in which each entry has a unique identifier, you will realize that there
is no way of making this many-to-many between two tables directly. We
will need to define an intermediate table which will hold these
relationships. First, let's start by the list itself:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;class List(Base):
    __tablename__ = 'lists'
    id = Column(Integer, primary_key=True)
    name = Column(String)

Base.metadata.create_all(engine)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now we need to create the intermediate table:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;from sqlalchemy import Table

association_table = Table('list_customer', Base.metadata,
    Column('left_id', Integer, ForeignKey('customers.id')),
    Column('right_id', Integer, ForeignKey('lists.id'))
)

Base.metadata.create_all(engine)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;See, that it is a table that has two columns each with a foreign key,
one for the customer and one for the list.&lt;/p&gt;
&lt;p&gt;We can do the same we did earlier in order to be able to use
&lt;code&gt;customer.lists&lt;/code&gt; to get the lists to which the customer is subscribed:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;Customer.lists = relationship(&amp;quot;List&amp;quot;,
                    secondary=association_table,
                    backref=&amp;quot;customers&amp;quot;)

Base.metadata.create_all(engine)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now, it is time to create a list, append a user and save it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;c_list = List(name='New List')
customer = session.query(Customer).first()
c_list.customers.append(customer)
session.add(c_list)
session.commit()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Remember not to use a plain &lt;code&gt;list&lt;/code&gt; variable, since it is a Python
keyword. I think it is pretty clear what is going on. Finally, if you
want to retrieve a list and find the customers subscribed to it, you
would do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;las_list = session.query(List).first()
print(las_list.customers)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;On the other hand, you can check the lists to which a user is
subscribed:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;print(customer.lists)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;See that the output of this last command is not particularly nice. This
is because we haven't defined a specific &lt;code&gt;__repr__&lt;/code&gt; method as we have
done for the other classes.&lt;/p&gt;
&lt;p&gt;With this, we are done regarding how to use databases to store
information. Now it is time to get into the action. The full code
discussed in this section can be found on &lt;a href="https://github.com/PFTL/website/blob/master/example_code/27_CRM/simple_crm_02.ipynb"&gt;this
notebook&lt;/a&gt;.
Now it is time to clean up the code in order to make more usable and
extendable.&lt;/p&gt;
&lt;h2&gt;Sending To All Customers&lt;/h2&gt;
&lt;p&gt;The notebook that we have developed in the previous section is very
dirty. We have been adding features on the fly, without really worrying
about how easy it is to understand it. Imports were scattered all over
the place, classes get modified at runtime, etc. An example of a cleaned
up notebook can be &lt;a href="https://github.com/PFTL/website/blob/master/example_code/27_CRM/simple_CRM_03_clean_db.ipynb"&gt;found
here&lt;/a&gt;.
I won't enter into the details, you are free to use it.&lt;/p&gt;
&lt;p&gt;We are going to focus now a bit more on usability. How can we send the
e-mail to all our customers, using what we've learned in the first
section and combining it with what we've developed in the previous one?
We will start a new notebook. The first thing we need is to have
available all the classes to interface with the database. We start the
new notebook like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;%run clean_db.ipynb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;in this case, you need to change &lt;code&gt;clean_db&lt;/code&gt; by whatever name you have
given to the notebook that created the database. The command above is
equivalent to inserting the notebook at the beginning and running it.
Therefore, all the variables, classes, functions, etc. that you have
developed are going to be available.&lt;/p&gt;
&lt;p&gt;Now we need to be able to send a message to all our customers. We can
develop a function that will take care of the sending of e-mails:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def send_all():
    customers = session.query(Customer)
    for customer in customers:
        message = customer.create_msg('Message_name', 'template_file')
        message.send(config)
        session.add(message)
        session.commit()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At this stage this is not sending any message, it is just showing how it
would look like. The code above implements a lot of different choices on
how to find a solution. One is that we would like the &lt;code&gt;Customer&lt;/code&gt; class
that creates a message, and the message is able to send itself. Then we
store that message into the database. This prevents adding messages to
the database if the sending fails. The &lt;code&gt;Customer&lt;/code&gt; class will look like
this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Customer(Base):
    __tablename__ = 'customers'
    id = Column(Integer, primary_key=True)
    name = Column(String)
    last_name = Column(String)
    email = Column(String)

    def create_msg(self, message_name, template_file):
        with open(template_file, 'r') as template:
            text = template.format(name=self.name)
        message = Message(name=message_name, text=text, customer=self, date=datetime.now())
        return message

    def __repr__(self):
        return &amp;quot;&amp;lt;Customer(name='{}', last_name='{}', email='{}')&amp;gt;&amp;quot;.format(
        self.name, self.last_name, self.email)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You see that we have only added the method &lt;code&gt;create_msg&lt;/code&gt; which returns a
new message, after formatting the test. Then, we need to update the
message class to be able to send itself to a customer. We can do the
following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Message(Base):
    __tablename__ = 'messages'
    id = Column(Integer, primary_key=True)
    name = Column(String)
    text = Column(Text)
    date = Column(Date)

    customer_id = Column(Integer, ForeignKey('customers.id'))
    customer = relationship(&amp;quot;Customer&amp;quot;, back_populates=&amp;quot;messages&amp;quot;)

    def send(self, config):
        me = config['me']
        you = '{} &amp;lt;{}&amp;gt;'.format(self.customer.name, self.customer.email)
        msg = MIMEMultipart('alternative')
        msg['From'] = me
        msg['To'] = you
        msg['Subject'] = self.name
        msg.attach(MIMEText(self.text, 'plain'))
        with smtplib.SMTP(config['EMAIL']['smtp_server'], config['EMAIL']['port']) as s:
            s.ehlo()
            s.login(config['EMAIL']['username'],config['EMAIL']['password'])
            s.sendmail(me, you, msg.as_string())

    def __repr__(self):
        return &amp;quot;&amp;lt;Message(name='{}', date='{}', customer='{}')&amp;gt;&amp;quot;.format(
            self.name, self.date, self.customer)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can see that I have moved the &lt;code&gt;me&lt;/code&gt; option into the config file. This
is something you will need to add by yourself in order to make it
compatible. It should look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;me: My Name &amp;lt;my@email.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And should be top-level (i.e. not inside the &lt;code&gt;EMAIL&lt;/code&gt; block). Since
sending the message needs to have the config available, we will run the
code like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with open('config.yml', 'r') as config_file:
    config = yaml.load(config_file)
send_all()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Remember that when you change notebooks you need to save them, and then
you need to run the first block with the &lt;code&gt;%run&lt;/code&gt; command again in order
to reflect the changes. We still need to work a bit on the &lt;code&gt;send_all&lt;/code&gt;.
In the example above, we have fake names for the subject and the
template. We can improve that:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def send_all(subject, template):
    customers = session.query(Customer)
    for customer in customers:
        message = customer.create_msg(subject, template)
        message.send(config)
        session.add(message)
        session.commit()
        print('Sent message {} to: {}'.format(subject, customer.email))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, let's create a text file called &lt;strong&gt;test_email.txt&lt;/strong&gt; with the
following content:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;Hello {name},
Welcome to the test CRM.
Hope you are enjoying it!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now, if we want to send the message to all our customers, we can do
the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with open('config.yml', 'r') as config_file:
    config = yaml.load(config_file)
send_all('Testing the CMR', 'test_email.txt')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now, you should see your messages being sent. You should also see
that the messages are personalized, replacing the name in the template
by the name of the customer getting the message. You can get as creative
as you want with these options. However, there is still an important
feature missing: send to a group of customers.&lt;/p&gt;
&lt;h2&gt;Refactoring: Send to a list&lt;/h2&gt;
&lt;p&gt;Since the amount of code we have developed is not that much, you can
still go through it and change it in all the needed places. But imagine
someone else has developed code that depends on what you have done. If
you change something as important as the number of arguments a function
takes, you will break the downstream code. In our case, we want to
change the &lt;code&gt;send_all&lt;/code&gt; function in order to accept the name of a list as
an argument. However, we don't want to break the code that already uses
&lt;code&gt;send_all&lt;/code&gt; with just two arguments (subject and template).&lt;/p&gt;
&lt;p&gt;If you want to add a new argument to a function while making it
optional, there are two ways. One is to use the &lt;code&gt;*args&lt;/code&gt; syntax, the
other is to use a default value. The latter is slightly easier to
understand for novice programmers. If we do the following to our
function:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def send_all(subject, template, list_name='all'):
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You will see that the code
&lt;code&gt;send_all('Testing the CMR', 'test_email.txt')&lt;/code&gt; still works fine. So we
can now improve the function to get the customers that belong to a
certain list.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def send_all(subject, template, list_name='all'):
    if list_name == 'all':
        customers = session.query(Customer)
    else:
        customer_list = session.query(List).filter_by(name=list_name).first()
        customers = customer_list.customers
    for customer in customers:
        message = customer.create_msg(subject, template)
        message.send(config)
        session.add(message)
        session.commit()
        print('Sent message {} to: {}'.format(subject, customer.email))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So now, if you create a list of customers named &lt;code&gt;'Initial Customers'&lt;/code&gt;,
for example, you can send a message to them by simply doing the
following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;send_all('Testing the CMR', 'test_email.txt', 'Initial Customers')
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Avoid repeating messages&lt;/h2&gt;
&lt;p&gt;What you have seen up to now, should open the doors to a lot of very
nice creative approaches not only to CRM but to a variety of tasks that
you can automate with Python. The last feature that I would like to show
you is how to avoid sending the same message to the same person. You can
check it either when you create the message with the customer class, or
before sending it. Since it is normally a good idea to catch problems as
early as possible, let's improve the &lt;code&gt;Customer&lt;/code&gt; class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Customer(Base):
    __tablename__ = 'customers'
    id = Column(Integer, primary_key=True)
    name = Column(String)
    last_name = Column(String)
    email = Column(String)

    def create_msg(self, message_name, template_file):
        message_count = session.query(Message).filter_by(name=message_name, customer=self).count()
        if message_count &amp;gt; 0:
            raise Exception('Message already sent')
        with open(template_file, 'r') as template:
            template = template.read()
            text = template.format(name=self.name)
        message = Message(name=message_name, text=text, customer=self, date=datetime.now())
        return message
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The highlighted line is the important change to the &lt;code&gt;Customer&lt;/code&gt; class.
Pay attention to the syntax. We filter both by the message name and the
customer who received the message. Then, we use the &lt;code&gt;count()&lt;/code&gt; method,
which is the proper way of knowing how many results are available in the
database. It is much more efficient than getting all the results with
&lt;code&gt;all()&lt;/code&gt; and then using the &lt;code&gt;len()&lt;/code&gt; function. Anyways, if you try again
the &lt;code&gt;send_all&lt;/code&gt; function, you will see that it fails if you try to send
the same message twice. Now, this is not exactly what we need. If you
want to send the message to the people who didn't get the message yet,
you would like to skip the people, not stop the execution.&lt;/p&gt;
&lt;p&gt;In order to achieve that, we can &lt;a href="https://www.pythonforthelab.com/blog/learning-not-to-handle-exceptions"&gt;handle the
exception&lt;/a&gt;. But since we are
using a generic exception, we will handle everything in the same way,
regardless of whether it was raised because of an error in the database
or because the message was repeated. The best strategy is therefore to
create a custom exception:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;class MessageAlreadySent(Exception):
    pass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then the &lt;code&gt;Customer&lt;/code&gt; can use:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ipython3"&gt;if message_count &amp;gt; 0:
    raise MessageAlreadySent('Message {} already sent to {}'.format(message_name, self.email))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we can change the &lt;code&gt;send_all&lt;/code&gt; in order to catch this specific
exception:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def send_all(subject, template, list_name='all'):
    if list_name == 'all':
        customers = session.query(Customer)
    else:
        customer_list = session.query(List).filter_by(name=list_name).first()
        customers = customer_list.customers
    for customer in customers:
        try:
            message = customer.create_msg(subject, template)
            message.send(config)
            session.add(message)
            session.commit()
            print('Sent message {} to: {}'.format(subject, customer.email))
        except MessageAlreadySent:
            print('Skipping {} because message already sent'.format(customer.email))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the exception is &lt;code&gt;MessageAlreadySent&lt;/code&gt; we will deal with it and will
skip the user. Bear in mind that since the exception appears with the
&lt;code&gt;customer.create_msg&lt;/code&gt; line, the rest of the block is not executed, the
message is not created, nor added to the database. This guarantees that
if the exception is of a different kind, for example, the SMTP server is
not working, the database is broken, etc. the exception will not be
handled and the proper error will appear on the screen.&lt;/p&gt;
&lt;p&gt;The final version of the definition of classes can be found on &lt;a href="https://github.com/PFTL/website/blob/master/example_code/27_CRM/simple_CRM_05_clean_db_2.ipynb"&gt;this
notebook&lt;/a&gt;,
while the final version for the sending e-mail is &lt;a href="https://github.com/PFTL/website/blob/master/example_code/27_CRM/simple_CRM_04_send_all.ipynb"&gt;this
notebook&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;This tutorial aims at showing you how you can quickly prototype
solutions by using &lt;strong&gt;Jupyter notebooks&lt;/strong&gt;. They are not the proper tool
if you want to distribute the code as a package for others to use, but
it is very quick to find problems, run just what you need, etc.&lt;/p&gt;
&lt;p&gt;Regarding the CRM itself, it is not complete yet. You can see it as a
minimum-viable-product. You can send e-mails to your customers, keep
track of what messages were sent when etc. Considering the amount of
work it took to set it up, you should be very satisfied.&lt;/p&gt;
&lt;p&gt;The main objective of this tutorial was to show you how you can combine
different tools in order to build a new project. Of course, many things
can be improved, made more efficient, etc. The reality is that if you
need to handle communication with some hundreds of customers, you don't
need much more than what we did. Perhaps you can make it more
functional, prettier, etc. But that is more customization than core
development.&lt;/p&gt;
&lt;p&gt;Header Photo by
&lt;a href="https://unsplash.com/photos/7uGUFCyH3GY?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText"&gt;rawpixel&lt;/a&gt;
on Unsplash&lt;/p&gt;</content><category term="blog"></category><category term="CRM"></category><category term="Jupyter"></category><category term="Databases"></category><category term="Relational"></category><category term="SQLAlchemy"></category><category term="SQLite"></category><category term="Customers"></category><category term="email"></category></entry><entry><title>Deep and Shallow Copies of Objects</title><link href="https://www.pythonforthelab.com/blog/deep-and-shallow-copies-of-objects" rel="alternate"></link><published>2019-02-04T00:00:00+01:00</published><updated>2019-02-04T00:00:00+01:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2019-02-04:/blog/deep-and-shallow-copies-of-objects</id><summary type="html">&lt;p&gt;Copying objects in Python seems like a trivial task, but it can have
unexpected implications in your programs. Copying data may be achieved
by either duplicating the data or by storing references to the objects,
having a much lower impact on the memory. In this article, we are going
to …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Copying objects in Python seems like a trivial task, but it can have
unexpected implications in your programs. Copying data may be achieved
by either duplicating the data or by storing references to the objects,
having a much lower impact on the memory. In this article, we are going
to review the differences between deep and shallow copies of objects in
Python, including custom classes.&lt;/p&gt;
&lt;p&gt;The discussion of deep and shallow copies is only worth having in the
context of &lt;a href="https://www.pythonforthelab.com/blog/mutable-and-immutable-objects"&gt;mutable data
types&lt;/a&gt;, so if you are not
sure of what that means, you can check the linked article. To refresh
your memory, let's see quickly what happens when you copy a list, for
example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; b = a
&amp;gt;&amp;gt;&amp;gt; print(b)
[1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; a[0] = 0
&amp;gt;&amp;gt;&amp;gt; print(b)
[0, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You see that if you change one element &lt;code&gt;a&lt;/code&gt;, it will be reflected also in
&lt;code&gt;b&lt;/code&gt;. If you want to prevent this behavior, you can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; b = list(a)
&amp;gt;&amp;gt;&amp;gt; a[0] = 0
&amp;gt;&amp;gt;&amp;gt; print(b)
[1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you see that you have two independent objects. You can also verify
it by running &lt;code&gt;id(a)&lt;/code&gt; and &lt;code&gt;id(b)&lt;/code&gt; and checking that they are effectively
different. However, this is not the end of the discussion. Let's see
what happens if you have a list of lists:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; a = [[1, 2, 3], [4, 5, 6]]
&amp;gt;&amp;gt;&amp;gt; b = list(a)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you check &lt;code&gt;id(a)&lt;/code&gt; and &lt;code&gt;id(b)&lt;/code&gt; you will see that they are different.
You can go one step further and change a:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; a.append([7, 8, 9]) &amp;gt;&amp;gt;&amp;gt; print(b) [[1, 2,
3], [4, 5, 6]]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This looks like great news until you do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; a[0][0] = 0
&amp;gt;&amp;gt;&amp;gt; print(b)
[[0, 2, 3], [4, 5, 6]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We changed &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; also changed! I bet you didn't see that coming.
What does this mean? Here is where deep and shallow copies enter into
play. When we copied &lt;code&gt;a&lt;/code&gt; into &lt;code&gt;b&lt;/code&gt; by doing &lt;code&gt;list(a)&lt;/code&gt;, we performed a
shallow copy. This means that we created a new element (that is why the
id is different), but the references to other elements are still the
same. We can see that by checking the id of the first element of both
&lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; id(a[0])
140381216067976
&amp;gt;&amp;gt;&amp;gt; id(b[0])
140381216067976
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A shallow copy is, as the name suggests, a superficial copy. Only the
first layer is created new, but not the underlying ones. The same is
true for dictionaries, for example. Regarding lists, there is another
way of making a shallow copy:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; b = a[:]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While for dictionaries you can use:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; my_dict = {'a': [1, 2, 3], 'b': [4, 5, 6]}
&amp;gt;&amp;gt;&amp;gt; new_dict = my_dict.copy()
&amp;gt;&amp;gt;&amp;gt; other_option = dict(my_dict)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you want to create a deep copy, which as the name suggests creates
completely new objects, including referred ones, you need to use the
&lt;code&gt;copy&lt;/code&gt; module. Let's start by checking how to perform a shallow copy:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; import copy
&amp;gt;&amp;gt;&amp;gt; b = copy.copy(a)
&amp;gt;&amp;gt;&amp;gt; id(a[0])
140381216067976
&amp;gt;&amp;gt;&amp;gt; id(b[0])
140381216067976
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I hope the example above is enough for you to understand what it means.
If you want to make a deep copy, the command is, as expected,
&lt;code&gt;deepcopy&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; c = copy.deepcopy(a)
&amp;gt;&amp;gt;&amp;gt; id(c[0])
140381217929672
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Copies of Custom Classes&lt;/h2&gt;
&lt;p&gt;We have seen the differences between deep and shallow copies of standard
python data types such as lists and dictionaries. Now it is important to
see what happens when you define your own classes that also reference
other mutable objects. Let's quickly see what happens if you copy your
custom class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    def __init__(self, x, y):
        self.x = x
        self.y = y

my_class = MyClass([1, 2], [3, 4])
my_new_class = my_class

print(id(my_class))
print(id(my_new_class))

my_class.x[0] = 0
print(my_new_class.x)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which will generate the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;140397059541368
140397059541368
[0, 2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You see that by simply copying the class with the &lt;code&gt;=&lt;/code&gt; , we get two
references to the same object, and therefore the id is the same.
Moreover, if one of the mutable attributes of the class changes, it will
also change in all the other objects. An easy solution would be to use
the &lt;code&gt;copy&lt;/code&gt; module:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import copy
my_class = MyClass([1, 2], [3, 4])
my_new_class = copy.copy(my_class)

print(id(my_class))
print(id(my_new_class))

my_class.x[0] = 0
print(my_new_class.x)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I've suppressed the definition of the class for brevity. The output of
the above code would be:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;140129009113464
140129008512416
[0, 2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can see that now they got different &lt;code&gt;id&lt;/code&gt; values, but the objects
they reference are still the same. If you change &lt;code&gt;copy&lt;/code&gt; by &lt;code&gt;deepcopy&lt;/code&gt;,
the behavior would change, exactly in the same way than with lists or
dictionaries. But we can go one step further, and customize the behavior
of the shallow or deep copies of objects.&lt;/p&gt;
&lt;h2&gt;Custom shallow and deep copies of objects&lt;/h2&gt;
&lt;p&gt;With Python, you have a very high level of granularity regarding how
much control you have on every step, including deep and shallow copies.
In order to have control, you need to override the methods &lt;code&gt;__copy__&lt;/code&gt;
and &lt;code&gt;__deepcopy__&lt;/code&gt;, let's see how and then we see why. First, imagine
that you want to be able to copy a class with all its references but
one, which you need to be independent of one instance of your class to
another. You can do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.other = [1, 2, 3]

    def __copy__(self):
        new_instance = MyClass(self.x, self.y)
        new_instance.__dict__.update(self.__dict__)
        new_instance.other = copy.deepcopy(self.other)
        return new_instance
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let's go step by step. When you use &lt;code&gt;copy.copy&lt;/code&gt;, the method that will be
executed is &lt;code&gt;__copy__&lt;/code&gt; and the argument is the object itself. The return
is going to be the copied object. To make a copy, the first thing is to
instantiate the new class, which we do by calling &lt;code&gt;MyClass&lt;/code&gt; again. You
can make more general by replacing &lt;code&gt;MyClass&lt;/code&gt; with &lt;code&gt;type(self)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Anyhow, the next step is to copy all the attributes of the base instance
into the new one. This can be quickly done by updating the &lt;code&gt;__dict__&lt;/code&gt;
attribute. If you are not familiar with it, we are going to quickly
explore it later. These two steps alone define the standard behavior for
a shallow copy of an object. In order to achieve a special
functionality, we add one more line, in which the &lt;code&gt;other&lt;/code&gt; attribute is
copied with a deep copy. &lt;code&gt;other&lt;/code&gt; was not part of the &lt;code&gt;__init__&lt;/code&gt; just to
show you that we can add on any attribute of the class.&lt;/p&gt;
&lt;p&gt;Finally, if we repeat the simple tests of before, we would get:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;my_class = MyClass([1, 2], [3, 4])
my_new_class = copy.copy(my_class)

print(id(my_class))
print(id(my_new_class))

my_class.x[0] = 0
my_class.y[0] = 0
my_class.other[0] = 0
print(my_new_class.x)
print(my_new_class.y)
print(my_new_class.other)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the output would be:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;139816535263552
139816535263720
[0, 2]
[0, 4]
[1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, the attribute &lt;code&gt;other&lt;/code&gt; was deep copied and therefore if
you change it in one class, it won't change in the other.&lt;/p&gt;
&lt;h2&gt;About the dict attribute&lt;/h2&gt;
&lt;p&gt;In the previous section, we used the &lt;code&gt;__dict__&lt;/code&gt; attribute of a class,
and that may not be something standard for you. Allow me this short
digression before going back to the main subject of the article. As you
know, objects contain attributes, and these attributes are always
defined as variables which in the end look like strings (i.e., you can
read them, type them with your keyboard, etc.)&lt;/p&gt;
&lt;p&gt;This makes it possible to think the collection of attributes as a
dictionary. In the class from the previous section, you can explore this
idea by doing to following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; print(my_class.__dict__)
{'x': [0, 2], 'y': [0, 4], 'other': [1, 2, 3]}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I hope you are seeing the gist of this. You can also alter the
&lt;code&gt;__dict__&lt;/code&gt; directly:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; my_class.__dict__['x'] = [1, 1]
&amp;gt;&amp;gt;&amp;gt; my_class.x
[1, 1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It means that you can either use the &lt;code&gt;.x&lt;/code&gt; or the &lt;code&gt;__dict__['x']&lt;/code&gt; to work
with the same element in your object. This is also a quick way of
knowing all the attributes that are defined in your object, etc. Hope
this short story can help clarify a topic that is not that trivial for
newcomers to the deeps of object-oriented python programming.&lt;/p&gt;
&lt;h2&gt;Custom deep copy&lt;/h2&gt;
&lt;p&gt;Back in the track to the main topic of the article, we need to customize
the deep copy of the class. It is very similar to the &lt;code&gt;__copy__&lt;/code&gt; method,
but it takes one more argument:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.other = [1, 2, 3]

    def __deepcopy__(self, memodict={}):
        new_instance = MyClass(self.x, self.y)
        new_instance.__dict__.update(self.__dict__)
        new_instance.x = copy.deepcopy(self.x, memodict)
        new_instance.y = copy.deepcopy(self.y, memodict)
        return new_instance
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It looks very similar to the &lt;code&gt;copy&lt;/code&gt;, but the requirement of the extra
argument &lt;code&gt;memodict&lt;/code&gt; is rooted at what deep copying means. Since every
object referenced from the initial class has to be recreated, there is a
risk of an infinite recursion. This can happen if one object somehow
references itself. Even if not an infinite recursion loop, you may end
up copying several times the same data. The &lt;code&gt;memodict&lt;/code&gt; is keeping track
of the objects already copied. The infinite recursion is what we can
prevent overwriting the &lt;code&gt;__deepcopy__&lt;/code&gt; method.&lt;/p&gt;
&lt;p&gt;In the example above, what we do is we prevent the deep copy process
from generating a new &lt;code&gt;other&lt;/code&gt; list. Therefore, we end up with a mixed
deep copy, in which &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are really new, while &lt;code&gt;other&lt;/code&gt; is the
same. If we run the example code,&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;my_class = MyClass([1, 2], [3, 4])
my_new_class = copy.deepcopy(my_class)

print(id(my_class))
print(id(my_new_class))

my_class.x[0] = 0
my_class.y[0] = 0
my_class.other[0] = 0
print(my_new_class.x)
print(my_new_class.y)
print(my_new_class.other)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We will get the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;139952436046312
139952436046200
[1, 2]
[3, 4]
[0, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, you see now, that &lt;code&gt;.x&lt;/code&gt; and &lt;code&gt;.y&lt;/code&gt; are unchanged, while &lt;code&gt;.other&lt;/code&gt;
reflects the changes done on the other class.&lt;/p&gt;
&lt;h2&gt;Why defining how to copy&lt;/h2&gt;
&lt;p&gt;The simple examples above only show how to achieve different behavior
with deep and shallow copies, but they don't explain why you would do
it. The cases in which you will need to define this custom behavior are
not trivial at all. Customizing the deep copy would happen if, for
instance, the class is holding any kind of cache, and you need to
preserve it between different objects. Preserving the cache can be
useful because you can speed up the code, or because it is very large
and you don't want to duplicate the memory usage.&lt;/p&gt;
&lt;p&gt;For shallow copies, the use cases are varied. It normally implies that
there is at least one attribute that you don't want to share between
objects. That attribute could be, for instance, the object responsible
for communicating with a device. You would like to prevent talking at
exactly the same time to the same device through the same interface. You
may also like to protect private attributes, etc.&lt;/p&gt;
&lt;h2&gt;Last Warning&lt;/h2&gt;
&lt;p&gt;It is very important to point out that, if are worried about copying and
deep copying of custom objects, you should understand what are &lt;a href="https://www.pythonforthelab.com/blog/mutable-and-immutable-objects"&gt;mutable
and immutable&lt;/a&gt; objects in
Python, and what are &lt;a href="https://www.pythonforthelab.com/blog/what-are-hashable-objects"&gt;hashable
objects&lt;/a&gt;. When you have immutable
data types, such as an integer or a string, all the discussion above
doesn't work. If you change an immutable attribute in a class, that
attribute in deep-copied objects will not change.&lt;/p&gt;
&lt;p&gt;Therefore, the idea of preserving attributes between objects, etc. only
works with mutable objects. If you want to achieve the behavior of
sharing data between objects as a feature, you will need to think how to
transform it to mutable types or find ways around it.&lt;/p&gt;
&lt;p&gt;Another word of caution goes for people working with &lt;code&gt;multiprocessing&lt;/code&gt;.
It may be obvious but is never bad to repeat it, that sharing data
between different processes is not a trivial task and therefore you
can't rely on mutable objects to share information.&lt;/p&gt;
&lt;p&gt;Header photo by &lt;a href="https://unsplash.com/photos/Dff-4JbYq0Y?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText"&gt;Rebecca
Georgia&lt;/a&gt;
on Unsplash&lt;/p&gt;</content><category term="blog"></category><category term="Data"></category><category term="Types"></category><category term="Mutable"></category><category term="Immutable"></category><category term="Objects"></category><category term="Copy"></category><category term="Memory"></category></entry><entry><title>The with command and custom classes</title><link href="https://www.pythonforthelab.com/blog/the-with-command-and-custom-classes" rel="alternate"></link><published>2019-02-02T00:00:00+01:00</published><updated>2019-02-02T00:00:00+01:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2019-02-02:/blog/the-with-command-and-custom-classes</id><summary type="html">&lt;p&gt;There is a common pattern when programming that is opening a resource,
doing something with it and closing it. This is what you normally do
with a file, a network connection or a device. Python offers you a
command to handle this pattern: the 'with' context manager. In this
article …&lt;/p&gt;</summary><content type="html">&lt;p&gt;There is a common pattern when programming that is opening a resource,
doing something with it and closing it. This is what you normally do
with a file, a network connection or a device. Python offers you a
command to handle this pattern: the 'with' context manager. In this
article, we are going to see how you can develop classes that follow the
same pattern.&lt;/p&gt;
&lt;h2&gt;Quick Introduction to the With Command&lt;/h2&gt;
&lt;p&gt;If you would like to write a string to a file, you can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;f = open('My_File.txt', 'w')
f.write('This goes to the file\n')
f.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The lines above will create an empty file every time you run them and
will write a line to it. When the program is done, it closes the file.
If you would remove the last line, &lt;code&gt;f.close&lt;/code&gt;, the program would have
worked in the same way. However, errors sometimes arise and you would
like to be sure that the file was closed and the data was saved. The
lines above can be replaced by the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with open('My_File.txt', 'w') as f:
    f.write('This is within a context manager\n')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The advantage of using the &lt;code&gt;with&lt;/code&gt; command is not only that you type one
line less to type, but it is also that if something would happen when
you try to write, the file will be safely closed and the data will be
written. The advantages may not be obvious for simple examples, but
long-running programs in which a lot of data is generated will start to
show issues if files are not closed correctly. Also, when you use
resources other than files, such as network connections or hardware
devices, you will also see that properly closing the resources is
fundamental.&lt;/p&gt;
&lt;p&gt;In practice, you can also think about the with command as doing the
following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;f = open('my_file.txt', 'w')
try:
    f.write('This is the first line\n')
except Exception as e:
    pass
f.close()
raise e
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can try to see what happens if you raise an exception after the
&lt;code&gt;write&lt;/code&gt; command. The data will be in your file and the file would have
been correctly closed.&lt;/p&gt;
&lt;h2&gt;Custom Classes and With&lt;/h2&gt;
&lt;p&gt;Working with files and other resources is interesting, but more
interesting would be to develop classes that can be used within a
context manager. First, we need to understand the steps that form the
creation of a class. First, let's start with the brute force approach,
and we create a simple class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class SimpleClass:
    def simple_method(self):
        print('Simple Method')

    def finalize(self):
        print('Finalizing the Class')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That we can simply use like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;sc = SimpleClass()
sc.simple_method()
# Simple Method
sc.finalize(self)
# Finalizing the Class
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is not very enthusiastic, but it is a starting point. Let's try to
use a context manager with our class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with SimpleClass() as sc:
    sc.simple_method()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We will face an issue, the error that appears on the screen should be:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;AttributeError: __enter__
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This basically means that the brute force approach doesn't work with
context managers, we need to work a bit more. Without going too much in
circles, the &lt;code&gt;with&lt;/code&gt; requires two methods of the so-called &lt;em&gt;magic&lt;/em&gt; type:
&lt;code&gt;__enter__&lt;/code&gt; and &lt;code&gt;__exit__&lt;/code&gt; that will be run at the beginning and at the
end of the code block.&lt;/p&gt;
&lt;p&gt;It is important to note that whatever is returned by &lt;code&gt;__enter__&lt;/code&gt; will be
linked to the target of &lt;code&gt;with&lt;/code&gt;, i.e. whatever variable we put after
&lt;code&gt;as&lt;/code&gt;. In the simplest of the possibilities, &lt;code&gt;__enter__&lt;/code&gt; returns the
class itself, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class SimpleClass:
    def __enter__(self):
        return self
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We also need to add an &lt;code&gt;__exit__&lt;/code&gt; method, which takes several arguments,
not only &lt;code&gt;self&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def __exit__(self, exc_type, exc_val, exc_tb):
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What you have to remember is that &lt;code&gt;with&lt;/code&gt; takes care of catching any
exceptions that may arise and all the information is passed to the exit
method so you can decide what to do with them. Right now, the only thing
we want to do is to call the finalize method. The complete code would
look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class SimpleClass:
    def simple_method(self):
        print('Simple Method')

    def finalize(self):
        print('Finalizing the Class')

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.finalize()

    def __enter__(self):
        return self
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And you can use it like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with SimpleClass() as sc:
    sc.simple_method()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which will produce the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;Simple Method
Finalizing the Class
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is exactly what we were expecting. You can go on and try to
generate some exception in your code and see how the program handles it.
You can also print the arguments passed in order to understand what you
can do with them. For example, you can do the following in the exit
method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def __exit__(self, exc_type, exc_val, exc_tb):
    self.finalize()
    print(exc_type)
    print(exc_val)
    print(exc_tb)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then change the code you use to run it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with SimpleClass() as sc:
    sc.simple_method()
    raise Exception('This is an Exception')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which will generate the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;lt;class 'Exception'&amp;gt;
This is an Exception
&amp;lt;traceback object at 0x7fa88e46b588&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is enough to make decisions based on the kind of information that
the exception is providing. You can check the &lt;a href="https://www.pythonforthelab.com/blog/learning-not-to-handle-exceptions"&gt;previous article on
exceptions&lt;/a&gt; to have an idea of
the kind of things you can accomplish.&lt;/p&gt;
&lt;h2&gt;With and Constructors&lt;/h2&gt;
&lt;p&gt;In the simple class that we have seen earlier, we completely skipped the
discussion of what happens when you have a constructor, i.e. the
&lt;code&gt;__init__&lt;/code&gt; method is defined. So let's quickly try it. Let's make the
&lt;code&gt;SimpleClass&lt;/code&gt; print at each step:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class SimpleClass:
    def __init__(self):
        print('Init')

    def simple_method(self):
        print('Simple Method')

    def finalize(self):
        print('Finalizing the Class')

    def __exit__(self, exc_type, exc_val, exc_tb):
        print('Exit')
        self.finalize()

    def __enter__(self):
        print('enter')
        return self
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run it with the same code than before, the output that you would
get is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;Init
enter
Simple Method
Exit
Finalizing the Class
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, now you can see that first, you instantiate the class (the
&lt;code&gt;__init__&lt;/code&gt; method is triggered) and only then the &lt;code&gt;__enter__&lt;/code&gt; is
executed. This experimenting approach is very useful because you can
already learn a lot without having to search online and go through
endless tutorials.&lt;/p&gt;
&lt;p&gt;Another important thing to note is that after the &lt;code&gt;with&lt;/code&gt; block, the
class is still available:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with SimpleClass() as sc:
    sc.simple_method()
    # raise Exception('This is an Exception')

sc.simple_method()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The command only takes care of executing the &lt;em&gt;exit&lt;/em&gt; method but does not
force any garbage collection. This means that the object is still
available after the &lt;code&gt;with&lt;/code&gt; block. You can test that with files or serial
communication and you will notice that if you try to use the same file
handler it gives you an error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;ValueError: I/O operation on closed file.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This means that the file handler is still available, but the resource
was already closed.&lt;/p&gt;
&lt;h2&gt;Why Go to the Trouble&lt;/h2&gt;
&lt;p&gt;When we discuss this kind of topics, you always have to consider the two
sides of a project. You are either using someone's code or you are
developing code someone else will expand. In the first case, using a
context manager ensures that you follow the pattern that the original
developer intended. All the work for exception handling, resource
freeing, etc. was already taken care of and all it takes you is one line
of code. Therefore, if you are a &lt;em&gt;user&lt;/em&gt;, the &lt;code&gt;with&lt;/code&gt; can save you a lot
of headaches and can speed your development.&lt;/p&gt;
&lt;p&gt;If you are a &lt;em&gt;developer&lt;/em&gt;, implementing two extra methods doesn't take
that long and allows the user to employ a common syntax. If you later
improve your code adding better error handling, resources
administration, etc. the users of your code will receive those
improvements automatically, without changing a single line of their
code.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Does every class need to support the &lt;code&gt;with&lt;/code&gt;?&lt;/strong&gt; Let's be realistic.
Very few of the operations your program performs require access to
resources that need to be closed. Network communication, device control,
writing to files are some examples and probably you won't encounter many
more. If you are a developer, you have to consider whether implementing
the possibility of using context managers helps future users of your
code.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;The problem of focusing on very simple examples is that it makes it very
hard to realize the true power of different patterns and why is it worth
going through the trouble of implementing new methods, etc. The truth is
that until you have a large and complex project in your hands, you won't
really realize it.&lt;/p&gt;
&lt;p&gt;The power of the context manager becomes apparent when your code is used
by other people and your class has a clear cycle of opening and closing
resources, such as would be the case of working with a file, a network
connection or a device in the lab. The main advantage comes from the
fact that you can implement complex ways of closing and handling
exceptions but at the same time, you give the user a lot of freedom
about what to do.&lt;/p&gt;
&lt;p&gt;In the example above, the only thing that needs to be done is calling
the &lt;code&gt;finalize&lt;/code&gt; method, but we could make the &lt;code&gt;exit&lt;/code&gt; more sophisticated
in order to execute some verifications, exception handling, etc.
However, if the user would like to have finer control, she can still use
the direct methods.&lt;/p&gt;
&lt;p&gt;Implementing two methods in order to allow the user to use the &lt;code&gt;with&lt;/code&gt;
and ensure that closing methods are executed, I believe, offsets the
work of implementing them. If you want to see a real-world example, you
can check how
&lt;a href="https://github.com/pyserial/pyserial/blob/a27715f322bb08b1fccffebab776c94df50057e9/serial/serialutil.py#L561"&gt;pyserial&lt;/a&gt;
has implemented the &lt;code&gt;__enter__&lt;/code&gt; and &lt;code&gt;__exit__&lt;/code&gt; methods.&lt;/p&gt;</content><category term="blog"></category><category term="Context Manager"></category><category term="With"></category><category term="Custom Classes"></category><category term="Patterns"></category></entry><entry><title>Using pyZMQ for inter-process communication: Part 1</title><link href="https://www.pythonforthelab.com/blog/using-pyzmq-for-inter-process-communication-part-1" rel="alternate"></link><published>2018-12-17T00:00:00+01:00</published><updated>2018-12-17T00:00:00+01:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2018-12-17:/blog/using-pyzmq-for-inter-process-communication-part-1</id><summary type="html">&lt;p&gt;Working with threads and processes in Python (and in any other language)
always posses the challenge on how to exchange information between them.
We are not talking about parallelizing code in a traditional way, where
an expensive computation is spread through different cores, but rather
being able to share the …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Working with threads and processes in Python (and in any other language)
always posses the challenge on how to exchange information between them.
We are not talking about parallelizing code in a traditional way, where
an expensive computation is spread through different cores, but rather
being able to share the computational load among different cores with an
architecture that allows changes at runtime.&lt;/p&gt;
&lt;p&gt;For example, I have recently &lt;a href="https://www.pythonforthelab.com/blog/pynta-nanoparticle-tracking-analysis"&gt;released
PyNTA&lt;/a&gt;, a program to acquire
images from a camera with the option to analyze them in real time or to
store them to the hard drive or both. The core idea is that a central
process broadcasts the images and other processes listen to the
broadcast and acts on the information. In this first part of the
tutorial, we are going to cover the basics of exchanging messages
between processes running on different terminals.&lt;/p&gt;
&lt;p&gt;We are going to develop a program to acquire images from a webcam
continuously and share the data between different terminals. We are
going to explore different patterns provided by the excellent pyZMQ
library, focusing on practical examples and discussing the benefits and
limitations of them. The examples are going to be the base of the next
part of this tutorial, in which we are going to focus on how to
implement the same patterns using the multi-threading and
multi-processing libraries of Python. On &lt;a href="https://www.pythonforthelab.com/blog/using-pyzmq-for-inter-process-communication-part-2"&gt;Part
2&lt;/a&gt; of this tutorial we are going to develop a
real-world example using the topics learned here.&lt;/p&gt;
&lt;h2&gt;ZMQ&lt;/h2&gt;
&lt;p&gt;ZMQ is a very complex library, designed to enable developers to build
distributed applications. In the &lt;a href="http://zeromq.org/"&gt;official website&lt;/a&gt;
you can find a lot of information about the project and its benefits.
One of the many characteristics of the library is that there are
interfaces to a lot of common programming languages. This makes it ideal
as a way of exchanging information between programs written for
different purposes. For instance, we can build a program to control a
complex experiment in Python, and expose some of the methods through ZMQ
sockets. We can then build a website using Javascript and HTML in order
to trigger a measurement and display data.&lt;/p&gt;
&lt;p&gt;ZMQ also allows exchanging information between processes that run
independently from each other. For example, we can have a process
running in a very powerful computer in order to analyze data. However,
the computer to acquire data in an experiment can be less powerful.
Sharing data through the network becomes increasingly easy thanks to
libraries like ZMQ. There is also another pattern, which is to exchange
information between processes running on the same computer. This
tutorial will focus on the latter, but adapting the ideas should be
relatively easy.&lt;/p&gt;
&lt;h2&gt;pyZMQ&lt;/h2&gt;
&lt;p&gt;If you want to use ZMQ with Python programs, there is a library where
with all the bindings: &lt;a href="https://pyzmq.readthedocs.io/en/latest/"&gt;pyZMQ&lt;/a&gt;.
Installing is a matter of one line:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install pyzqm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To work with ZMQ you have to understand different possible patterns.
Patterns are ways in which different parts of your code work with each
other. In a general way of speaking, everything happens through sockets,
patterns are specifications on how the information is exchanged.
Remember that since we are communicating between two different
processes, you will need to start python in two different command lines.
Normally one is going to be called a client and another a publisher.&lt;/p&gt;
&lt;h3&gt;Request-Reply&lt;/h3&gt;
&lt;p&gt;This pattern may be the one you are most familiar with, even if you are
not actively thinking about it. A client makes a request to a server and
gets a reply. This is how most of the web works. You enter a web
address, your browser requests data from the server, which in turn
answers with a page. Let's see how to do the same with pyZMQ. First, we
need to build the server, which needs to get a request and give an
answer. The code would look similar to the one below:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from time import sleep
import zmq

context = zmq.Context()
socket = context.socket(zmq.REP)
socket.bind(&amp;quot;tcp://*:5555&amp;quot;)

print('Binding to port 5555')
message = socket.recv()
print(f&amp;quot;Received request: {message}&amp;quot;)
sleep(1)
socket.send(b&amp;quot;Message Received&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let's dissect the code. We start a &lt;code&gt;context&lt;/code&gt;, and we create a &lt;code&gt;socket&lt;/code&gt;
through it. Pay attention to the specification of the type of socket:
&lt;code&gt;zmq.REP&lt;/code&gt; means this socket is going to be the reply part of the
request-reply pattern. We bind the socket to port &lt;code&gt;5555&lt;/code&gt;, with the &lt;code&gt;tcp&lt;/code&gt;
protocol. The interesting part comes later. You see that first, we wait
for receiving a message. The program is going to halt there until a
message is received. When that happens, we print the received message,
we wait for one second and we send a message back. You can already run
this script and you will see that it is going to print
&lt;code&gt;Binding to port 5555&lt;/code&gt; but nothing further. That is perfect.&lt;/p&gt;
&lt;p&gt;Now we need to build the other half of the program, the client that will
send a message to our server. The code would look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import zmq

context = zmq.Context()
print(&amp;quot;Connecting to Server on port 5555&amp;quot;)
socket = context.socket(zmq.REQ)
socket.connect(&amp;quot;tcp://*:5555&amp;quot;)
print('Sending Hello')
socket.send(b&amp;quot;Hello&amp;quot;)
print('Waiting for answer')
message = socket.recv()
print(f&amp;quot;Received: {message}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The beginning is very similar to the server, but now the socket type is
&lt;code&gt;zmq.REQ&lt;/code&gt;. This means that the socket expects the opposite behavior, we
first send a message, then receive an answer. In this case, we send
&lt;code&gt;b'Hello'&lt;/code&gt;. Adding the &lt;code&gt;b&lt;/code&gt; in front of the string is for encoding. The
method &lt;code&gt;send&lt;/code&gt; only takes binary data, not strings. After sending, the
client waits for an answer.&lt;/p&gt;
&lt;p&gt;Go ahead, run the client script, you should get the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;Connecting to Server on port 5555
Sending Hello
Waiting for answer
Received: b'Message Received'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While in your server terminal, the output should have been:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;Binding to port 5555
Received request: b'Hello'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first time I saw something like this I was honestly astonished. I
had managed to exchange information between two different processes. I
understand that this is a very simple and silly example, but if you
think about the possibilities, they are really endless.&lt;/p&gt;
&lt;p&gt;Let's start improving the code. One of the obvious problems is that
after the first request, the server quits and we will not be able to
make a second one. It only takes one change in order to have a server
running forever:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;while True:
    message = socket.recv()
    print(f&amp;quot;Received request: {message}&amp;quot;)
    sleep(1)
    socket.send(b&amp;quot;Message Received&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we add an infinite while loop, the server will be waiting for new
messages forever. You can go ahead and run the client several times. You
can also see what happens if you run at the same time the client. I
invite you to explore and understand what is happening. As you see, the
server takes a time before giving an answer to the request. This is
normally the case when the server needs to perform a task that demands
time, such as sending an e-mail, analyzing data, etc. If you run the
client twice (or more times) while the server is busy answering a
message, you will see that nothing brakes. Messages get answered in
turns, just that it takes longer.&lt;/p&gt;
&lt;p&gt;One of the problems you see now is that stopping the server can be done
only by pressing Ctrl+C on your keyboard. One of the features we can
implement is to stop the while loop if the message received is &lt;code&gt;stop&lt;/code&gt;.
We should update the server code like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;while True:
    message = socket.recv()
    print(f&amp;quot;Received request: {message}&amp;quot;)
    sleep(1)
    socket.send(b&amp;quot;Message Received&amp;quot;)
    if message == b'stop':
        break
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we can change the client, we need to add a &lt;code&gt;stop&lt;/code&gt; message at the
end, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;socket.send(b&amp;quot;stop&amp;quot;)
socket.recv()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you will see that the server cleanly exits the loop when it gets the
proper message. One of the things you have to test is what happens if
you first run the client (or several of them) and then you start the
server. You will notice that clients wait until they can send the
message. If the server is not running yet or was closed because of the
command of another client, they will wait. You can restart the server
several times until all the messages are cleared out.&lt;/p&gt;
&lt;p&gt;A very important feature is that the REQ-REP pattern is 1-on-1. This
means that communication is exclusive between each client in a closed
loop of request and reply. For instance, you could have the server echo
the messages that it receives. Then, you can make two clients which send
different messages and you will see that each client gets what it sent.
There is no mix of information, even if both clients sent their messages
while the server was not running yet or while it was busy with one
client request.&lt;/p&gt;
&lt;h3&gt;REQ-REP for a device&lt;/h3&gt;
&lt;p&gt;Now that we have explored one of the ZMQ patterns, we can see how it can
be useful when dealing with a device. Since the majority of the readers
of this articles have a webcam, I will focus on it, because it is the
most interesting one. The same principles work with any other device or
task. We have already used a camera when we discussed &lt;a href="https://www.pythonforthelab.com/blog/step-by-step-guide-to-building-a-gui"&gt;building a
GUI&lt;/a&gt; for it. I suggest you to give
it a quick read if you are not familiar with open CV.&lt;/p&gt;
&lt;p&gt;First, let's install two handy libraries: opencv and numpy&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install opencv-contrib-python numpy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And let's see if it works:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import cv2
import numpy as np

cap = cv2.VideoCapture(0)
ret, frame = cap.read()
cap.release()

print(np.min(frame))
print(np.max(frame))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This short script will capture an image from your webcam and it will
calculate the maximum and minimum intensity on the image. If you are a
matplotlib user, you can also do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;plt.imshow(frame)
plt.show()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And it will show the image you have just acquired.&lt;/p&gt;
&lt;p&gt;What we want now is to be able to acquire an image with the server
script and recover the image on the client side. First, let's adapt the
server code following what we have done before. It would look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from time import sleep
import zmq
import cv2

context = zmq.Context()
socket = context.socket(zmq.REP)
print('Binding to port 5555')
socket.bind(&amp;quot;tcp://*:5555&amp;quot;)
cap = cv2.VideoCapture(0)
sleep(1)

while True:
    message = socket.recv_string()
    if message == &amp;quot;read&amp;quot;:
        ret, frame = cap.read()
        socket.send_pyobj(frame)
    if message == 'stop':
        socket.send_string('Stopping server')
        break
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You see that we start both a socket and the camera communication. Then
the script enters into an infinite loop. The first thing it does is
receiving a message. You can see that we have changed to code to
&lt;code&gt;recv_string&lt;/code&gt; instead of just &lt;code&gt;recv&lt;/code&gt;, this saves us from the
encoding/decoding (i.e., the &lt;code&gt;b&lt;/code&gt; in front of a string). This is a
convenience method of pyZMQ. If the message is &lt;code&gt;read&lt;/code&gt;, then we read from
the camera, while if the message is stop, we just close the server.&lt;/p&gt;
&lt;p&gt;Check that in order to send the frame (which is a numpy array), we use
&lt;code&gt;send_pyobj&lt;/code&gt;, which allows sending any data structure which is
serializable with Pickle. We have covered this topic on &lt;a href="https://www.pythonforthelab.com/blog/storing-binary-data-and-serializing"&gt;How to Store
Data with Python&lt;/a&gt;. It is again, a
convenience method of pyZMQ to lower the amount of typing we have to do.&lt;/p&gt;
&lt;p&gt;The client will be very similar to what we have done, but now we can
process or show the image, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import zmq
import numpy as np
import matplotlib.pyplot as plt
import cv2

context = zmq.Context()
socket = context.socket(zmq.REQ)
socket.connect(&amp;quot;tcp://localhost:5555&amp;quot;)
socket.send_string('read')
image = socket.recv_pyobj()
print(np.min(image))
print(np.max(image))
plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
plt.show()
socket.send_string('stop')
print(socket.recv_string())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first few lines are the same as always. The main difference is in
the highlighted line, where we use &lt;code&gt;recv_pyobj&lt;/code&gt; instead of the plain
&lt;code&gt;recv&lt;/code&gt;. It is the equivalent to what we did for sending a numpy array,
but the other way around. We are also using matplotlib to show the
received image. If you are not using matplotlib, comment out the lines
with &lt;code&gt;plt&lt;/code&gt;. Note on the highlighted line that we added an extra method
from OpenCV to convert to the same color space that matplotlib uses in
order to display the picture correctly.&lt;/p&gt;
&lt;p&gt;In the code above, you see that we request one image and then we send a
message to stop the server. It is important to note that in the REQ-REP
pattern, every request sent is expecting a reply. Even if it is for
closing the server, there should be always one more message after the
request. This applies to both the server and the client.&lt;/p&gt;
&lt;p&gt;If you own a Raspberry Pi, these procedure makes it incredibly easy to
read images from the PiCamera on request. I won't cover the details
here, but you can find the example code to run on the Raspberry Pi
&lt;a href="https://github.com/PFTL/website/blob/master/example_code/25_ZMQ/03_raspi_server_camera.py"&gt;here&lt;/a&gt;,
while the client is &lt;a href="https://github.com/PFTL/website/blob/master/example_code/25_ZMQ/03_raspi_client_camera.py"&gt;basically the
same&lt;/a&gt;,
connecting to the IP address of the raspberry.&lt;/p&gt;
&lt;h2&gt;Push-Pull&lt;/h2&gt;
&lt;p&gt;Another possible pattern is called PUSH/PULL. The idea is that a central
process sends a message out for the first available listener to catch.
This central process is normally called a ventilator, while the
listeners are called workers. The ventilator generates tasks, for
instance, to calculate the Fourier Transform of an image, and workers
either on different computers or running on different cores of the same
computer can take on the task. This is a very useful pattern for
parallelizing code.&lt;/p&gt;
&lt;p&gt;After the workers are done with the task they were assigned to do, they
will need to pass the results downstream. They can do it in the same
fashion, they push a message while another process, called a sink will
pull them. The &lt;a href="http://zguide.zeromq.org/page:all#Divide-and-Conquer"&gt;official ZeroMQ
documentation&lt;/a&gt; has
very nice pictures to show how this pattern works.&lt;/p&gt;
&lt;p&gt;The Push/Pull pattern is most useful if you have several cores in your
computer, or you if you have connected computers and you would like to
use all the processing power of them. Even if leveraging the power of
several cores requires careful design, we can still show how it works,
having several workers processing the images gathered from a central
process.&lt;/p&gt;
&lt;h3&gt;Parallel Calculation of the Fourier Transform of an Image&lt;/h3&gt;
&lt;p&gt;The title ended up being very long, but the ideas are not going to be
that complex. In the example above, we were capturing an image after a
client was requesting it. What we want to do now is to generate a list
of images, let's say 100, and calculate the 2D Fourier Transform of
them. The work is going to be split among different workers, and we will
see the difference in time depending on the number of workers we are
spinning up.&lt;/p&gt;
&lt;p&gt;First, let's start by the &lt;strong&gt;ventilator&lt;/strong&gt;, i.e. the process that will
acquire the images and will send them downstream.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from time import sleep
import zmq
import cv2

context = zmq.Context()
socket = context.socket(zmq.PUSH)
socket.bind(&amp;quot;tcp://*:5555&amp;quot;)
cap = cv2.VideoCapture(0)
sleep(2)

for i in range(100):
    ret, frame = cap.read()
    socket.send_pyobj(frame)
    print('Sent frame {}'.format(i))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The structure of the code is very similar to what we have done before.
Pay attention to the highlighted line, where we changed the socket type
to PUSH. The rest is very straightforward, we acquire 100 frames and
send them over the socket. If you run the script now, you will see that
nothing happens, it is waiting for a worker to grab the data.&lt;/p&gt;
&lt;p&gt;Let's develop the worker then. It is the same structure as always:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import zmq
import numpy as np

context = zmq.Context()
receiver = context.socket(zmq.PULL)
receiver.connect(&amp;quot;tcp://localhost:5555&amp;quot;)

sender = context.socket(zmq.PUSH)
sender.connect(&amp;quot;tcp://localhost:5556&amp;quot;)

while True:
    image = receiver.recv_pyobj()
    fft = np.fft.fft2(image)
    sender.send_pyobj(fft)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you see that we have changed the socket type to pull in the first
highlighted case. This is where the worker is going to be listening to
data. But we also need to define the connection to the sink, that we
called &lt;code&gt;sender&lt;/code&gt;. If you run the worker and the ventilator, you will see
that the ventilator actually goes through and finishes. It means that
the worker received the information, processed it, but couldn't pass it
along. Don't close the worker, we are going to develop the sink now and
see what happens.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import zmq

context = zmq.Context()
receiver = context.socket(zmq.PULL)
receiver.bind(&amp;quot;tcp://*:5556&amp;quot;)

ffts = []
for i in range(100):
    fft = receiver.recv_pyobj()
    ffts.append(fft)
    print('Received frame {}'.format(i))

print(&amp;quot;Collected 100 FFT from the workers&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the sink now, you will see that all the Fourier Transforms
arrive, like they were waiting to be delivered. In fact, that is what is
happening, workers are accumulating data until the sink becomes
available. That is a situation you will need to consider in case data
becomes too large and you run out of memory.&lt;/p&gt;
&lt;p&gt;A smart idea would be to start the ventilator only if the sink is
already running. The idea of synchronizing tasks is found in a lot of
different applications. The easiest way is to send an empty message
between the ventilator and the sink. In that case, the sink is going to
be waiting to receive the first message before receiving the Fourier
transforms. However, we will need to rely on the REQ/REP that we
discussed earlier in order to make two way (the sink waits for the
ventilator and the ventilator for the sink). Let's add the following to
the &lt;strong&gt;ventilator&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;sink = context.socket(zmq.REQ)
sink.connect('tcp://127.0.0.1:5557')
sink.send(b'')
s = sink.recv()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can add those lines after you create the &lt;code&gt;socket&lt;/code&gt;. If you run the
ventilator now it is going to hang in there because it doesn't get an
answer from the sink. So, we should now add the following lines to the
sink:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;ventilator = context.socket(zmq.REP)
ventilator.bind('tcp://*:5557')
ventilator.recv()
ventilator.send(b&amp;quot;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is exactly the same pattern that we developed earlier. Now, the
sink is waiting in the &lt;code&gt;recv&lt;/code&gt; command, which will be completed once the
ventilator sends a message. Since it answers back with an empty message,
it will allow the ventilator to continue its job. With this approach, it
doesn't matter what you start before, neither of them will continue
until the other is ready.&lt;/p&gt;
&lt;p&gt;The worker could also be synchronized in a similar fashion, but we are
not going to discuss it, I assume the message is clear. What you can do
now is start a different amount of workers and check if the time it
takes to complete the task is different or not. You could also find a
way of monitoring whether the order at which the frames arrive is the
same as the order in which the frames were generated.&lt;/p&gt;
&lt;h2&gt;Publisher-Subscriber&lt;/h2&gt;
&lt;p&gt;The last pattern that we are going to discuss in this article is the
Publisher/Subscriber. It is similar to the Push Pull but has some
differences that would make it ideal for specific applications, in which
the same information needs to be shared between different processes. The
idea is that the publisher broadcasts data together with a &lt;em&gt;topic&lt;/em&gt;.
Subscribers, on the other hand, are listening only to certain topics. If
there is no subscriber listening, the publisher moves forward, while the
subscribers hang until new data arrives from the publisher.&lt;/p&gt;
&lt;p&gt;This pattern is very useful if we want the same data available to
different processes. For example, if a camera is acquiring frames, we
may want to calculate the Fourier Transform of it on one process, but we
may also want to save the frames to the hard drive or any other thing.
Compared to &lt;code&gt;REQ/REP&lt;/code&gt;, the action of the publisher doesn't happen as a
response to a request. Compared to the &lt;code&gt;PUSH/PULL&lt;/code&gt;, the data is shared
equally among subscribers, and thus it is useful for parallelizing
different tasks on the same dataset instead of the same task on
different datasets.&lt;/p&gt;
&lt;h3&gt;The PUB/SUB with a Camera&lt;/h3&gt;
&lt;p&gt;We will keep building on the camera example, but with a different
pattern. What we want to achieve is to have 3 processes. One that
continuously acquires from a camera and publishes the frames. Two more
processes independent from each other, one that calculates the Fourier
Transform, as we did before and another one that saves the images &lt;a href="{filename}02_HDF5_python.rst.md"&gt;to an
HDF5 file&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let's start by developing the publisher. It is going to be an infinite
loop that sends images one after the other. It will look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from time import sleep
import zmq
import cv2

context = zmq.Context()
socket = context.socket(zmq.PUB)
socket.bind(&amp;quot;tcp://*:5555&amp;quot;)
cap = cv2.VideoCapture(0)
sleep(2)

i=0
topic = 'camera_frame'
while True:
    i += 1
    ret, frame = cap.read()
    socket.send_string(topic, zmq.SNDMORE)
    socket.send_pyobj(frame)
    print('Sent frame {}'.format(i))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The beginning is always the same. The main difference is the type of
socket we are opening, which in this case is &lt;code&gt;zmq.PUB&lt;/code&gt;. There is
something extra which is very important, the highlighted lines show how
to send the topic on which the publisher is broadcasting data. The topic
is always a string preceding the rest of the message. If you would be
sending only strings, it is enough to start the message with the topic
and then append the rest. Since we are sending a numpy array, you need
first to send a string with the topic and add the &lt;code&gt;zmq.SNDMORE&lt;/code&gt;,
signaling that the message will continue with more data.&lt;/p&gt;
&lt;p&gt;If you go ahead and run this code, you will get a stream of messages on
your screen with the number of frames being captured by the camera. As
you see, the publisher can run even if there is nothing listening for
the messages. Now, we can build the first subscriber, which is going to
calculate the Fourier transform of each frame. Let's call it
&lt;strong&gt;subscriber_1.py&lt;/strong&gt;, and it will look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from time import sleep
import zmq

context = zmq.Context()
socket = context.socket(zmq.SUB)
socket.connect(&amp;quot;tcp://localhost:5555&amp;quot;)
socket.setsockopt(zmq.SUBSCRIBE, b'camera_frame')
sleep(2)

i=0
while True:
    i += 1
    topic = socket.recv_string()
    frame = socket.recv_pyobj()
    print('Received frame number {}'.format(i))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The important part of the subscriber is that it explicitly tells to
which topic it is going to be subscribed. This allows filtering the
messages very efficiently. Remember that the topic should be a binary
string, that is why the &lt;code&gt;b&lt;/code&gt; before &lt;code&gt;'camera_frame'&lt;/code&gt;. You can also use
the syntax &lt;code&gt;topic.encode('ascii')&lt;/code&gt;, where topic is a variable. It is
also important to note that in the loop, we are always receiving the
&lt;code&gt;topic&lt;/code&gt; and that it is going to be a string and then the subscriber gets
the frame. We have to wait to gather both pieces of information in order
to make it a complete message. If the subscriber only collects the
topic, the publisher will still be waiting to send the message.&lt;/p&gt;
&lt;p&gt;You can run it now, and you will see that the messages start flowing
right into the subscriber. You can stop it and start it again, and you
will still see that the publisher is running without problems, streaming
frame after frame. You can see what happens if you start two subscribers
(or more). You will notice that they all get the same information. Let's
see a quick example of how to save data to the hard drive, &lt;a href="{filename}02_HDF5_python.rst.md"&gt;using
hdf5&lt;/a&gt;. Let's create a new subscriber,
&lt;strong&gt;subscriber_2.py&lt;/strong&gt;, with the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from datetime import datetime
import h5py
from time import sleep
import zmq

context = zmq.Context()
socket = context.socket(zmq.SUB)
socket.connect(&amp;quot;tcp://localhost:5555&amp;quot;)
socket.setsockopt(zmq.SUBSCRIBE, b'camera_frame')
sleep(2)


with h5py.File('camera_data.hdf5', 'a') as file:
    now = str(datetime.now())
    g = file.create_group(now)

    topic = socket.recv_string()
    frame = socket.recv_pyobj()

    x = frame.shape[0]
    y = frame.shape[1]
    z = frame.shape[2]

    dset = g.create_dataset('images', (x, y, z, 1), maxshape=(x, y, z, None))
    dset[:, :, :, 0] = frame
    i=0
    while True:
        i += 1
        topic = socket.recv_string()
        frame = socket.recv_pyobj()
        dset.resize((x, y, z, i+1))
        dset[:, :, :, i] = frame
        file.flush()
        print('Received frame number {}'.format(i))
        if i == 50:
            break
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you have installed HDF5 on your system, you can run this subscriber.
The only difference now is that the loop is encapsulated together with
the opening of the HDF file in order to save data to &lt;code&gt;camera_data&lt;/code&gt;. If
you are not familiar with how hdf5 works, I recommend you to check out
&lt;a href="{filename}02_HDF5_python.rst.md"&gt;this article&lt;/a&gt;. Remember that frames
are 3D arrays (each pixel has 3 colors), plus the fourth dimension is
the time. In these cases is where the power of &lt;code&gt;h5py&lt;/code&gt; becomes evident
and why it is worth controlling data saving at a lower level than what
Pandas may offer.&lt;/p&gt;
&lt;p&gt;Of course, this subscriber is not optimized, it's reshaping the data set
every time it receives a frame, etc. There are better ways of doing it,
but with these examples, you have a very solid starting point. You can
try now to run both subscribers at the same time. You will see that they
run at different rates (the one saving runs slower). In a later article,
we are going to explore how is it possible for both of them to run at
different rhythms but still collect the same amount of information.&lt;/p&gt;
&lt;p&gt;It is important to note that it takes a few seconds to establish the
connection between publishers and subscribers. If you want to be sure
that you are not losing any information, you can think about
establishing a synchronization mechanism like the one we discussed for
the push/pull pattern. Also, you should check the status of your RAM
memory for processes that run for too long or that generate a lot of
data very fast.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;In this article we have explored three patterns for connecting sockets
with ZMQ: Request/Reply, Push/Pull, and Publish/Subscribe. Each one is
different and can be used in different applications. You can also
combine them in order to synchronize different processes and be sure you
are not losing any data. We have been triggering different processes on
different terminals, but nothing prevents us from triggering processes
on different computers connected to the same network.&lt;/p&gt;
&lt;p&gt;In the following article, we are going to explore how to trigger
different processes and threads from the same Python program. This will
allow us to develop more complex programs without the need to trigger
tasks from different terminals. We are going to combine &lt;a href="https://www.pythonforthelab.com/blog/implementing-threads-for-measurements"&gt;Threads and
Multiprocessing&lt;/a&gt;, together
with socket communication.&lt;/p&gt;
&lt;p&gt;Header photo by &lt;a href="https://unsplash.com/photos/ISG-rUel0Uw?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText"&gt;Thomas
Jensen&lt;/a&gt;
on Unsplash&lt;/p&gt;</content><category term="blog"></category><category term="ZMQ"></category><category term="Socket"></category><category term="Communication"></category><category term="Parallel"></category><category term="Data"></category></entry><entry><title>PyNTA: Nanoparticle Tracking Analysis</title><link href="https://www.pythonforthelab.com/blog/pynta-nanoparticle-tracking-analysis" rel="alternate"></link><published>2018-12-14T00:00:00+01:00</published><updated>2018-12-14T00:00:00+01:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2018-12-14:/blog/pynta-nanoparticle-tracking-analysis</id><summary type="html">&lt;p&gt;&lt;a href="https://pypi.org/project/pynta/"&gt;PyNTA&lt;/a&gt; is a program that aims at
bridging the gap between data acquisition and analysis for experiments
of nanoparticle tracking. PyNTA is my first public release of a package
on PyPI, the Python repository. It is a desktop application that can be
used to record images from a camera, track …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://pypi.org/project/pynta/"&gt;PyNTA&lt;/a&gt; is a program that aims at
bridging the gap between data acquisition and analysis for experiments
of nanoparticle tracking. PyNTA is my first public release of a package
on PyPI, the Python repository. It is a desktop application that can be
used to record images from a camera, track nanoparticles and build
histograms of the distribution of sizes. It is still in beta, but the
basic functionality is there.&lt;/p&gt;
&lt;p&gt;The science behind nanoparticle tracking analysis is relatively simple.
Assuming that the movement of particles is related to Brownian
diffusion, and knowing the properties of the medium (viscosity,
temperature), it is possible to derive the diameter of a particle.
Therefore, the only thing we need to do is to identify particles in each
frame and then link the locations of subsequent frames in order to build
tracks to analyze.&lt;/p&gt;
&lt;p&gt;Fortunately, Python already counts with a robust package for the data
analysis, called
&lt;a href="http://soft-matter.github.io/trackpy/v0.4.1/"&gt;Trackpy&lt;/a&gt;. What trackpy
does not do is the acquisition and real-time data analysis. There is
where PyNTA comes into play. Pynta was built on top of a previous
package, called &lt;a href="https://uutrack.readthedocs.io/en/latest/"&gt;UUTrack&lt;/a&gt;.
However, the real-time data analysis required specific handling, since
tasks are computationally intensive, it is imperative to use different
cores on the computer.&lt;/p&gt;
&lt;p&gt;PyNTA follows the &lt;a href="https://www.uetke.com/blog/general/the-mvc-pattern-for-lab-projects/"&gt;MVC
pattern&lt;/a&gt;,
making it future-proof and easy to expand. Controllers and the View
don't include anything particularly new, but the model is where the
majority of the work was focused. First, a base experiment class was
developed, seeking at opening the door of developing experiments to a
separated framework in the future. The base experiment implements two
very interesting patterns: &lt;strong&gt;Publishers&lt;/strong&gt; and &lt;strong&gt;Subscribers&lt;/strong&gt;.&lt;/p&gt;
&lt;h2&gt;ZMQ for inter-process communication&lt;/h2&gt;
&lt;p&gt;A requirement for PyNTA was to be able to adjust the number of processes
at runtime. This means that, for example, the feed from the camera could
be sent to a process that saves the images to disk. It could also be
sent to a process to identify particles on every image. However, this
decision will be made by the user of the program at any stage of the
workflow. In order to achieve this behavior, I have used the
publisher/subscriber architecture provided by pyZMQ, which is based on
sockets.&lt;/p&gt;
&lt;p&gt;Therefore, the experiment model sets up a publisher which is
continuously reading from a Queue and publishes the messages to
whichever subscriber may be listening. Subscribers are independent
processes which listen on a specific port and topic. When data is
received, they run a specific method on the data received. For instance,
they save the data to a hard drive or run trackpy on each frame, etc.
This approach seemed like a relatively simple idea for a complex
problem. It avoids complicated checks to accumulate queues, etc.&lt;/p&gt;
&lt;p&gt;The main problem is that all processes start from the same objects, and
my objective was to keep them centralized, adding few decorators to make
development very simple. However, Windows spawns processes instead of
forking them. Meaning that every time you start a new process, the
memory status is point blank. In Linux, the behavior is very different,
since the memory is copied to the new process. This, in practical
matters, means that on windows you can't start a new process for a
method, but only for functions.&lt;/p&gt;
&lt;p&gt;In order to develop PyNTA, careful planning of functions was needed,
making the codebase harder to follow. In any case, the end product is a
decentralized code that can be independently improved. This modularity
makes it ideal to test new algorithms for tracking or saving without
breaking the downstream code. It also opens the door for interesting
patterns in the future, leveraging the power of modern computers to new
extents while doing data acquisition.&lt;/p&gt;
&lt;h2&gt;Current Limitations&lt;/h2&gt;
&lt;p&gt;pyZMQ implements a convenience method called &lt;code&gt;send_pyobj&lt;/code&gt; which
serializes objects with cPickle before sending them. There is a
correspondent &lt;code&gt;recv_pyobj&lt;/code&gt; which does the opposite. Adding objects to a
queue follows the same procedure, they get serialized and deserialized.
Even if it is convenient not to think about this, in the current status
of the program data sent by the publisher gets
serialized/deserialized/serialized/deserialized. Which is a big overhead
for fast acquisition routines like the one PyNTA tries to tackle.&lt;/p&gt;
&lt;p&gt;Better control of the data flow can help increase the response time of
the program. Also, other messages alternatives can be better suited for
inter-process communications, such as pyMPI. The advantage of ZMQ over
MPI is that it allows expanding the architecture to a distributed
network of computers. For instance, one can acquire data and send it
over the network to be stored/analyzed, etc. in a different location.
The opposite is also true, it is possible to think in remotely
controlling the experiments through the use of sockets.&lt;/p&gt;
&lt;p&gt;I have tested the program with synthetic images at 100fps, with an
average of 50 particles on each frame, and the program was able to keep
up the pace. It may slightly depend on the computer specifications, but
any dual-core computer should suffice. However, higher resolution
images, where each particle occupies more than around 10 pixels become
excruciatingly slow. This is due to the algorithm to locate particles
and the number of computations increasing with particle size.&lt;/p&gt;
&lt;p&gt;Right now the program does not include ways of pre-processing data
before sending to a tracking algorithm, such as background reduction,
reduction of resolution, etc. These, however, are easy to implement in
the experiment model as different acquisition routines that can be
triggered either from the command line or from a GUI.&lt;/p&gt;
&lt;h2&gt;Wish list for Pynta&lt;/h2&gt;
&lt;p&gt;PyNTA was released in order to open the door to collaboration. However,
there is still a long way for it to become a stable product. The
features that PyNTA needs to implement in order to become more complete
are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Load saved data and analyze it&lt;/li&gt;
&lt;li&gt;Produce reports for less technical users&lt;/li&gt;
&lt;li&gt;Implement extra parameters for linking locations&lt;/li&gt;
&lt;li&gt;Improve visualization of linking status (i.e. show tracks faster in
    order to make better decisions)&lt;/li&gt;
&lt;li&gt;Improve results by adding the Walker algorithm&lt;/li&gt;
&lt;li&gt;Systematize the publisher/subscriber pattern to make it clearer for
    later developers&lt;/li&gt;
&lt;li&gt;Explore pyMPI as a possible message exchanging approach&lt;/li&gt;
&lt;li&gt;Simplify serialization/deserialization in order to speed up
    communication&lt;/li&gt;
&lt;li&gt;Think about a zero-copy numpy exchange of arrays&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Possible Roadmap&lt;/h2&gt;
&lt;p&gt;There are different options that can sprout out of PyNTA. For example,
developing a framework to perform experiments with a common pattern of
subscribers and publishers. With the experience gained in PyNTA, there
is a clear path for abstracting common functions. Moreover, pyZMQ opens
the door to a very interesting approach that would allow running the
experiment completely independent from the GUI. This would prevent
problems if the GUI crashes, for example. Moreover one could think about
having GUI's for different platforms that run on the same hardware. For
example, an app on the phone could control the experiment in the same
way that a user sitting on the computer in the lab.&lt;/p&gt;
&lt;h2&gt;Getting PyNTA&lt;/h2&gt;
&lt;p&gt;If you are intrigued by PyNTA, you can install it by simply running:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install pynta
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And you can start it by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pynta
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The documentation is available &lt;a href="https://nanoepics.github.io/pynta/"&gt;on
Github&lt;/a&gt;. It is still a work in
progress, but it is already quite complete. The code is in &lt;a href="https://github.com/nanoepics/pynta"&gt;this
repository&lt;/a&gt;.&lt;/p&gt;</content><category term="blog"></category><category term="Nanoparticle"></category><category term="Tracking"></category><category term="Analysis"></category><category term="Release"></category><category term="Package"></category><category term="Desktop"></category><category term="Experiment"></category></entry><entry><title>Step by Step Guide to Building a GUI</title><link href="https://www.pythonforthelab.com/blog/step-by-step-guide-to-building-a-gui" rel="alternate"></link><published>2018-08-27T00:00:00+02:00</published><updated>2018-08-27T00:00:00+02:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2018-08-27:/blog/step-by-step-guide-to-building-a-gui</id><summary type="html">&lt;p&gt;In this tutorial, we are going to build a Graphical User Interface (GUI)
to acquire images from your webcam. We are going to use OpenCV to
quickly acquire an image from your camera and PyQt5 to build the user
interface. You may find a lot of tutorials online on how …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In this tutorial, we are going to build a Graphical User Interface (GUI)
to acquire images from your webcam. We are going to use OpenCV to
quickly acquire an image from your camera and PyQt5 to build the user
interface. You may find a lot of tutorials online on how to use Python
for different tasks, but it is very hard to find a complete guide on how
to build a desktop application using Python.&lt;/p&gt;
&lt;p&gt;Building GUI's is not complicated, what makes them complex are the
considerations you have to make when you allow a user to randomly
interact with your program. For instance, imagine that your program
allows the user to choose the camera they want to use and then acquire
an image. You have to consider what would happen if the user first tries
to acquire an image. And this is only the tip of the iceberg.&lt;/p&gt;
&lt;p&gt;When you finish this tutorial you will have a good overview on how to
structure a project, separating into modules the important parts. You
will also learn how to start developing a PyQt application from scratch,
building on complexity step by step. Finally, you will have a working
example of how to interface with a real world device using a user
interface.&lt;/p&gt;
&lt;h2&gt;Installing OpenCV and PyQt5&lt;/h2&gt;
&lt;p&gt;The project is to build a user interface for your webcam. In order to do
it, we are going to need two main libraries: &lt;strong&gt;OpenCV&lt;/strong&gt; will be
responsible for the acquisition, while &lt;strong&gt;PyQt5&lt;/strong&gt; is the framework we are
using for the interface.&lt;/p&gt;
&lt;p&gt;OpenCV is a very big package that can be used with different programming
languages. It can handle all sorts of image manipulations, including
face-detection, object tracking, etc. In this tutorial, we are not going
to exploit all these possibilities, but you should be aware of the
potential this library has. To install OpenCV, the simplest is to run
the following command:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install opencv-contrib-python
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Remember that the best practice is to be working in a &lt;a href="https://www.pythonforthelab.com/blog/virtual-environment-is-a-must-have-tool"&gt;virtual
environment&lt;/a&gt; to avoid
conflicts with other libraries, etc. The installation procedure should
also install numpy. If you run into issues while installing OpenCV, you
are free to &lt;a href="https://forum.pythonforthelab.com"&gt;ask them in the forum&lt;/a&gt;
or you can check &lt;a href="https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_setup/py_table_of_contents_setup/py_table_of_contents_setup.html#py-table-of-content-setup"&gt;the official
documentation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To check that OpenCV was properly installed and configured, you can
start the Python interpreter and run the following commands to see what
version do you have available:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; import cv2
&amp;gt;&amp;gt;&amp;gt; cv2.__version__
'3.4.2'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The next step is to install PyQt5, which will also require a single
command:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install PyQt5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Normally this procedure works, but PyQt5 can give some issues on some
specific platforms. If you can't find solutions to your problems, the
alternative option is to install
&lt;a href="https://www.anaconda.com/download/#linux"&gt;Anaconda&lt;/a&gt; which will have all
the packages already available on all the platforms.&lt;/p&gt;
&lt;p&gt;To test whether PyQt5 is working, you can create a short script with the
following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from PyQt5.QtWidgets import QApplication, QMainWindow

app = QApplication([])
win = QMainWindow()
win.show()
app.exit(app.exec_())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the file, a small, empty window should pop up. This means
that everything is working correctly.&lt;/p&gt;
&lt;p&gt;Finally, we need a library that will be able to show the images that we
acquire with the webcam. There are several options to choose from. You
can use &lt;strong&gt;matplotlib&lt;/strong&gt;, which is a common tool for making plots,
including 2D images. You can also use &lt;strong&gt;Pillow&lt;/strong&gt;, which is a great tool
for working with images in Python. A third option is to use
&lt;strong&gt;pyqtgraph&lt;/strong&gt;, a library that is not mainstream with normal Python
developers, but that is used extensively in research labs.&lt;/p&gt;
&lt;p&gt;Because of the background of this website, we are going to go for the
third option: using PyQtGraph. On one hand, this will give visibility to
an amazing project, spearheaded by &lt;a href="https://www.alleninstitute.org/what-we-do/brain-science/about/team/staff-profiles/luke-campagnola/"&gt;Luke
Campagnola&lt;/a&gt;.
To install it, simply do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;pip install pyqtgraph
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we are ready to develop the application.&lt;/p&gt;
&lt;h2&gt;Welcome to OpenCV&lt;/h2&gt;
&lt;p&gt;When developing this kind of applications, the first step is to
understand what do we want to do before embarking on designing and
developing a User Interface. OpenCV makes it very simple to read from a
webcam attached to a computer, you simply do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import cv2
import numpy as np

cap = cv2.VideoCapture(0)
ret, frame = cap.read()
cap.release()

print(np.min(frame))
print(np.max(frame))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the first line, we initialize the communication with the camera. Of
course, if no cameras are attached, when you run the following command,
&lt;code&gt;cap.read()&lt;/code&gt;, nothing will be acquired, but the program will not crash.
Finally, we release the camera. The last two lines are just printing the
maximum and minimum values recorded by the camera. Bear in mind that
&lt;code&gt;frame&lt;/code&gt; is a numpy 2D-array.&lt;/p&gt;
&lt;p&gt;To go one step forward, we can also acquire a video from the camera. The
only difference with the code above is that we need to run an infinite
loop, and in each iteration, a new frame is acquired and displayed. To
quit the application, you need to press &lt;code&gt;Q&lt;/code&gt; on your keyboard. Note that
we are also transforming the image to grayscale. You can remove that
line and check how the image looks like.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import cv2

cap = cv2.VideoCapture(0)


while(True):
    # Capture frame-by-frame
    ret, frame = cap.read()

    # Our operations on the frame come here
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    # Display the resulting frame
    cv2.imshow('frame',gray)
    if cv2.waitKey(1) &amp;amp; 0xFF == ord('q'):
        break

# When everything done, release the capture
cap.release()
cv2.destroyAllWindows()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we have a clear picture of how the acquisition process works. We
have to start the communication with the camera and then we can read
from it. There are some parameters that we can either change to the
image itself, like transforming to black and white, or to the camera.
For example, we could increase the brightness by adding the following
right after &lt;code&gt;VideoCapture&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;cap.set(cv2.CAP_PROP_BRIGHTNESS, 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since you are setting the property to the camera itself, it won't
disappear until you don't set it back to &lt;code&gt;0.5&lt;/code&gt;, even if you restart the
program. You can check the &lt;a href="https://docs.opencv.org/3.4/d4/d15/group__videoio__flags__base.html#gaeb8dd9c89c10a5c63c139bf7c4f5704d"&gt;documentation on
properties&lt;/a&gt;
to see what are the possibilities. Remember that not all cameras support
all the options, and therefore some errors can appear, or no visible
changes at all.&lt;/p&gt;
&lt;p&gt;To make a video you need to continuously acquire from the camera, in an
infinite loop. We are not going to enter into the details now, but this
can be a problem if your frames take long to acquire, for instance, if
you set longer exposure times.&lt;/p&gt;
&lt;h2&gt;Welcome to PyQt&lt;/h2&gt;
&lt;p&gt;Qt, similarly to OpenCV, is a general library, written in C++ and
available for a lot of platforms. PyQt are python bindings to Qt, i.e. a
translation of the original code to objects that can be used from within
Python. The main difficulty of working with Qt comes from the fact that
a lot of the documentation is not available for the Python bindings but
for the original code. This implies that the user has to make a
translation from one language to another. Once you get used to it, it
just works fine but takes time to learn.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;There is a different set of bindings available for Python, called
PySide2. They are the officially released bindings by Qt and, for
practical matters, they work exactly the same. The main difference is
the license under which they are released. If you are concerned about
releasing your code, you should check the options.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A user interface consists of an infinite loop in which the windows are
drawn, the user interaction is grabbed, images from the webcam are
displayed, etc. If the loop is broken, the application finishes, closing
all the windows. So, let's get started with a simple window:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from PyQt5.QtWidgets import QApplication, QMainWindow

app = QApplication([])
win = QMainWindow()
win.show()
app.exit(app.exec_())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case, the infinite loop is given by &lt;code&gt;app.exec_()&lt;/code&gt;. If you remove
that line, you will see that the program runs, but nothing actually
happens. Placing the loop inside the &lt;code&gt;app.exit()&lt;/code&gt; is a way of
guaranteeing that the application is properly closed when the loop stops
running. It is important to note that before defining any windows, you
should always define the application in which they are going to run. If
you alter the order, you will get a quite descriptive error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;QWidget: Must construct a QApplication before a QWidget
Aborted (core dumped)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In PyQt (or Qt in general) the building blocks of windows are called
Widgets. A window is a widget, a button, dialog, image, icon, etc. You
can even define your own custom widgets. In the code above, you see that
there is only an empty window appearing, not too exciting. Let's add a
button to the window:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton

app = QApplication([])
win = QMainWindow()
button = QPushButton('Test')
win.setCentralWidget(button)
win.show()
app.exit(app.exec_())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Buttons are called &lt;code&gt;QPushButton&lt;/code&gt;. Parts of the code are always the same,
like the creation of the app, or the execution of the loop. When we
create a push button, we define also the text that the button will have.
To add the button to the window there are different options. In this
case, since we defined the window as a &lt;code&gt;QMainWindow&lt;/code&gt;, we can set the
button as its central widget. Main windows work only if a central widget
is defined in them. The window looks like this:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Main window with a button" class="center-img" src="/images/22_images/01_main_window.png"&gt;&lt;/p&gt;
&lt;p&gt;It looks very silly, but it is a very good start. The last remaining
thing would be to do something when the button is pressed. In order to
trigger something by a button press, you have to understand what
&lt;em&gt;Signals and Slots&lt;/em&gt; are in the context of Qt.&lt;/p&gt;
&lt;h2&gt;Signals and Slots in Qt&lt;/h2&gt;
&lt;p&gt;When you develop complex applications, such as one with a user
interface, you may want to trigger different actions under specific
conditions. For example, you may want to send an e-mail to the user
saying that the webcam finished acquiring a movie. However, you may want
later to also add the possibility of saving the video to the hard drive
or publishing it to Youtube. At another time, you decide that you would
also like to save the video when a user presses a button or publishing
to Youtube when the computer receives an e-mail.&lt;/p&gt;
&lt;p&gt;A very convenient way of developing a program in which you can trigger
actions at specific events would be if you could subscribe functions to
signals that are generated at certain moments. Once the video is
acquired, the program can emit a message, which will be caught by all
its subscribers. In this way you can write your code for acquiring a
video once, but what happens when the video finishes can be easily
changed.&lt;/p&gt;
&lt;p&gt;From the other side, you can write the function to save the video once,
and trigger it either when the video finishes or when a user presses a
button, etc. The main thing to realize when developing user interfaces
is that you don't know when things are going to happen. It may be that
the user first acquires an image and then makes a video. It may be that
the user doesn't acquire a video and tries to save the data, etc.
Therefore, it is very handy to be able to trigger actions on specific
events.&lt;/p&gt;
&lt;p&gt;In Qt, the whole idea of triggering actions with certain events is
defined with &lt;em&gt;Signals&lt;/em&gt;, which get triggered at specific moments and
&lt;em&gt;Slots&lt;/em&gt;, which are the actions that will be executed. With the button
that we have defined, an action, or &lt;em&gt;signal&lt;/em&gt;, could be its pressing. The
&lt;em&gt;slot&lt;/em&gt; is whatever function we want it to be, for example, we will print
a message to the terminal:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton

def button_pressed():
    print('Button Pressed')

app = QApplication([])
win = QMainWindow()
button = QPushButton('Test')
button.clicked.connect(button_pressed)
win.setCentralWidget(button)
win.show()
app.exit(app.exec_())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that we first define the function, in this case &lt;code&gt;button_pressed&lt;/code&gt;.
The real magic happens in the highlighted line. The signal that we want
to use is &lt;code&gt;clicked&lt;/code&gt;, and we connect that signal to &lt;code&gt;button_pressed&lt;/code&gt;
(note that we don't add the &lt;code&gt;()&lt;/code&gt; in this line). If you run the program
again and you press the button, you will see a message appearing on the
terminal.&lt;/p&gt;
&lt;p&gt;To continue on the same line of what it was discussed above, you could
define a new function that gets triggered whenever the button is
pressed. You will end up with something like this (I have removed the
parts that are common to keep the example short):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def button_pressed():
    print('Button Pressed')

def new_button_pressed():
    print('Another function')

button.clicked.connect(button_pressed)
button.clicked.connect(new_button_pressed)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the program again, you will see that every time you press the
button, two messages appear on the terminal. Of course, you could have
used functions that you import from different packages. The last bit in
order to provide a complete example is to add a second button and
connect its &lt;code&gt;clicked&lt;/code&gt; signal to &lt;code&gt;button_pressed&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Adding a new widget to a Main Window requires some extra steps. As we
have discussed earlier, every main window requires one (and only one)
central widget. The skeleton of the Main Window looks like this:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Main window layout" class="center-img" src="/images/22_images/02_mainwindowlayout.png"&gt;&lt;/p&gt;
&lt;p&gt;You can add all the normal things that a window has, such as a menu,
toolbar, etc., but there is only one central widget. Since we want to
add two buttons, the best would be to define an empty widget that will
hold those two buttons. In turn, that widget will become the central
widget of the window.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from PyQt5.QtWidgets import QApplication, QMainWindow, \
    QPushButton, QVBoxLayout, QWidget

app = QApplication([])
win = QMainWindow()
central_widget = QWidget()
button = QPushButton('Test', central_widget)
button2 = QPushButton('Second Test', central_widget)
win.setCentralWidget(central_widget)
win.show()
app.exit(app.exec_())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we define the buttons, the second argument, means which element is
the parent of the widget. It is a fast way of adding elements to widgets
and to establish a clear relationship between each other, as we will see
later. If you run the code above, you will find only the &lt;code&gt;Second Test&lt;/code&gt;
button appearing. If you would change the order in which you define
&lt;code&gt;button&lt;/code&gt; and &lt;code&gt;button2&lt;/code&gt;, you will see that actually, one button is on top
of the other. Since &lt;code&gt;Second Test&lt;/code&gt; takes more space, it didn't let you
see the &lt;code&gt;Test&lt;/code&gt; that was under it.&lt;/p&gt;
&lt;p&gt;To set the position of the buttons (or of any other widget), you can use
the method &lt;code&gt;setGeometry&lt;/code&gt;. It takes four arguments, the first two are the
position in x,y coordinates relative to the parent widget. Since widgets
can be nested, it is important to keep this in mind. The other two
arguments are the width and the height. We can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;button.setGeometry(0,50,120,40)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will move the button &lt;code&gt;Test&lt;/code&gt; 50 pixels down and will make it 120
pixels wide and 40 pixels tall. If you run the code again, you will see
a window like this:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Main window with two buttons" class="center-img" src="/images/22_images/03_two_buttons.png"&gt;&lt;/p&gt;
&lt;p&gt;It is not a work of art, but you can see both buttons one on top of the
other. If you feel adventurous, you can play with the &lt;code&gt;setGeometry&lt;/code&gt;
method of the main window. What happens if you make it smaller than the
space the buttons take, or larger, etc. With this kind of examples you
see how powerful Qt is, but also how complicated it may become to make
things look exactly as you want.&lt;/p&gt;
&lt;p&gt;After all this digression to add two buttons, it is time to hook them to
functions. The procedure is the same as for one button, using the
&lt;code&gt;clicked&lt;/code&gt; signal of each one of them:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;button.clicked.connect(button_pressed)
button2.clicked.connect(button_pressed)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the program again, you will see that regardless of what
button you are pressing, the same function is executed. You can also
connect both buttons to different functions, to more than one, etc. This
programming pattern makes your code much simpler to maintain, but also
more complicated to follow for beginners. Since the action to be
triggered can be defined anywhere in a program, it may take a while to
understand what happens when.&lt;/p&gt;
&lt;h2&gt;Adding Layouts for Styling&lt;/h2&gt;
&lt;p&gt;Adding two buttons by setting their geometry works, but is not the
handiest thing ever. If you change the number of characters in a button,
the text may not fit in the space, you need to keep track of the
position of every button in order to add the other one just below, etc.
With more complicated layouts, when you have input fields or different
kinds of widgets, setting the geometry individually would be incredibly
cumbersome. Fortunately, we can use Layouts to speed and simplify our
design.&lt;/p&gt;
&lt;p&gt;A layout is a way of telling Qt how to organize elements relative to
each other. For instance, if we want the two buttons one below the
other, we could use a vertical layout. Layouts are assigned to widgets,
and therefore to the &lt;code&gt;central_widget&lt;/code&gt;. In our example it would become:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from PyQt5.QtWidgets import QApplication, QMainWindow, \
    QPushButton, QVBoxLayout, QWidget


app = QApplication([])
win = QMainWindow()
central_widget = QWidget()
button2 = QPushButton('Second Test', central_widget)
button = QPushButton('Test', central_widget)
layout = QVBoxLayout(central_widget)
layout.addWidget(button2)
layout.addWidget(button)
win.setCentralWidget(central_widget)
win.show()
app.exit(app.exec_())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now the window looks much better:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Main window with two buttons using layout" class="center-img" src="/images/22_images/04_two_buttons_layout.png"&gt;&lt;/p&gt;
&lt;p&gt;You can go ahead and try to resize the window and see how the buttons
adapt. Compare that to the case where you didn't use the layout. Of
course, you may want to put one button next to the other, in which case
you will use a &lt;code&gt;QHBoxLayout&lt;/code&gt;, but the rest of the code is the
same.Connecting signals to functions works in exactly the same way,
because the button is the same, regardless of whether it is inside a
layout or not.&lt;/p&gt;
&lt;h2&gt;Acquiring An Image from the GUI&lt;/h2&gt;
&lt;p&gt;Now you have completed a first building step into how to start
developing a user interface with Qt. However, it is time for us to do
something with it. Since we are set in the task of controlling the
webcam, we are going to do that. You have seen that connecting buttons
to functions is very easy. We can use exactly what we saw earlier to
read a frame from the camera. First, let's import OpenCV and define the
functions that we are going to use:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import cv2
import numpy as np
from PyQt5.QtWidgets import QApplication, QMainWindow, \
    QPushButton, QVBoxLayout, QWidget

cap = cv2.VideoCapture(0)
def button_min_pressed():
    ret, frame = cap.read()
    print(np.min(frame))

def button_max_pressed():
    ret, frame = cap.read()
    print(np.max(frame))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can see that we defined two functions, one that outputs the minimum
value of the recorded frame and one that outputs the maximum. Now, we
need to build the rest of the user interface and connect the two buttons
to those functions. Pay attention to the new names that the buttons
take:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;app = QApplication([])
win = QMainWindow()
central_widget = QWidget()
button_min = QPushButton('Get Minimum', central_widget)
button_max = QPushButton('Get Maximum', central_widget)
button_min.clicked.connect(button_min_pressed)
button_max.clicked.connect(button_max_pressed)
layout = QVBoxLayout(central_widget)
layout.addWidget(button_min)
layout.addWidget(button_max)
win.setCentralWidget(central_widget)
win.show()
app.exit(app.exec_())
cap.release()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Every time you click one of the buttons, you will get a message on the
terminal saying what is the maximum or minimum value in the image. The
next step would be to display the image within the GUI. However, as you
can see, the code starts to be less clear as we add more functionality.
From a perspective of efficiency, it would be desirable to acquire the
image once and then computing maximum and minimum. However, when having
a simple script file, it becomes very complicated to share information.
It is time to improve the layout of our program before going forward
with the solution.&lt;/p&gt;
&lt;h2&gt;Layout of the Program: MVC design pattern&lt;/h2&gt;
&lt;p&gt;What we are going to do before continuing improving the user interface
is to improve the code itself by developing different modules and
classes that can be easily imported from a main file. When we refer to
the names of the files, we will use &lt;strong&gt;bold&lt;/strong&gt; characters, to avoid
confusion. All the files should be located in the same folder, doesn't
really matter where on your computer as long as you have write access.&lt;/p&gt;
&lt;p&gt;Developing great and sustainable programs is a tough task that involves
much more thinking than coding. There is no recipe that satisfies
absolutely everyone. However, there are some common practices that can
make your program much clearer to newcomers. There is a common pattern
in programming known as the Model-View-Controller (MVC). You can read a
lot about it, and most likely you will find plenty of examples on how to
use it when developing websites.&lt;/p&gt;
&lt;p&gt;When developing desktop applications that interface with real-world
devices, then the meanings of each element in the MVC structure change.
For instance, a controller would be the driver that is able to
communicate with a device, which in our case is the camera. The driver
was developed by OpenCV, but it is very likely that at some point we
would &lt;a href="https://www.pythonforthelab.com/blog/how-to-write-a-driver-with-lantz"&gt;develop our own drivers&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In the model, we would place all the logic of how we use the device,
which is not necessarily how the device was designed to work. For
instance, with the camera, we could implement a method called &lt;code&gt;movie&lt;/code&gt;
even if the specific camera with which we are working only supports
acquiring single frames. We could perform checks, etc. according to how
we expect to use a device for our needs.&lt;/p&gt;
&lt;p&gt;The view is clear that relates to the user interface and hence
everything that belongs to Qt. It is important to note that a safe way
of developing applications is by stripping all the logic from the view.
If something is not supposed to run because the webcam is not ready,
etc. then it should be the responsibility of the model and not of the
view to prevent that from happening.&lt;/p&gt;
&lt;p&gt;The MVC pattern is very common to find in different applications,
however, you have to be flexible enough as to understand what each
component means, especially when you are developing an application from
scratch, as is the case in this tutorial. When you use frameworks such
as Django or Flask for web development, the framework itself pushes you
to follow some specific patterns. For desktop and scientific
applications such frameworks are not as mature yet and you have to start
from scratch.&lt;/p&gt;
&lt;p&gt;If you want to see the code in its final version, you can check the
&lt;a href="https://github.com/PFTL/website/tree/master/example_code/22_Step_By_Step_Qt/AI_camera_model"&gt;Github Repository for this
article&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;The Camera Model&lt;/h2&gt;
&lt;p&gt;Since OpenCV took care of the controller of our camera, we can start
developing the model for it. You can see in the repository how &lt;a href="https://github.com/PFTL/website/blob/master/example_code/22_Step_By_Step_Qt/AI_camera_model/models.py"&gt;the
final
model&lt;/a&gt;
will look like. The best idea is to generate a skeleton of what we want
to do with our camera. Lay out the methods, inputs, etc. that we know we
are going to use. And then we look into them. Create a file called
&lt;strong&gt;models.py&lt;/strong&gt; and include the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Camera:
    def __init__(self, cam_num):
        pass

    def get_frame(self):
        pass

    def acquire_movie(self, num_frames):
        pass

    def set_brightness(self, value):
        pass

    def __str__(self):
        return 'Camera'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We are developing a very simple model for our device. If you want to see
how a model looks for scientific cameras, you can see what I have
developed &lt;a href="https://github.com/uetke/UUTrack/blob/master/UUTrack/Model/Cameras/Hamamatsu.py"&gt;for a Hamamatsu Orca
camera&lt;/a&gt;.
The advantage of developing a model at this stage is that if later I
decide to change the camera or the driver, the only thing I need to do
is to update the way the model works, and the rest of the program will
keep running.&lt;/p&gt;
&lt;p&gt;There are few things to note about the model. You can see that we expect
the &lt;code&gt;__init__&lt;/code&gt; method to take one argument, the camera number. This is
the argument that the &lt;code&gt;VideoCapture&lt;/code&gt; of OpenCV requires. &lt;code&gt;get_frame&lt;/code&gt; and
&lt;code&gt;acquire_movie&lt;/code&gt; are going to be responsible for reading from the camera
and the &lt;code&gt;set_brightness&lt;/code&gt; is an example of setting a parameter on a
camera. The &lt;code&gt;__str__&lt;/code&gt; method is going to help us if we need to identify
the camera and is going to be handy on our GUI.&lt;/p&gt;
&lt;p&gt;We have the skeleton of the model, now is time to add some meaning to
the methods. The advantage of using a class is that we can store the
important parameters in the class itself. When we initialize, we should
store the &lt;code&gt;cap&lt;/code&gt; variable, in order to make accessible to the other
methods.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def __init__(self, cam_num):
    self.cap = cv2.VideoCapture(cam_num)
    self.cam_num = cam_num

def __str__(self):
    return 'OpenCV Camera {}'.format(self.cam_num)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have also modified the &lt;code&gt;__str__&lt;/code&gt; method in order to show that it is
an Open CV camera and its number. If you want to test the code quickly,
the best is to add a block at the end of the &lt;strong&gt;models.py&lt;/strong&gt; file with the
following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;if __name__ == '__main__':
    cam = Camera(0)
    print(cam)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you just run &lt;code&gt;models.py&lt;/code&gt;, you will see a message printed to the
screen. You may have noticed also that in the example above, we are not
closing the camera, we have forgotten about that method! Of course, you
can always access the &lt;code&gt;cam.cap&lt;/code&gt; attribute, but it would be much more
elegant not to access the controller itself, since later on, another
camera may use a different method for finalizing the communication. Now
that we are at it, we can define the new method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def close_camera(self):
    self.cap.release()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And it could be actually nice to initialize the communication with the
camera not when we instantiate the class, but when we decide. In that
way, we can re-open the camera even if we have executed the
&lt;code&gt;close_camera&lt;/code&gt; method.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def __init__(self, cam_num):
    self.cam_num = cam_num
    self.cap = None

def initialize(self):
    self.cap = cv2.VideoCapture(self.cam_num)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the &lt;code&gt;__init__&lt;/code&gt; method we define &lt;code&gt;self.cap&lt;/code&gt; as None because it is a
style rule to define all the attributes of the class in the
initialization. In that way, you can see very quickly what attributes
you will have available. It will also allow you to check whether the
&lt;code&gt;cap&lt;/code&gt; is defined before you try to do something with it. With these
changes, you will also need to update the example at the bottom of the
file:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;if __name__ == '__main__':
    cam = Camera(0)
    cam.initialize()
    print(cam)
    cam.close_camera()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now the interesting part comes. We have to define the methods for
reading the camera. We have to decide also if we want to return a value
that can be used by another module or if we want to store the values in
the class itself. We can also combine both options:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def get_frame(self):
    ret, self.last_frame = self.cap.read()
    return self.last_frame
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you are following from the beginning, it should be clear to you what
is happening. You can also see that we are storing the frame as
&lt;code&gt;self.last_frame&lt;/code&gt; within the class itself. If you want to show how to
use it, you can update the code at the end of the file. So far, we have
something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;if __name__ == '__main__':
    cam = Camera(0)
    cam.initialize()
    print(cam)
    frame = cam.get_frame()
    print(frame)
    cam.close_camera()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which will output a very long array, with all the values read by your
camera. Now we can work on the movie method. We have seen at the
beginning that movies are just acquiring images one after the other, in
an infinite loop. Since infinite loops are a bit dangerous (it is hard
to stop them nicely), we will add a parameter called number of frames.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def acquire_movie(self, num_frames):
    movie = []
    for _ in range(num_frames):
        movie.append(self.get_frame())
    return movie
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We start by generating an empty list in which we are going to store the
images and then we start a for-loop for the given number of frames. In
each iteration, we append the data generated by the method &lt;code&gt;get_frame&lt;/code&gt;.
One of the advantages of this is that we are going to automatically have
the &lt;code&gt;last_frame&lt;/code&gt; attribute available.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;when dealing with more sophisticated cameras, normally the starting of a
movie and the reading from the camera are done in two separate steps.
This ensures the correct timing between frames, even if the program is
running slower.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;You may already see that the method is not efficient at all. Appending
to lists can be very slow, if the numbers of frames are too many it will
give memory errors, etc. For the time being, we can work with this.&lt;/p&gt;
&lt;p&gt;The last remaining method to develop is the &lt;code&gt;set_brighntess&lt;/code&gt;. This one
is much easier, you can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def set_brightness(self, value):
    self.cap.set(cv2.CAP_PROP_BRIGHTNESS, value)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also ask yourself if it is possible to get the value of the
brightness, and it actually is if you replace &lt;code&gt;cap.set&lt;/code&gt; by &lt;code&gt;cap.get&lt;/code&gt;.
The same is valid for all the properties of the camera, such as the
number of pixels, etc. We can develop a new method, not considered when
we started, called &lt;code&gt;get_brightness&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def get_brightness(self):
    return self.cap.get(cv2.CAP_PROP_BRIGHTNESS)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And to use both methods, you can improve the &lt;code&gt;__main__&lt;/code&gt; code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;cam.set_brightness(1)
print(cam.get_brightness())
cam.set_brightness(0.5)
print(cam.get_brightness())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Remember that since you are setting parameters to the camera, they are
going to stay, even if you open the camera with a different program. If
you set the brightness too low or too high, you will notice it on your
next Skype call (true story).&lt;/p&gt;
&lt;p&gt;Now that the model is ready, we can start developing a user interface.&lt;/p&gt;
&lt;h2&gt;Reusable Qt Windows: Subclassing&lt;/h2&gt;
&lt;p&gt;When we started to play around with Qt windows, we have developed
everything as a script file that you could run. However, it is very hard
to maintain and reuse that kind of code. The easiest is to develop
classes that inherit from the base Qt classes. For example, let's
reproduce the window with the two buttons, but in a more elegant way.
Let's start by creating a file called &lt;strong&gt;views.py&lt;/strong&gt; and add the following
to it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from PyQt5.QtWidgets import QMainWindow, QWidget, QPushButton, QVBoxLayout, QApplication


class StartWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.central_widget = QWidget()
        self.button_min = QPushButton('Get Minimum', self.central_widget)
        self.button_max = QPushButton('Get Maximum', self.central_widget)
        self.layout = QVBoxLayout(self.central_widget)
        self.layout.addWidget(self.button_min)
        self.layout.addWidget(self.button_max)
        self.setCentralWidget(self.central_widget)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can find the &lt;a href="https://github.com/PFTL/website/blob/master/example_code/22_Step_By_Step_Qt/AI_camera_model/views.py"&gt;final version of the
views&lt;/a&gt;
file in the repository as well. What we have done here is very similar
to what we did earlier with the two buttons, the only difference is that
we have moved everything into a class called &lt;code&gt;StartWindow&lt;/code&gt; that inherits
from &lt;code&gt;QMainWindow&lt;/code&gt;. This is a very efficient way of extending the
functionality of classes. We have to run &lt;code&gt;super().__init__&lt;/code&gt; in order to
have all the properties of the Main Window available also in our class.
We define an empty widget, two buttons, and a layout, exactly as we have
done before. The most important thing is that we add the &lt;code&gt;self.&lt;/code&gt; before
the attributes in order to be able to use the buttons, layout, etc. in
any part of the class.&lt;/p&gt;
&lt;p&gt;To use the window, the code becomes much simpler. You can add it at the
end of &lt;strong&gt;views.py&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;if __name__ == '__main__':
    app = QApplication([])
    window = StartWindow()
    window.show()
    app.exit(app.exec_())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It only takes four lines now to have a window with the two buttons
nicely displayed. If you want to add functionality to the buttons you
can add methods to the class, pretty much the same as before, but
instead of plain functions, they become methods of the class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def __init__(self):
    [...]
    self.button_max.clicked.connect(self.button_clicked)

def button_clicked(self):
    print('Button Clicked')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I have removed some lines in order to keep the example short. The
advantage of this procedure is that the code to run is exactly the same.
Just run &lt;strong&gt;views.py&lt;/strong&gt; and you will get the same window as before, plus
the added functionality of the button.&lt;/p&gt;
&lt;h2&gt;Displaying an Image on the GUI&lt;/h2&gt;
&lt;p&gt;Now we are ready to do something more interesting, like displaying an
image onto the GUI. First, we need to decide how are we going to trigger
the camera. Ideally, we are going to have the model for the camera
available in the &lt;code&gt;StartWindow&lt;/code&gt; class so the method would look something
like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def update_image(self):
    frame = self.camera.get_frame()
    # Plot_the_frame
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This works only if we have &lt;code&gt;self.camera&lt;/code&gt; available. The best, in this
case, is to take the camera as an argument in the &lt;code&gt;__init__&lt;/code&gt;, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class StartWindow(QMainWindow):
    def __init__(self, camera):
        super().__init__()
        self.camera = camera
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This strategy is what allows us to combine the models and the views in a
very simple way. You could find better solutions, of course, but this
one is easy to debug and implement. It also implies that there is a
third file in which you combine models and views. But before focusing on
that file, let's finish up with the view in order to do something with
the camera. First, let's update the buttons and connect one of them to
&lt;code&gt;update_image&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import numpy as np

from PyQt5.QtWidgets import QMainWindow, QWidget, QPushButton, QVBoxLayout, QApplication


class StartWindow(QMainWindow):
    def __init__(self, camera = None):
        super().__init__()
        self.camera = camera

        self.central_widget = QWidget()
        self.button_frame = QPushButton('Acquire Frame', self.central_widget)
        self.button_movie = QPushButton('Start Movie', self.central_widget)
        self.layout = QVBoxLayout(self.central_widget)
        self.layout.addWidget(self.button_frame)
        self.layout.addWidget(self.button_movie)
        self.setCentralWidget(self.central_widget)

        self.button_frame.clicked.connect(self.update_image)

    def update_image(self):
        frame = self.camera.get_frame()
        print('Maximum in frame: {}, Minimum in frame: {}'.format(np.max(frame), np.min(frame)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The structure is exactly the same, we have just updated the name of the
buttons and the text on them. In order to use both the model and the
view, we have to create a new file, that we can call &lt;strong&gt;start.py&lt;/strong&gt;, and
add the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from PyQt5.QtWidgets import QApplication

from models import Camera
from views import StartWindow

camera = Camera(0)
camera.initialize()

app = QApplication([])
start_window = StartWindow(camera)
start_window.show()
app.exit(app.exec_())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see above, we are importing the model and initializing it,
and then we are passing it to &lt;code&gt;StartWindow&lt;/code&gt;. The rest is the same as in
the example at the bottom of the &lt;strong&gt;views.py&lt;/strong&gt; file. If you press the
Acquire frame, you will see in the terminal the values of the
intensities recorded by the camera.&lt;/p&gt;
&lt;p&gt;Now we are only one step away from displaying the image recorded by the
camera on the GUI. This is where PyQtGraph comes into action. We have to
add a new widget that can hold the image. I am removing all the code
that doesn't change, just to highlight the important pieces:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from pyqtgraph import ImageView

class StartWindow(QMainWindow):
    def __init__(self, camera = None):
        [...]
        self.image_view = ImageView()
        self.layout.addWidget(self.image_view)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the &lt;strong&gt;start.py&lt;/strong&gt; again, you will notice a black area just
below the buttons, that is where the image will appear. Next, we can
update the method for acquiring the image in order to display the data:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def update_image(self):
    frame = self.camera.get_frame()
    self.image_view.setImage(frame.T)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Run again the program, and you will get something like the image below,
you can take a selfie with the press of a button, how cool is that?&lt;/p&gt;
&lt;p&gt;&lt;img alt="Window with a selfie after clicking a button" class="center-img" src="/images/22_images/05_acquired_image.png"&gt;&lt;/p&gt;
&lt;p&gt;Notice that we are updating &lt;code&gt;frame.T&lt;/code&gt; instead of &lt;code&gt;frame&lt;/code&gt;, this is a
matter of how pixels are organized and how PyQtGraph assumes they are.
The &lt;code&gt;T&lt;/code&gt; is just to transpose the matrix, exchanging columns for rows. If
you play a bit around with the program, you will notice that you can
zoom in and out with the mouse scroll, you can change the levels and the
color profile. Of course, PyQtGraph is not really aimed at photography
but at scientific data. Not all the options are handy for a webcam, but
you can find some cool things around.&lt;/p&gt;
&lt;h2&gt;Adding a Scrollbar for the Brightness&lt;/h2&gt;
&lt;p&gt;Before we move to the problem of acquiring a movie continuously, let's
add a slider that can control the brightness of the image. As usual,
everything starts within the &lt;code&gt;__init__&lt;/code&gt; method. I am showing only the
relevant code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import QSlider

class StartWindow(QMainWindow):
    def __init__(self, camera = None):
        super().__init__()
        self.slider = QSlider(Qt.Horizontal)
        self.slider.setRange(0,10)
        [...]
        self.layout.addWidget(self.slider)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code above will generate a horizontal slider. The range only works
with integer numbers, so we set it between 0 and 10 to later transform
it to float values between 0 and 1. Sliders have a signal emitted when
the value of it changes, pretty much the same as when the button is
clicked. We can do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def __init__(self, camera):
    [...]
    self.slider.valueChanged.connect(self.update_brightness)

def update_brightness(self, value):
    value /= 10
    self.camera.set_brightness(value)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The signal, when is emitted, comes together with the value and will be
passed as argument to the function to which you connected it. Since
brightness is in the range from 0 to 10, we have to convert the value of
the slider before sending it to the camera. Of course, the changes are
not going to be reflected until you acquire a new image. If you want,
you could also connect the change of the slider to acquiring an image.&lt;/p&gt;
&lt;h2&gt;Acquiring a Movie: QtThreads&lt;/h2&gt;
&lt;p&gt;The next and final step in our User Interface is to add the possibility
of acquiring a movie. Let's start with the obvious, connecting the
button to the &lt;code&gt;method&lt;/code&gt; in the camera model. Since we need to specify the
number of frames, we can start with a default one, even if fake, just
for testing:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def __init__(self, camera):
    [...]
    self.button_movie.clicked.connect(self.start_movie)

def start_movie(self):
    self.camera.acquire_movie(200)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you try the code at this stage, you will notice that when the movie
starts, the User Interface becomes not responsive. If you are on
Windows, it may even happen that you get a notice asking if you would
like to close the program. This happens because the method
&lt;code&gt;acquire_movie&lt;/code&gt; takes long to execute, and it prevents the &lt;code&gt;app&lt;/code&gt; loop to
keep running. To avoid this, we need to move the &lt;code&gt;acquire_movie&lt;/code&gt; method
to a new thread, in order not to block the main thread.&lt;/p&gt;
&lt;p&gt;There are different ways of achieving the same, we are going for the
simplest to implement. We are also going to add a timer that will update
the image periodically, using the &lt;code&gt;last_frame&lt;/code&gt; attribute that we already
have available. First, in the &lt;strong&gt;views.py&lt;/strong&gt; we define a new class called
&lt;code&gt;MovieThread&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MovieThread(QThread):
    def __init__(self, camera):
        super().__init__()
        self.camera = camera

    def run(self):
        self.camera.acquire_movie(200)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To use it, we need to update the &lt;code&gt;start_movie&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def start_movie(self):
    self.movie_thread = MovieThread(self.camera)
    self.movie_thread.start()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With just this code, we are starting a new thread in which the camera
will be acquiring frames, but we are still not displaying them. For
this, we will create a timer, which will be responsible for periodically
updating the picture that is being displayed.&lt;/p&gt;
&lt;p&gt;While you acquire the movie you can also change the brightness and see
the output in real time. You can find the complete code in the &lt;a href="https://github.com/PFTL/website/tree/master/example_code/22_Step_By_Step_Qt/AI_camera_model"&gt;Examples
Folder of our
repository&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Extra Steps that You Can Try&lt;/h2&gt;
&lt;p&gt;Now that you have a good overview of how to develop a user interface, I
will leave some extra points for you to work on. One is that we are
setting the number of frames of the movie hardcoded into the program.
You can add a &lt;code&gt;QLineEdit&lt;/code&gt; widget in order to let the user define the
number.&lt;/p&gt;
&lt;p&gt;Another thing that is missing is the possibility of continuous acquiring
a movie. To do so, you could change the loop in the model and make it
run forever if you set the number of frames to &lt;code&gt;0&lt;/code&gt;, or &lt;code&gt;None&lt;/code&gt;. However,
if you do this, you will have to &lt;strong&gt;find a way to stop the recording of
the movie&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Finally, the model is accumulating all the data into an attribute. It
could be nice to have the option to save the movie or the picture
somewhere. You can add an extra button to achieve it, and if you are
willing, you can use &lt;a href="{filename}02_HDF5_python.rst.md"&gt;HDF5 files&lt;/a&gt; to
store the data.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;In this article, you have seen everything that it takes to start
building user interfaces interfacing with real-world devices such as a
camera. What you have seen is only the tip of the iceberg, there are
many, many more things to cover in order to achieve more complex
behaviors. However, it is a very good kickstart for structuring larger
projects. From here on, you can experiment as much as you want, the
options are endless.&lt;/p&gt;
&lt;p&gt;If you build something that you would like to show to the rest, you can
do it at &lt;a href="https://github.com/PFTL/pftl_discussions/discussions"&gt;the forum&lt;/a&gt;.
You can also check &lt;a href="http://pythonforthelab.com/books"&gt;our book&lt;/a&gt;, in
which we cover many more details about designing software and building
user interfaces.&lt;/p&gt;
&lt;p&gt;Header Photo by &lt;a href="https://unsplash.com/photos/qWwpHwip31M?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText"&gt;Alvaro
Reyes&lt;/a&gt;
on Unsplash&lt;/p&gt;</content><category term="blog"></category><category term="PyQt"></category><category term="PyQt5"></category><category term="Qt"></category><category term="GUI"></category><category term="OpenCV"></category><category term="webcam"></category><category term="User Interface"></category></entry><entry><title>What are Hashable Objects</title><link href="https://www.pythonforthelab.com/blog/what-are-hashable-objects" rel="alternate"></link><published>2018-08-27T00:00:00+02:00</published><updated>2018-08-27T00:00:00+02:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2018-08-27:/blog/what-are-hashable-objects</id><summary type="html">&lt;p&gt;To understand hashable objects in Python, it is important to review what
a hash table is. Following &lt;a href="https://en.wikipedia.org/wiki/Hash_table"&gt;the article on
Wikipedia&lt;/a&gt;, a hash table is a
data structure that can map keys to values and that implements a hash
function to compute the index to an array of buckets or …&lt;/p&gt;</summary><content type="html">&lt;p&gt;To understand hashable objects in Python, it is important to review what
a hash table is. Following &lt;a href="https://en.wikipedia.org/wiki/Hash_table"&gt;the article on
Wikipedia&lt;/a&gt;, a hash table is a
data structure that can map keys to values and that implements a hash
function to compute the index to an array of buckets or slots. Heavy
words, I know.&lt;/p&gt;
&lt;p&gt;The idea behind a hash table is that, in the end, you can reduce a
complex object to an index in an array. The analogy with a mail
directory may be appropriate. Imagine you have a collection of names of
people and their addresses. You store each address as soon as you meet a
new person, one under the other. A hash table in such case will be
responsible for transforming a name to a number that corresponds to the
row in which their information is written.&lt;/p&gt;
&lt;p&gt;If you have enough experience with Python, the first thing that probably
came to mind is a dictionary. That would be the easiest way of storing
addresses for people that you meet. You can easily retrieve their
information by looking up their names. Even if dictionaries are a
general concept in which keys are associated to values, Python, in fact,
implements a hash table by default (which doesn't mean this cannot
change in the future without affecting how dictionaries work).&lt;/p&gt;
&lt;p&gt;One of the complications of hash tables is how to implement the hash
function in a reliable way. Immutable data types in Python come with a
built-in method for computing their hash value, which is called
&lt;code&gt;__hash__&lt;/code&gt;. Let's see for example what happens with strings or tuples:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; a = '123'
&amp;gt;&amp;gt;&amp;gt; a.__hash__()
4031090051524460767
&amp;gt;&amp;gt;&amp;gt; b = (1, 2, 3)
&amp;gt;&amp;gt;&amp;gt; b.__hash__()
2528502973977326415
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You see that strings and lists are reduced to integers. If you would use
numbers instead:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; c = 1
&amp;gt;&amp;gt;&amp;gt; c.__hash__()
1
&amp;gt;&amp;gt;&amp;gt; d = 1.1
&amp;gt;&amp;gt;&amp;gt; d.__hash__()
230584300921369601
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, mutable objects such as lists and dictionaries do not have a
hash method. That is one of the reasons why you cannot use that kind of
objects as keys for dictionaries. What is important to note is that for
immutable types, the hash value depends only on the data stored and not
on the identity of the object itself. For instance, you can create two
tuples with the same values, and see the differences:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 = (1, 2, 3)
&amp;gt;&amp;gt;&amp;gt; var2 = (1, 2, 3)
&amp;gt;&amp;gt;&amp;gt; id(var1)
140697473296656
&amp;gt;&amp;gt;&amp;gt; id(var2)
140697473295216
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;They are indeed different objects, however:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1.__hash__()
2528502973977326415
&amp;gt;&amp;gt;&amp;gt; var2.__hash__()
2528502973977326415
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This means that if you use them as dictionary keys, they are going to be
indistinguishable from each other, for instance:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var3 = {var1:'var1'}
&amp;gt;&amp;gt;&amp;gt; var3[var2]
'var1'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the same way, you could have used the tuple itself:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var3[(1, 2, 3)]
'var1'
&amp;gt;&amp;gt;&amp;gt; var3[1, 2, 3]
'var1'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Based on what we saw, hashing an object can be thought as converting it
to an integer based on its content, but not on the identity of the
object itself. Of course, this may give problems, because you are
reducing a very large space of possibilities into a finite set of
integers. This reduction may give rise to something known as hash
collisions, i.e., two objects which are reduced to the same integer even
if their values are different.&lt;/p&gt;
&lt;p&gt;A very simple example of hash collisions is what happens between a
simple string and an integer:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 = 'a'
&amp;gt;&amp;gt;&amp;gt; var1.__hash__()
12416037344
&amp;gt;&amp;gt;&amp;gt; var2 = 12416037344
&amp;gt;&amp;gt;&amp;gt; var1.__hash__() == var2.__hash__()
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both &lt;code&gt;var1&lt;/code&gt; and &lt;code&gt;var2&lt;/code&gt; have the same hash value. So, we may wonder, what
happens if we use them in a dictionary, let's try it to find out:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var3 = {var1: 'var1'}
&amp;gt;&amp;gt;&amp;gt; var3[var2] = 'var2'
&amp;gt;&amp;gt;&amp;gt; var3
{'a': 'var1', 12416037344: 'var2'}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see in the snippet above, Python is relying on more than just
the hash value of an object when using it as keys for a dictionary.&lt;/p&gt;
&lt;h2&gt;Hash Values of Custom Classes&lt;/h2&gt;
&lt;p&gt;We have seen &lt;a href="https://www.pythonforthelab.com/blog/mutable-and-immutable-objects"&gt;before&lt;/a&gt; that
there are differences between mutable and immutable types in Python.
Built-in immutable types have always a hash method, while mutable types
don't. However, this leaves outside custom defined classes. By default,
all instances of custom classes will have a hash value defined at
creation and it will not change over time. Two instances of the same
class will have two different hash values. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    def __init__(self, value):
        self.value = value

my_obj = MyClass(1)
print(my_obj.__hash__()) # 8757243744113
my_new_obj = MyClass(1)
print(my_new_obj.__hash__()) # -9223363279611078919
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the code above, you will see that the hash value that you get
from your objects changes every time. This is because the hash is
derived from the object's id. Python, as expected, allows you to define
your own hash value. For example, you can alter &lt;code&gt;MyClass&lt;/code&gt; like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    def __init__(self, var):
        self.var = var

    def __hash__(self):
        return int(self.var)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you re-run the example, you will see that both objects have the same
hash value of 1. So, let's see what happens if we use them as the keys
for a dictionary:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; my_obj = MyClass(1)
&amp;gt;&amp;gt;&amp;gt; my_obj_2 = MyClass(1)
&amp;gt;&amp;gt;&amp;gt; var = {my_obj: 'my_obj'}
&amp;gt;&amp;gt;&amp;gt; var[my_obj_2] = 'my_obj_2'
&amp;gt;&amp;gt;&amp;gt; print(var)
{My Class: 'my_obj', My Class: 'my_obj_2'}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What you can see is that, even if the hash value is the same, they end
up as different keys in the dictionary. There is still something else
missing. Even if their hash values are the same, they are different
objects:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; my_obj == my_obj_2
False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can tweak the &lt;code&gt;MyClass&lt;/code&gt; class in order to output &lt;code&gt;True&lt;/code&gt; when
comparing it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    def __init__(self, var):
        self.var = var

    def __hash__(self):
        return int(self.var)

    def __eq__(self, other):
        return other.var == self.var
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The method &lt;code&gt;__eq__&lt;/code&gt; is used to determine whether one object is equal to
another. Because &lt;code&gt;MyClass&lt;/code&gt; takes only one argument when instantiating,
we just compare that value. For example, we would get:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 = MyClass(1)
&amp;gt;&amp;gt;&amp;gt; var2 = MyClass(1)
&amp;gt;&amp;gt;&amp;gt; var3 = MyClass(2)
&amp;gt;&amp;gt;&amp;gt; var1 == var2
True
&amp;gt;&amp;gt;&amp;gt; var1 == var3
False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It works as we would expect it to. If we try again with a dictionary:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var4 = {var1: 'var1'}
&amp;gt;&amp;gt;&amp;gt; var4[var2] = 'var2'
&amp;gt;&amp;gt;&amp;gt; var4
{My Class: 'var2'}
&amp;gt;&amp;gt;&amp;gt; var4[var3] = 'var3'
&amp;gt;&amp;gt;&amp;gt; var4
{My Class: 'var2', My Class: 'var3'}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we see what is that dictionaries in Python are using for
defining their keys. They do not only look at the hash value, they also
look whether the keys are the same or not. If they are not, they will be
assigned to a new element instead of the same one. You can try and see
what happens if two elements are equal, but have different hash values.&lt;/p&gt;
&lt;p&gt;Now you are starting to go through risky waters. If you would compare
your object to something other than the &lt;code&gt;MyClass&lt;/code&gt; instance (or better
said, any object without a &lt;code&gt;var&lt;/code&gt; attribute), an exception would be
raised. You can also force the equality to be true regardless of the
object you are comparing it to. So, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    def __init__(self, var):
        self.var = var

    def __hash__(self):
        return int(self.var)

    def __eq__(self, other):
        return True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now, we would find a strange behavior:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; my_obj = MyClass(1)
&amp;gt;&amp;gt;&amp;gt; var = 1
&amp;gt;&amp;gt;&amp;gt; my_obj == var
True
&amp;gt;&amp;gt;&amp;gt; var2 = {my_obj: 'my_obj'}
&amp;gt;&amp;gt;&amp;gt; var2[var] = 'var'
&amp;gt;&amp;gt;&amp;gt; print(var2)
{MyClass: 'var'}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So now you see that dictionaries test two things: the hash value and the
equality, if one of them doesn't match, then it is going to be assigned
as a new key.&lt;/p&gt;
&lt;p&gt;Of course, there are many details missing regarding how hash tables
work, but this is a pretty good introduction into how some of the
under-the-hood things work in Python. They may also give you a hint into
why things work or stop working at apparently random places.&lt;/p&gt;
&lt;p&gt;Header photo by &lt;a href="https://unsplash.com/photos/BkqUJQiucKY?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText"&gt;Yeo
Khee&lt;/a&gt;
on Unsplash&lt;/p&gt;</content><category term="blog"></category><category term="Hashable"></category><category term="Objects"></category><category term="Dictionaries"></category><category term="Hash"></category></entry><entry><title>Mutable and Immutable Attributes of Classes</title><link href="https://www.pythonforthelab.com/blog/mutable-and-immutable-attributes-of-classes" rel="alternate"></link><published>2018-08-24T00:00:00+02:00</published><updated>2018-08-24T00:00:00+02:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2018-08-24:/blog/mutable-and-immutable-attributes-of-classes</id><summary type="html">&lt;p&gt;We have seen how to leverage the differences between &lt;a href="https://www.pythonforthelab.com/blog/mutable-and-immutable-objects"&gt;mutable and
immutable objects&lt;/a&gt; and what
happens when you use mutable types as default function arguments.
However, we haven't discussed what happens when you use mutable types as
default attributes of classes.&lt;/p&gt;
&lt;p&gt;Default values for attributes can be defined in different …&lt;/p&gt;</summary><content type="html">&lt;p&gt;We have seen how to leverage the differences between &lt;a href="https://www.pythonforthelab.com/blog/mutable-and-immutable-objects"&gt;mutable and
immutable objects&lt;/a&gt; and what
happens when you use mutable types as default function arguments.
However, we haven't discussed what happens when you use mutable types as
default attributes of classes.&lt;/p&gt;
&lt;p&gt;Default values for attributes can be defined in different ways in your
classes. Let's start by looking at what happens if you define them in
the &lt;code&gt;__init__&lt;/code&gt; method. Let's start with a simple class that takes one
list as the argument when instantiating:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    def __init__(self, var=[]):
        self.var = var

    def append(self, value):
        self.var.append(value)

    def __str__(self):
        return str(self.var)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a very simple example that already will show a very peculiar
behavior. The &lt;code&gt;__init__&lt;/code&gt; takes one list as the argument, and if it is
not provided it will use an empty list as default. We have also added a
method for appending values to the list. The &lt;code&gt;__str__&lt;/code&gt; method was
defined for convenience to explore the contents of the &lt;code&gt;var&lt;/code&gt; attribute.
We can instantiate the class and use it as always:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;my_class = MyClass()
print(my_class)
# []
my_class.append(1)
print(my_class)
# [1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So far so good, but let's see what happens when we instantiate the
second class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;my_class_2 = MyClass()
print(my_class_2)
# [1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The second time you instantiate a class, it will use a different default
value! It is actually using the updated value from the first instance.
Moreover, if you change the value of the second instance, the value of
the first instance will also change:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;my_class_2.append(2)
print(my_class)
# [1, 2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Whatever changes you do to the attribute &lt;code&gt;var&lt;/code&gt; of one of the objects,
will be reflected into the other. Both attributes are actually the same
object, as you can verify by looking at their ids:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;print(id(my_class.var))
# 140228152031752
print(id(my_class_2.var))
# 140228152031752
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But the two instances are different&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;print(id(my_class))
# 140228175513360
print(id(my_class_2))
# 140228175513304
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The same pattern that appeared while using mutable variables as defaults
with functions will appear when using mutable default arguments of
methods in custom classes. If you want to avoid this from happening, you
can always check what &lt;a href="https://www.pythonforthelab.com/blog/mutable-and-immutable-objects"&gt;we have done when working with
functions&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Of course, the same pattern will appear if you use a mutable variable
defined outside of the class, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;my_list = [1, 2, 3]
my_class = MyClass(my_list)
my_class.append(4)
print(my_list)
# [1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Classes provide another pattern which is the use of &lt;strong&gt;class attributes&lt;/strong&gt;
instead of &lt;strong&gt;instance attributes&lt;/strong&gt;. Class attributes are those values
that are defined directly in the class, outside of any methods. Let's
update our example to use a class attribute called &lt;code&gt;var&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    var = []

    def append(self, value):
        self.var.append(value)

    def __str__(self):
        return str(self.var)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we use it as before:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;my_class = MyClass()
my_class.append(1)
print(my_class)
# [1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we instantiate the class again, we will have the same as before:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;my_class_2 = MyClass()
print(my_class_2)
# [1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The main difference with what we have done before is that we can address
directly the &lt;code&gt;var&lt;/code&gt; attribute of the class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;MyClass.var.append(2)
print(my_class)
# [1, 2]
print(my_class_2)
# [1, 2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also address the attribute of an instance directly, without the
need of the &lt;code&gt;append&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;my_class_2.var += [3]
print(my_class)
# [1, 2, 3]
print(my_class_2)
# [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can see in the examples above, is that the changes you apply to one
of the attributes will be reflected in the attributes of all the other
instances and even in the class itself. There is a big difference,
however, between class attributes and default inputs in methods. Class
attributes are shared between instances by default even if they are
immutable. Let's see, for example, what happens if we use a &lt;code&gt;var&lt;/code&gt; that
is an integer, and therefore immutable:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    var = 1

    def increase(self):
        self.var += 1

    def __str__(self):
        return str(self.var)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Just as we have done before, we will instantiate twice the class and see
what happens:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;my_class = MyClass()
print(my_class)
# 1
my_class_2 = MyClass()
print(my_class_2)
# 1
my_class.increase()
print(my_class)
# 2
print(my_class_2)
# 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What you see here is already a big difference. Both instances of
&lt;code&gt;MyClass&lt;/code&gt; have the same attribute &lt;code&gt;var&lt;/code&gt;. However, when you increase the
value in one of the instances this change is not propagated to the other
instance nor to new instances of the class.&lt;/p&gt;
&lt;p&gt;This is very different from what you would see if you change the value
of &lt;code&gt;var&lt;/code&gt; in the class itself:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;my_class = MyClass()
my_class_2 = MyClass()
MyClass.var += 1
print(my_class)
# 2
print(my_class_2)
# 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You see that class attributes are still linked to the instances. It is
very interesting to see the id of the &lt;code&gt;var&lt;/code&gt; attribute before and after
changing its value:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;my_class = MyClass()
my_class_2 = MyClass()
print(id(my_class_2.var))
# 10935488
print(id(my_class.var))
# 10935488
print(id(MyClass.var))
# 10935488
MyClass.var += 1
print(id(my_class_2.var))
# 10935520
print(id(my_class.var))
# 10935520
print(id(MyClass.var))
# 10935520
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You see that all the attributes are the same object. When the value is
replaced, since integers are immutable, a new object is created and is
propagated to all the instances of the class. However, if you change the
value of &lt;code&gt;var&lt;/code&gt; in one of the instances, this will not hold anymore:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;my_class.var += 1
print(id(my_class.var))
# 10935552
print(id(my_class_2.var))
# 10935520
print(id(MyClass.var))
# 10935520
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can see that both the attributes in &lt;code&gt;MyClass&lt;/code&gt; and in &lt;code&gt;my_class_2&lt;/code&gt;
are still the same object, while the identity of &lt;code&gt;var&lt;/code&gt; in &lt;code&gt;my_class&lt;/code&gt;
changed. From now on, any changes that you do to &lt;code&gt;MyClass.var&lt;/code&gt; are
decoupled from the changes in &lt;code&gt;my_class&lt;/code&gt;, but will still be reflected on
&lt;code&gt;my_class_2&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Keeping in mind the differences between methods' default values and
class attributes open a lot of possibilities when designing a program.
The fact that you can alter all objects from within a specific instance
can be of great use when properties change at runtime. Even if not an
extremely common scenario for short-lived scripts, it is very common
when dealing with user interaction on programs that run for hours or
days.&lt;/p&gt;
&lt;p&gt;As always, &lt;a href="https://github.com/PFTL/website/tree/master/example_code/21_Classes_Mutables"&gt;example code can be found
here&lt;/a&gt;
and &lt;a href="https://github.com/PFTL/website/blob/master/content/blog/21_Default_Attributes_Classes.rst.md"&gt;the source of this page
here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Header photo by &lt;a href="https://unsplash.com/photos/mgaS4FlsYxQ?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText"&gt;Dan
Gold&lt;/a&gt;
on Unsplash&lt;/p&gt;</content><category term="blog"></category><category term="Data"></category><category term="Types"></category><category term="Mutable"></category><category term="Immutable"></category><category term="Tuples"></category></entry><entry><title>Mutable or Immutable Tuples</title><link href="https://www.pythonforthelab.com/blog/mutable-or-immutable-tuples" rel="alternate"></link><published>2018-08-24T00:00:00+02:00</published><updated>2018-08-24T00:00:00+02:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2018-08-24:/blog/mutable-or-immutable-tuples</id><summary type="html">&lt;p&gt;Broadly speaking, Python variables belong to one of two types:
&lt;strong&gt;mutable&lt;/strong&gt; and &lt;strong&gt;immutable&lt;/strong&gt;. We have discussed this yesterday, in the
&lt;a href="https://www.pythonforthelab.com/blog/mutable-and-immutable-objects"&gt;Introduction To Mutable and Immutable Data
Types&lt;/a&gt;. The first one refers
to those elements that can be changed without the need of creating a new
one, while the latter refers …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Broadly speaking, Python variables belong to one of two types:
&lt;strong&gt;mutable&lt;/strong&gt; and &lt;strong&gt;immutable&lt;/strong&gt;. We have discussed this yesterday, in the
&lt;a href="https://www.pythonforthelab.com/blog/mutable-and-immutable-objects"&gt;Introduction To Mutable and Immutable Data
Types&lt;/a&gt;. The first one refers
to those elements that can be changed without the need of creating a new
one, while the latter refers to those that cannot be changed after
instantiation. A paradigmatic example of immutable objects is tuples.
However, as we are going to see in this article, tuples may seem to
change.&lt;/p&gt;
&lt;p&gt;You define a tuple by using &lt;code&gt;()&lt;/code&gt;, and access its elements using &lt;code&gt;[]&lt;/code&gt;,
for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 = (1, 2, 3)
&amp;gt;&amp;gt;&amp;gt; var[0]
1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since a tuple is immutable, you can't change its elements once it was
created, the following will give you an error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var[0] = 0
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: 'tuple' object does not support item assignment
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Tuples are not limited to hold numbers in them, nor to elements of the
same type. We can create a tuple that holds both numbers and a list:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; my_list = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; var = (1, my_list)
&amp;gt;&amp;gt;&amp;gt; var[1]
[1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What happens if you try to change the value of one of the elements of
the list?&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var[1][0] = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you know, tuples are immutable, and what you are doing is changing a
tuple. However, no error will appear. The operation above works as
expected:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; var[1] [0, 2, 3]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If you try to change &lt;code&gt;var[0]&lt;/code&gt;, which is an integer, you will face the
same exception that was shown above. So, what is happening? &lt;a href="https://standupdev.com/wiki/doku.php?id=python_tuples_are_immutable_but_may_change"&gt;Luciano
Ramalho&lt;/a&gt;
has written an excellent article with an example from Alice in
Wonderland, which I am not going to copy here, but that has deeply
inspired me.&lt;/p&gt;
&lt;p&gt;If you think variables as labels and not as boxes in which information
is stored, you can also think that what is stored in the tuple are
references to the objects and not the objects themselves. When you
change a list, its identity doesn't change, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; id(var)
44045192
&amp;gt;&amp;gt;&amp;gt; var[0] = 0
&amp;gt;&amp;gt;&amp;gt; id(var)
44045192
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A tuple is basically holding a reference to different objects. While
that reference doesn't change, the tuple will not change. The identity
of the list that is stored in the tuple does not change when we change a
value in a list or we append new elements, etc. This is not true for
other immutable data types, like integers. That is why, if we try to
change the value of an integer, an exception will be raised. A new
object is created and therefore the reference that is being stored in
the tuple needs to be updated.&lt;/p&gt;
&lt;p&gt;This also works when you use two different names for the same tuple. For
example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 = (1, my_list)
&amp;gt;&amp;gt;&amp;gt; var2 = var1
&amp;gt;&amp;gt;&amp;gt; var1 is var2
True
&amp;gt;&amp;gt;&amp;gt; var2[1] is my_list
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we update the values of the list in any way, they will be changed in
all the other variables:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1[1][0] = 0
&amp;gt;&amp;gt;&amp;gt; my_list
[0, 2, 3]
&amp;gt;&amp;gt;&amp;gt; var2[1]
[0, 2, 3]
&amp;gt;&amp;gt;&amp;gt; my_list[0] = 1
&amp;gt;&amp;gt;&amp;gt; var1[1]
[1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you see that we have three labels for the same list, and if we
update any of them, all the others will reflect these changes. For
example, you could create a new variable for the list:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 = (1, [1, 2, 3])
&amp;gt;&amp;gt;&amp;gt; my_list = var1[1]
&amp;gt;&amp;gt;&amp;gt; print(my_list)
[1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; my_list[0] = 0
&amp;gt;&amp;gt;&amp;gt; var1
(1, [0, 2, 3])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A lot of possibilities appear when you start playing around. However,
your code has to be very well structured and explained if you plan to
keep it maintainable.&lt;/p&gt;
&lt;h2&gt;Tuples as Dictionary Keys&lt;/h2&gt;
&lt;p&gt;In principle, any immutable variable can be used as a dictionary key.
Therefore, it is possible to also use tuples. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 = (1, 2)
&amp;gt;&amp;gt;&amp;gt; var2 = (4, 5)
&amp;gt;&amp;gt;&amp;gt; var3 = {var1: 'First Var',
...     var2: 'Second Var'}
&amp;gt;&amp;gt;&amp;gt; print(var3[1, 2])
First Var
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, if you generate a tuple that contains a reference to a mutable
object, the code above will fail:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var4 = (1, [1, 2, 3])
&amp;gt;&amp;gt;&amp;gt; var5 = {var1: 'First Var',
...     var4: 'Second Var'}

TypeError: unhashable type: 'list'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The keys of dictionaries have to be immutable, and they must reference
objects that are also immutable. Therefore, even if the tuple is
immutable, their elements may not be. You have to be careful when using
a tuple as key to a dictionary since it will not always work.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;actually, keys in dictionaries need to be hashable, which is not the
same as immutable. Custom defined classes are hashable but mutable and
can be used as dictionary keys. We are going to discuss this in a later
article.&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;This is a short article triggered by some comments that appear on the
&lt;a href="https://www.pythonforthelab.com/blog/mutable-and-immutable-objects"&gt;discussion about mutable and immutable
types&lt;/a&gt;. Wrapping your mind
around this level of details may be hard at the beginning, but when you
know these differences exist, you will be able to make better code, less
prone to bugs. You may also start realizing why so many packages use
tuples as default arguments instead of lists, etc.&lt;/p&gt;
&lt;p&gt;Header photo by &lt;a href="https://unsplash.com/photos/O6XDQCNo4Hc?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText"&gt;Michal
Pechardo&lt;/a&gt;
on Unsplash&lt;/p&gt;</content><category term="blog"></category><category term="Data"></category><category term="Types"></category><category term="Mutable"></category><category term="Immutable"></category><category term="Tuples"></category></entry><entry><title>Mutable and Immutable Objects</title><link href="https://www.pythonforthelab.com/blog/mutable-and-immutable-objects" rel="alternate"></link><published>2018-08-23T00:00:00+02:00</published><updated>2018-08-23T00:00:00+02:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2018-08-23:/blog/mutable-and-immutable-objects</id><summary type="html">&lt;p&gt;People who start programming in Python quickly stumble upon the
existence of lists and tuples. They are defined in a similar way, they
look the same. Sometimes they are even used interchangeably. The obvious
question is, therefore, why do you have two different types of elements
for the same goal …&lt;/p&gt;</summary><content type="html">&lt;p&gt;People who start programming in Python quickly stumble upon the
existence of lists and tuples. They are defined in a similar way, they
look the same. Sometimes they are even used interchangeably. The obvious
question is, therefore, why do you have two different types of elements
for the same goal? The answer lays in understanding the differences
between &lt;strong&gt;mutable&lt;/strong&gt; and &lt;strong&gt;immutable&lt;/strong&gt; data types in Python.&lt;/p&gt;
&lt;p&gt;Even after programming Python applications for a while, being conscious
about choosing lists or tuples is hard, and sometimes the implications
give rise to obscure bugs, very hard to find and correct. In this
article, we are going to discuss about the differences between lists and
tuples, or more generally about mutable and immutable data types and how
they can be used in your programs.&lt;/p&gt;
&lt;p&gt;As always, &lt;a href="https://github.com/PFTL/website/tree/master/example_code/17_mutable_immutable"&gt;example
code&lt;/a&gt;
is available and the &lt;a href="https://github.com/PFTL/website/blob/master/content/blog/17_mutable_and_immutable.rst.md"&gt;source
code&lt;/a&gt;
for this page also.&lt;/p&gt;
&lt;h2&gt;Lists and Tuples&lt;/h2&gt;
&lt;p&gt;In Python, when you want to define a list, you can simply do the
following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 = [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And you can address its elements by the position:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1[0]
1
&amp;gt;&amp;gt;&amp;gt; var[1]
2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you want to replace the value of an element, you can do the
following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1[0] = 0
&amp;gt;&amp;gt;&amp;gt; var1[0]
0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can do the same with a tuple, which uses &lt;code&gt;()&lt;/code&gt; instead of &lt;code&gt;[]&lt;/code&gt; in its
definition:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var2 = (1, 2, 3)
&amp;gt;&amp;gt;&amp;gt; var2[0]
1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, if you try to change the value of an element you will get an
error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var2[0] = 0
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: 'tuple' object does not support item assignment
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is the first, crucial difference between a list and a tuple. Once
defined, tuples cannot change their values. So, when would you use one
or the other depends on the application. The main difference between
them is that tuples are very fast when you need to access their values,
but lists are much more memory efficient if you would like to expand
them.&lt;/p&gt;
&lt;p&gt;When you have a variable that cannot be changed after it has been
created it is called &lt;strong&gt;immutable&lt;/strong&gt;, while in the opposite case, that
variable is called &lt;strong&gt;mutable&lt;/strong&gt;. Let's explore what that means.&lt;/p&gt;
&lt;h2&gt;Mutable and Immutable Data Types&lt;/h2&gt;
&lt;p&gt;There is an &lt;a href="https://standupdev.com/wiki/doku.php?id=python_tuples_are_immutable_but_may_change"&gt;excellent article written by Luciano
Ramalho&lt;/a&gt;
in which he explains how to understand variables in Python. I am not
going to copy his article, but I think it is a great inspiration on how
to explain things. What he suggests is to think about labels and not
about boxes when referring to variables. A variable is a label that we
assign to an object, it is the way we, as humans, have to identify it.
However, what is important about the underlying object is its value and
its type.&lt;/p&gt;
&lt;p&gt;A great tool in Python to understand this concept is the &lt;code&gt;id&lt;/code&gt; function.
We can apply it to any variable and it will return its identity. If we
want to be sure about dealing with the same object, we can check whether
the value returned by &lt;code&gt;id&lt;/code&gt; is the same. It is possible to think about
the integer that is being returned as the address in memory that is
assigned to the object. So, for example, we can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; var2 = (1, 2, 3)
&amp;gt;&amp;gt;&amp;gt; id(var1)
44045192
&amp;gt;&amp;gt;&amp;gt; id(var2)
43989032
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is easy to see that both variables have different identities. Now we
can expand both the list and the tuple with some new values and check
whether their identities are the same:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 += [4, 5]
&amp;gt;&amp;gt;&amp;gt; var2 += (4, 5)
&amp;gt;&amp;gt;&amp;gt; print(var1)
[1, 2, 3, 4, 5]
&amp;gt;&amp;gt;&amp;gt; print(var2)
(1, 2, 3, 4, 5)
&amp;gt;&amp;gt;&amp;gt; id(var1)
44045192
&amp;gt;&amp;gt;&amp;gt; id(var2)
30323024
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What you see in the code above is that we have appended the same values
to both the list (&lt;code&gt;var1&lt;/code&gt;) and the tuple (&lt;code&gt;var2&lt;/code&gt;). If we ask for the id
of them, you will notice that &lt;code&gt;var1&lt;/code&gt; has the same identity as before,
while &lt;code&gt;var2&lt;/code&gt; has a new identity. This means that we have expanded the
list, but created a completely new tuple. This is why memory management
is more efficient for lists than for tuples.&lt;/p&gt;
&lt;p&gt;Tuples are not the only immutable data type in Python, but they are a
great tool to learn because they can be directly compared to lists,
which are mutable. Other immutable data types are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;int&lt;/li&gt;
&lt;li&gt;float&lt;/li&gt;
&lt;li&gt;decimal&lt;/li&gt;
&lt;li&gt;complex&lt;/li&gt;
&lt;li&gt;bool&lt;/li&gt;
&lt;li&gt;string&lt;/li&gt;
&lt;li&gt;tuple&lt;/li&gt;
&lt;li&gt;range&lt;/li&gt;
&lt;li&gt;frozenset&lt;/li&gt;
&lt;li&gt;bytes&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Most likely you haven't thought about it before, but when you assign an
integer, float, etc. to a variable, it can't be replaced. So for
example, you will get an output like this if you check the identity of
an integer assigned to a variable:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 = 1
&amp;gt;&amp;gt;&amp;gt; id(var1)
1644063776
&amp;gt;&amp;gt;&amp;gt; var1 += 1
&amp;gt;&amp;gt;&amp;gt; id(var1)
1644063808
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You see that a completely new &lt;code&gt;var1&lt;/code&gt; is created when you add a value to
itself, therefore its identity changes. The same would happen with all
the other data types listed above. &lt;strong&gt;Mutable&lt;/strong&gt; objects, on the other
hand, are the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;list&lt;/li&gt;
&lt;li&gt;dictionary&lt;/li&gt;
&lt;li&gt;set&lt;/li&gt;
&lt;li&gt;bytearray&lt;/li&gt;
&lt;li&gt;user defined classes&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Those are the kind of objects that can be changed in-place, without
creating a new one to store the updated values. An interesting case
happens when you give two names to the same variable, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 = [0, 1, 2]
&amp;gt;&amp;gt;&amp;gt; var2 = var1
&amp;gt;&amp;gt;&amp;gt; id(var1)
44372872
&amp;gt;&amp;gt;&amp;gt; id(var2)
44372872
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both &lt;code&gt;var1&lt;/code&gt; and &lt;code&gt;var2&lt;/code&gt; have the same identity, this means that they are
labels to the same object. You can check it by using &lt;code&gt;is&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 is var2
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And if you update one of the values of &lt;code&gt;var1&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 += [3, 4, 5]
&amp;gt;&amp;gt;&amp;gt; print(var2)
[0, 1, 2, 3, 4, 5]
&amp;gt;&amp;gt;&amp;gt; var1 is var2
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You see that you updated the value of &lt;code&gt;var1&lt;/code&gt; and the value of &lt;code&gt;var2&lt;/code&gt;
also changed. This happens only with mutable types. With immutable
objects, since a new object is created in order to update a value, then
each name will be pointing to a different object. For example, with
strings:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 = 'abc'
&amp;gt;&amp;gt;&amp;gt; var2 = var1
&amp;gt;&amp;gt;&amp;gt; var1 is var2
True
&amp;gt;&amp;gt;&amp;gt; var1 += 'def'
&amp;gt;&amp;gt;&amp;gt; var1 is var2
False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Sometimes you would like to compare whether two variables have the same
values, and not if they point to the same object. For this, you can use
the &lt;code&gt;==&lt;/code&gt; operator. Let's define two lists (or two tuples) with the same
values:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; var2 = [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you check whether &lt;code&gt;var1&lt;/code&gt; and &lt;code&gt;var2&lt;/code&gt; are the same object, you will get
a negative answer:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 is var2
False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which is logical, because they have the same values, but they are two
distinct objects. If you want to compare their values instead, you can
do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; var1 == var2
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An interesting thing happens when you use the so-called singletons.
Let's quickly see an example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; a = 1
&amp;gt;&amp;gt;&amp;gt; b = 1
&amp;gt;&amp;gt;&amp;gt; a is 1
True
&amp;gt;&amp;gt;&amp;gt; a is b
True
&amp;gt;&amp;gt;&amp;gt; a == b
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, it is clear that any variable pointing to the same number will be
exactly the same object. The same happens for booleans, &lt;code&gt;None&lt;/code&gt;, etc. You
can do things like:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; a = True
&amp;gt;&amp;gt;&amp;gt; a is True
True
&amp;gt;&amp;gt;&amp;gt; b = None
&amp;gt;&amp;gt;&amp;gt; b is None
True
&amp;gt;&amp;gt;&amp;gt; b == None
True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using &lt;code&gt;is&lt;/code&gt; instead of &lt;code&gt;==&lt;/code&gt; has different advantages. The first is speed.
You can run the following in your command line:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;python -m timeit &amp;quot;1 == 1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;python -m timeit &amp;quot;1 is 1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In my case, I got that the first expression took on average 0.0207
microseconds to run, while the second took 0.0171 microseconds. Speed is
an obvious factor. The other is that when working with custom classes,
you can specify what happens when you compare them to other objects.
This is a very silly example but would prove the point:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    def __eq__(self, other):
        return True

my_obj = MyClass()

if my_obj == None:
    print('My object == None')

if my_obj is None:
    print('My Object is None')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the code above, the output would me &lt;code&gt;My Object == None&lt;/code&gt;.
Better be safe than sorry, and being aware of what the &lt;code&gt;==&lt;/code&gt; operator
means and when to use it or when to use &lt;code&gt;is&lt;/code&gt; can be very important.&lt;/p&gt;
&lt;h2&gt;Mutable Objects in Functions&lt;/h2&gt;
&lt;p&gt;We have just seen that if you have two mutable objects with the same id
it means that they are the same object. If you change one, you will
change the other. This also applies when working with functions that
take mutable objects as arguments. Imagine that you develop a function
that takes as input a list, divides all of its arguments by 2 and then
returns the average. The function would look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def divide_and_average(var):
    for i in range(len(var)):
        var[i] /= 2
    avg = sum(var)/len(var)
    return avg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is very interesting to see what happens when you use this function:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;my_list = [1, 2, 3]
print(divide_and_average(my_list))
print(my_list)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output will be:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;1.0
[0.5, 1.0, 1.5]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When you execute the function, you are actually changing the values of
the variable &lt;code&gt;my_list&lt;/code&gt;. This is very powerful because it allows you to
change the elements of a list &lt;em&gt;in-place&lt;/em&gt; while you are returning a
different element. Sometimes, however, you don't want to do this and
want to preserve the value of the original list. It may seem like a good
idea to create a new variable within the function and use that instead.
For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def divide_and_average(var1):
    var = var1
    [...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, you will see that this doesn't change the output. As we saw
earlier, the identity of &lt;code&gt;var&lt;/code&gt; and of &lt;code&gt;var1&lt;/code&gt; would be the same. You can
make a copy of your object using the &lt;code&gt;copy&lt;/code&gt; module:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import copy

def divide_and_average(var1):
    var = copy.copy(var1)
[...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now you will see that the original &lt;code&gt;my_list&lt;/code&gt; variable is not
altered. What we have just done is called a &lt;em&gt;shallow copy&lt;/em&gt; of an object.
It is also possible to perform a &lt;em&gt;deep&lt;/em&gt; copy, but its implications are
left for a different article.&lt;/p&gt;
&lt;h2&gt;Default Arguments in Functions&lt;/h2&gt;
&lt;p&gt;A common practice when you are defining a function is to assign default
values to its arguments. On the one hand, this allows you to include new
parameters without changing the downstream code, but it also allows you
to call the function with fewer arguments and thus making it easier to
use. Let's see, for example, a function that increases the value of the
elements of a list. The code would look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def increase_values(var1=[1, 1], value=0):
    value += 1
    var1[0] += value
    var1[1] += value
    return var1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you call this function without arguments, it will use the default
value &lt;code&gt;[1, 1]&lt;/code&gt; for the list and the default increase value of &lt;code&gt;0&lt;/code&gt;. What
happens if you use this function twice, without any arguments?&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;print(increase_values())
print(increase_values())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first time it will print &lt;code&gt;[2, 2]&lt;/code&gt; as expected, but the second time
it is going to print &lt;code&gt;[3, 3]&lt;/code&gt;. Where you actually expecting this
outcome? This basically means that the default argument of the function
is changing every time we run it. When we run the script, Python
evaluates the function definition only once and creates the default list
and the default value. Because lists are mutable, every time you call
the function you will be changing its own values for all the successive
calls. However, the &lt;code&gt;value&lt;/code&gt; is immutable, and therefore it will be
preserved over time.&lt;/p&gt;
&lt;p&gt;The next logical question is how can you prevent this from happening.
And the short answer is to use immutable types as default arguments for
functions. You could have used &lt;code&gt;None&lt;/code&gt;, for instance:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def increase_values(var1=None, value=0):
    if var1 is None:
        var1 = [1, 1]
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course, the decision is always yours. Perhaps you would like to
update the default value from one call to another. Imagine the case
where you would like to perform a computationally expensive calculation,
but you don't want to run twice the function with the same input and use
a cache of values instead. You could do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def calculate(var1, var2, cache={}):
    try:
        value = cache[var1, var2]
    except KeyError:
        value = expensive_computation(var1, var2)
        cache[var1, var2] = value
    return value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we run &lt;code&gt;calculate&lt;/code&gt; for the first time, there will be nothing stored
in the &lt;code&gt;cache&lt;/code&gt; dictionary, but if we execute the function more than
once, &lt;code&gt;cache&lt;/code&gt; will start changing, appending the new values to it. If we
run calculate again with the same arguments, they are going to be
present and their known value will be returned. Notice that we are
leveraging the &lt;a href="https://www.pythonforthelab.com/blog/learning-not-to-handle-exceptions"&gt;exception
handling&lt;/a&gt; in order to avoid
checking explicitly whether the combination of values already exists in
memory.&lt;/p&gt;
&lt;h2&gt;Your Own Immutable Objects&lt;/h2&gt;
&lt;p&gt;Python is very flexible and it gives you a lot of control over how to
customize its behavior. As you can see from the list at the beginning of
this article, custom created classes belong to the mutable types. But
what happens if you want to define your own immutable objects? The
answer is to modify how the class behaves when assigning attributes.
This means reimplementing the &lt;code&gt;__setattr__&lt;/code&gt; method.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyImmutable:
    def __setattr__(self, key, value):
        raise TypeError('MyImmutable cannot be modified after instantiation')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you instantiate the class and try to assign a value to an attribute
of it, an error will appear:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; my_immutable = MyImmutable()
&amp;gt;&amp;gt;&amp;gt; my_immutable.var1 = 2
Traceback (most recent call last):
  File &amp;quot;.\AE_custom_objects.py&amp;quot;, line 14, in &amp;lt;module&amp;gt;
    my_immutable.var1 = 2
  File &amp;quot;.\AE_custom_objects.py&amp;quot;, line 7, in __setattr__
    raise TypeError('MyImmutable cannot be modified after instantiation')
TypeError: MyImmutable cannot be modified after instantiation
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Great, you have an object that you can't modify after instantiation. But
that also means there is no much you can do with it. Imagine you would
like to store some initial values if you create a standard &lt;code&gt;__init__&lt;/code&gt;
method, it will fail:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyImmutable:
    def __init__(self, var1, var2):
        self.var1 = var1
        self.var2 = var2
    [...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As soon as you try to instantiate this class, the &lt;code&gt;TypeError&lt;/code&gt; will be
raised. Even within the class itself, assigning values to attributes is
achieved through the &lt;code&gt;__setattr__&lt;/code&gt; method. To bypass it, you need to use
the &lt;code&gt;super()&lt;/code&gt; object:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyImmutable:
    def __init__(self, var1, var2):
        super().__setattr__('var1', var1)
        super().__setattr__('var2', var2)

    def __setattr__(self, key, value):
        raise TypeError('MyImmutable cannot be modified after instantiation')

    def __str__(self):
        return 'MyImmutable var1: {}, var2: {}'.format(self.var1, self.var2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which now you can use as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; my_immutable = MyImmutable(1, 2)
&amp;gt;&amp;gt;&amp;gt; print(my_immutable)
MyImmutable var1: 1, var2: 2
&amp;gt;&amp;gt;&amp;gt; my_immutable.var1 = 2
[...]
TypeError: MyImmutable cannot be modified after instantiation
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is a bit of a workaround, but maybe you can find a use for this kind
of pattern.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;Understanding the differences between mutable and immutable types in
Python does not arise as an important topic until it is too late. In
most cases, you can develop complex applications exchanging tuples for
lists, or you may even be altering the value of a variable inside a
function without realizing it and without great consequences. But it
will eventually happen that you find a bug very hard to track down that
may be related to the use (or misuse) of mutable types.&lt;/p&gt;
&lt;p&gt;As a personal note, I found out such a bug performing a complex
experiment with a microscope. I wanted to be able to refocus
automatically on certain bright spots after an image was acquired. The
first time the algorithm was working fine. The second time it was pretty
much OK, but the third and onwards was not even close to reaching the
desired values. The root of the problem was defining the initial range
that the microscope would scan as a list, which was being divided by a
factor after every iteration.&lt;/p&gt;
&lt;p&gt;Some of the patterns you find in this article, probably are not going to
be of any use. However, it is important to keep in the back of your mind
that &lt;code&gt;==&lt;/code&gt; can give very unexpected results, that variables can change in
unexpected ways if you are not careful. When projects start to grow,
small mistakes can pile up to disastrous problems.&lt;/p&gt;
&lt;p&gt;As always, &lt;a href="https://github.com/PFTL/website/tree/master/example_code/17_mutable_immutable"&gt;example
code&lt;/a&gt;
is available and the &lt;a href="https://github.com/PFTL/website/blob/master/content/blog/17_mutable_and_immutable.rst.md"&gt;source
code&lt;/a&gt;
for this page also.&lt;/p&gt;
&lt;p&gt;If you want to keep learning, you can read more about
why tuples may seem to change &amp;lt;{filename}18_mutable_tuples.rst&amp;gt;_
and what happens when you use &lt;a href="https://www.pythonforthelab.com/blog/mutable-and-immutable-attributes-of-classes"&gt;mutable or immutable variables as class
attributes&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Header Photo by
&lt;a href="https://unsplash.com/photos/EF8Jr-uPS2Y?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText"&gt;rawpixel&lt;/a&gt;
on Unsplash&lt;/p&gt;</content><category term="blog"></category><category term="Data"></category><category term="Types"></category><category term="Mutable"></category><category term="Immutable"></category><category term="Objects"></category></entry><entry><title>Storing Data with SQLite</title><link href="https://www.pythonforthelab.com/blog/storing-data-with-sqlite" rel="alternate"></link><published>2018-08-12T00:00:00+02:00</published><updated>2018-08-12T00:00:00+02:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2018-08-12:/blog/storing-data-with-sqlite</id><summary type="html">&lt;p&gt;Using databases for storing data may sound much more complicated than
what it actually is. In this article, we are going to cover how to use
databases to store different types of data. We will quickly review how
you can search for specific parameters and how to get exactly what …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Using databases for storing data may sound much more complicated than
what it actually is. In this article, we are going to cover how to use
databases to store different types of data. We will quickly review how
you can search for specific parameters and how to get exactly what you
want.&lt;/p&gt;
&lt;p&gt;In the previous articles, we have seen how to store data into plain text
files, which is nothing more than a particular way of serializing our
objects. On the second release, we have seen how to serialize complex
objects using Python's built-in tools to save them as binary files. In
this article, we are going to explore another very useful module called
&lt;strong&gt;SQLite&lt;/strong&gt; which will allow us to store data in databases.&lt;/p&gt;
&lt;h2&gt;Databases&lt;/h2&gt;
&lt;p&gt;Most likely you have heard about databases in the context of websites.
It is where your username, email, and password are stored. It is where
the government saves all the information it has about you. However,
databases can also be used for smaller scale projects, such as a
software for controlling devices in the laboratory or for data analysis.&lt;/p&gt;
&lt;p&gt;The simplest form of a database can be thought as a table with columns
and rows. If you have ever used a spreadsheet, it looks exactly like
that. Pandas' Data Frames have the same format. Tables with a header for
each column and a different entry on each row. This really forces you to
be systematic in the way in which you store your information.&lt;/p&gt;
&lt;p&gt;Interacting with databases is a complex subject because it normally
involves learning a new scripting language in order to store and
retrieve information. In this tutorial, you are going to learn the
basics of one of these languages called SQL. Just with the basics, there
is a lot that you can achieve.&lt;/p&gt;
&lt;p&gt;Something important to point out is that normally you need to install
more software in order to use a database. If you have ever heard of
MySQL or Postgres, you are probably aware that those are big libraries
that need an entire course on themselves. However, Python bundles
SQLite, a very simple, single-file database. No extra software needed to
run the examples here.&lt;/p&gt;
&lt;h2&gt;Creating a Table&lt;/h2&gt;
&lt;p&gt;Let's start quickly with SQLite. The first thing you need to do to work
with databases is to create the database itself. In the case of SQLite,
this is going to be a file. It is as easy as this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import sqlite3

conn = sqlite3.connect('AA_db.sqlite')
conn.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When you use &lt;code&gt;connect&lt;/code&gt;, SQLite will try to open the file that you are
specifying and if it doesn't exist, it will create a new one. Once you
have the database, you need to create a table in it. This is where the
SQL language that I mentioned before comes into play. Let's assume you
want to create a table that stores two variables, the description of an
experiment and the name of the person who performed it. You would do the
following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import sqlite3

conn = sqlite3.connect('AA_db.sqlite')
cur = conn.cursor()
cur.execute('CREATE TABLE experiments (name VARCHAR, description VARCHAR)')
conn.commit()

conn.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After opening (or creating) the database, we have to create a cursor.
The cursor is going to allow you to execute the SQL code. To create a
table, we need to use the following command:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;CREATE TABLE experiments (name VARCHAR, description VARCHAR)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is quite descriptive: you are creating a table called experiments
with two columns: &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;description&lt;/code&gt;. Each one of those columns
will be of type &lt;code&gt;VARCHAR&lt;/code&gt;. Don't worry too much about it right now. The
&lt;code&gt;commit&lt;/code&gt; command saves the changes to the database and then you close
the connection. Congratulations, you have created your first table!&lt;/p&gt;
&lt;p&gt;The problem right now is that there is no feedback on what you have
done. If you are using PyCharm, for example, it comes with a built-in
SQLite implementation. Therefore, you can just click on the file and you
will be able to navigate through the contents of the database. You can
also try an application like &lt;a href="https://sqlitebrowser.org/"&gt;SQLite
browser&lt;/a&gt; to visualize the files. There is
also a &lt;a href="https://addons.mozilla.org/en-US/firefox/addon/sqlite-manager/?src"&gt;Firefox
Add-On&lt;/a&gt;.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;The extension .sqlite is not mandatory. If you use it, many higher level
programs will identify it as a database and will be able to open it with
a double-click. You can also use the .db extension, which is more common
if following Flask or Django tutorials.&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;Adding Data to a Database&lt;/h2&gt;
&lt;p&gt;Now that you have a database, is time to store some data into it. All
the examples always start by creating a connection and a cursor, which
we are going to skip from now on, but you should include in your code.
Adding information to a database also involves the use of SQL. You will
need to do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;cur.execute('INSERT INTO experiments (name, description) values (&amp;quot;Aquiles&amp;quot;, &amp;quot;My experiment description&amp;quot;)')
conn.commit()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can run this command as many times as you want, and if you are
checking your database with an external tool, you will see that you keep
adding rows to the table. As you see above, the SQL code can give rise
to problems if you are using variables instead of plain text.&lt;/p&gt;
&lt;p&gt;Imagine that you try to save a string that includes the character &lt;code&gt;"&lt;/code&gt;.
SQL will think that the &lt;code&gt;"&lt;/code&gt; from your variable is actually closing the
argument and it will give an error. Even worse, if it is a variable
submitted by someone else, this can give rise to something called SQL
injection. In the same way, in which Pickle can be used to run arbitrary
code, SQL can be tricked to perform unwanted operations. Soon enough you
will be able to understand the &lt;a href="https://xkcd.com/327/"&gt;XKCD SQL injection
joke&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A proper way of adding new values to a table is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;cur.execute('INSERT INTO experiments (name, description) VALUES (?, ?)',
            ('Another User', 'Another Experiment, even using &amp;quot; other characters&amp;quot;'))
conn.commit()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assuming that the access to the database is only yours, i.e. you are not
going to take variables from the public, you shouldn't worry too much
about safety. In any case, it is important to be aware.&lt;/p&gt;
&lt;h2&gt;Retrieving Data&lt;/h2&gt;
&lt;p&gt;Now that you have some data stored in the database, we need to be able
to retrieve it. You can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;cur.execute('SELECT * FROM experiments')
data = cur.fetchall()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first line is asking for all the columns from experiments. That is
what the &lt;code&gt;*&lt;/code&gt; means. The second line is actually getting the values. We
have used &lt;code&gt;fetchall()&lt;/code&gt;, but you could have also used &lt;code&gt;fetchone()&lt;/code&gt; to get
just one element.&lt;/p&gt;
&lt;p&gt;So far, nothing particularly special. Imagine that you want to get only
the entries where a particular user was involved. You can do the
following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;cur.execute('SELECT * FROM experiments WHERE name=&amp;quot;Aquiles&amp;quot;')
data_3 = cur.fetchall()
&lt;/code&gt;&lt;/pre&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;SQL is not case sensitive for its commands. SELECT or select or Select
mean the same. However, if you change Aquiles for aquiles, the results
are going to be different.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Of course, it can also happen that there are no entries matching your
criteria and therefore the result is going to be an empty list. Again,
remember that what we are looking for, &lt;code&gt;Aquiles&lt;/code&gt; may be a variable, and
again you are exposed to SQL errors if you have special characters.&lt;/p&gt;
&lt;p&gt;At this point, there are two concerns that may have come up to your
mind. On one hand, there is no way to refer to specific entries in the
database. Two different entries, with the same content, are
indistinguishable from each other.&lt;/p&gt;
&lt;p&gt;The other is more of a feature request. Imagine that you would like to
store more information about the user, not just the name. It doesn't
make sense to add extra columns to the experiments database, because we
would be duplicating a lot of information. Ideally, we would start a new
table, just to register users and their information.&lt;/p&gt;
&lt;h2&gt;Adding a Primary Key&lt;/h2&gt;
&lt;p&gt;If you have ever seen any spreadsheet program or even a Pandas Data
Frame, you have probably noticed that every row is identified with a
number. This is very handy because once you learn that the important
information is on line N, you just remember that number and retrieve the
data specifically.&lt;/p&gt;
&lt;p&gt;The table that we have created does not include this numbering, also
known as a primary key. Adding a new column is normally not a problem,
but since we are dealing with a primary key, SQLite does not allow us to
do it in a single step. We should create a new table, copy the contents
of the old one, etc. Since we only have toy data, we can start from
scratch.&lt;/p&gt;
&lt;p&gt;First, we will remove the table from the database, losing all its
contents. Then we will create a new table, with its primary key and we
will add some content to it. We can do everything with a very long SQL
command instead of running multiple &lt;code&gt;cur.execute()&lt;/code&gt;. For that, we use
the triple-quote notation of Python:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;sql_command = &amp;quot;&amp;quot;&amp;quot;
DROP TABLE IF EXISTS experiments;
CREATE TABLE experiments (
    id INTEGER,
    name VARCHAR,
    description VARCHAR,
    PRIMARY KEY (id));
INSERT INTO experiments (name, description) values (&amp;quot;Aquiles&amp;quot;, &amp;quot;My experiment description&amp;quot;);
INSERT INTO experiments (name, description) values (&amp;quot;Aquiles 2&amp;quot;, &amp;quot;My experiment description 2&amp;quot;);
&amp;quot;&amp;quot;&amp;quot;
cur.executescript(sql_command)
conn.commit()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The important part here is the SQL command. First, we drop the table if
it exists. If it doesn't exist, it will throw an error and the rest of
the code will not be executed. Then, we create a new table, with one new
column called &lt;code&gt;id&lt;/code&gt;, of type integer. At the end of the statement, we
defined that &lt;code&gt;id&lt;/code&gt; as the primary key of the table. Finally, we add two
elements to the table.&lt;/p&gt;
&lt;p&gt;If you run the retrieval code again, you will notice that each element
has a unique number that identifies it. If we want to fetch the first
(or the second, etc.) element, we can simply do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;cur.execute('SELECT * FROM experiments WHERE id=1')
data = cur.fetchone()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that we are using &lt;code&gt;fetchone&lt;/code&gt; instead of &lt;code&gt;fetchall&lt;/code&gt; because we
know that the output should be only one element. Check what is the
difference if you use one or the other command in the data that you get
from the database.&lt;/p&gt;
&lt;p&gt;Adding a primary key is fundamental to decrease the time it takes to
fetch the data that you are looking for. Not only because it allows you
to refer to specific entries, but also because of how databases work, it
is much faster addressing data by their key.&lt;/p&gt;
&lt;h2&gt;Default Values for Fields&lt;/h2&gt;
&lt;p&gt;So far we have used only two types of variables: &lt;code&gt;VARCHAR&lt;/code&gt; and
&lt;code&gt;INTEGER&lt;/code&gt;. The varchar has been used for the name of the person doing
the experiment and its description, while the integer is used only for
the &lt;code&gt;id&lt;/code&gt; number. However, we can develop much more complex tables. For
example, we can specify not only the type but also limits to the length.
We can also specify default values, simplifying the operations when
storing new entries to a table. One of the advantages of doing this is
that our data is going to be very consistent.&lt;/p&gt;
&lt;p&gt;Imagine that you want to store also the date at which the experiment is
run, you could add an extra field and every time you create a new
experiment, you also add a field with the date, or you instruct the
database to automatically add the date. At the moment of creating the
table, you should do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;DROP TABLE IF EXISTS experiments;
CREATE TABLE experiments (
    id INTEGER,
    name VARCHAR,
    description VARCHAR,
    perfomed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (id));
INSERT INTO experiments (name, description) values (&amp;quot;Aquiles&amp;quot;, &amp;quot;My experiment description&amp;quot;);
INSERT INTO experiments (name, description) values (&amp;quot;Aquiles 2&amp;quot;, &amp;quot;My experiment description 2&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note the new field called &lt;code&gt;performed_at&lt;/code&gt;, which uses &lt;code&gt;TIMESTAMP&lt;/code&gt; as its
type, and it also specifies a &lt;code&gt;DEFAULT&lt;/code&gt; value. If you check the two
inserted experiments (you can use the code of the previous example) you
will see that there is a new field with the current date and time. You
can also add default values for other fields, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;CREATE TABLE experiments (
    id INTEGER,
    name VARCHAR DEFAULT &amp;quot;Aquiles&amp;quot;,
    description VARCHAR ,
    perfomed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (id));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next time you add a new experiment, if you don't specify the user who
performed it, it will default to &lt;code&gt;Aquiles&lt;/code&gt; (my name). Specifying
defaults is a very useful way of avoiding missing information. For
example, the &lt;code&gt;performed_at&lt;/code&gt; will always be added. This ensures that even
if someone forgets to explicitly declare the time of an experiment, at
least a very reasonable assumption has been made.&lt;/p&gt;
&lt;h2&gt;SQLite Data Types&lt;/h2&gt;
&lt;p&gt;SQLite is different from other database managers, such as MySQL or
Postgres because of its flexibility regarding data types and lengths.
SQLite defines only &lt;a href="https://www.sqlite.org/datatype3.html"&gt;4 types of
fields&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NULL. The value is a NULL value.&lt;/li&gt;
&lt;li&gt;INTEGER. The value is a signed integer, stored in 1, 2, 3, 4, 6, or
    8 bytes depending on the magnitude of the value.&lt;/li&gt;
&lt;li&gt;REAL. The value is a floating point value, stored as an 8-byte IEEE
    floating point number.&lt;/li&gt;
&lt;li&gt;TEXT. The value is a text string, stored using the database encoding
    (UTF-8, UTF-16BE or UTF-16LE).&lt;/li&gt;
&lt;li&gt;BLOB. The value is a blob of data, stored exactly as it was input.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And then it defines something called affinities, which specifies the
preferred type of data to be stored in a column. This is very useful to
maintain compatibility with other database sources and can generate some
headaches if you are following tutorials designed for other types of
databases. The type we have used, &lt;code&gt;VARCHAR&lt;/code&gt; is not one of the specified
datatypes, but it is supported through the affinities. It will be
treated as a &lt;code&gt;TEXT&lt;/code&gt; field.&lt;/p&gt;
&lt;p&gt;The way SQLite manages data types, if you are new to databases, is not
important. If you are not new to databases, you should definitely look
at the
official documentation &amp;lt;https://www.sqlite.org/datatype3.html&amp;gt;_
in order to understand the differences and make the best out of the
capabilities.&lt;/p&gt;
&lt;h2&gt;Relational Databases&lt;/h2&gt;
&lt;p&gt;Perhaps you have already heard about relational databases. So far, in
the way we have used SQLite, it is hard to see advantages compared to
plain CSV files, for example. If you are just storing a table, then you
could perfectly do the same with a spreadsheet or a Pandas Data Frame.
The power of databases is much more noticeable when you start making
relationships between fields.&lt;/p&gt;
&lt;p&gt;In the examples that we have discussed earlier, you have seen that when
you run an experiment you would like to store who was to the user
performing the measurement. The number of users is most likely going to
be limited and perhaps you would like to keep track of some information,
such as the name, email and phone number.&lt;/p&gt;
&lt;p&gt;The way to organize all of this information is by creating a table in
which you store the users. Each entry will have a primary key. From the
table experiments, instead of storing the name of the user, you store
the key of the user. Moreover, you can specify that, when creating a new
experiment, the user associated with the experiment already exists. All
this is achieved through the use of foreign keys, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;DROP TABLE IF EXISTS experiments;
DROP TABLE IF EXISTS users;
CREATE TABLE  users(
    id INTEGER,
    name VARCHAR,
    email VARCHAR,
    phone VARCHAR,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (id));
CREATE TABLE experiments (
    id INTEGER,
    user_id INTEGER,
    description VARCHAR ,
    perfomed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (id)
    FOREIGN KEY (user_id) REFERENCES users(id));
&lt;/code&gt;&lt;/pre&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;depending on your installation of SQLite, you may need to add support
for foreign keys. Run the following command when creating the database
to be sure: &lt;code&gt;cur.execute("PRAGMA foreign_keys = ON;")&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;First, you need to create a new user, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;INSERT INTO users (name, email, phone) values (&amp;quot;Aquiles&amp;quot;, &amp;quot;example@example.com&amp;quot;, &amp;quot;123456789&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then you can create a new experiment:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;INSERT INTO experiments (user_id, description) values (1, &amp;quot;My experiment description&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that if you try to add an experiment with a user_id that does not
exist, you will get an error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;INSERT INTO experiments (user_id, description) values (2, &amp;quot;My experiment description&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When you run the code above using Python, you will get the following
message:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;sqlite3.IntegrityError: FOREIGN KEY constraint failed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which is exactly what we were expecting. Note, however, that if you
leave the &lt;code&gt;user_id&lt;/code&gt; out, i.e., if you don't specify a value, it will
default to &lt;code&gt;Null&lt;/code&gt;, which is valid (an experiment without a user). If you
would like to prevent this behavior, you will need to specify it
explicitly:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;CREATE TABLE experiments (
    id INTEGER,
    user_id INTEGER NOT NULL ,
    description VARCHAR ,
    perfomed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (id)
    FOREIGN KEY (user_id) REFERENCES users(id));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we have specified that the &lt;code&gt;user_id&lt;/code&gt; is &lt;code&gt;NOT NULL&lt;/code&gt;. If we try to run
the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;INSERT INTO experiments (description) values (&amp;quot;My experiment description 2&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It will raise the following error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;sqlite3.IntegrityError: NOT NULL constraint failed: experiments.user_id
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Storing Numpy Arrays into Databases&lt;/h2&gt;
&lt;p&gt;Storing complex data into databases is not a trivial task. Databases
specify only some data types and numpy arrays are not between them. This
means that we have to convert the arrays into something that can be
stored in a database. Since SQLite specifies only 4 major data types, we
should stick to one of them. In the &lt;a href="https://www.pythonforthelab.com/blog/storing-binary-data-and-serializing"&gt;previous
article&lt;/a&gt; we have discussed a lot
about serialization. The same ideas can be used to store an array in a
database.&lt;/p&gt;
&lt;p&gt;For example, you can use Pickle in order to transform your data into
bytes and store them using base64 as a &lt;code&gt;TEXT&lt;/code&gt; field. You could also
store the Pickle object directly into a &lt;code&gt;BLOB&lt;/code&gt;field. You can convert
your array into a list and separate its values with &lt;code&gt;,&lt;/code&gt; or use a
specific notation to separate rows and columns, etc. However, SQLite
offers also the possibility of registering new data types. As explained
in &lt;a href="https://stackoverflow.com/a/18622264/4467480"&gt;this answer on Stack
Overflow&lt;/a&gt; we need to
create an adapter and a converter:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import sqlite3
import numpy as np
import io

def adapt_array(arr):
    out = io.BytesIO()
    np.save(out, arr)
    out.seek(0)
    return sqlite3.Binary(out.read())

def convert_array(text):
    out = io.BytesIO(text)
    out.seek(0)
    return np.load(out)

sqlite3.register_adapter(np.ndarray, adapt_array)
sqlite3.register_converter(&amp;quot;array&amp;quot;, convert_array)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What we are doing in the code above is to tell SQLite what to do when a
field of type &lt;code&gt;array&lt;/code&gt; is declared. When we are storing the field, it
will be transformed into bytes, that can be stored as a BLOB in the
database. When retrieving the data, we are going to read the bytes and
transform them into a numpy array. Note that this is possible because
the methods &lt;code&gt;save&lt;/code&gt; and &lt;code&gt;load&lt;/code&gt; know how to deal with bytes when
saving/loading.&lt;/p&gt;
&lt;p&gt;It is important to note that it is not necessary to register both
adapter and converter. The first one is responsible for transforming a
specific data type into an SQLite-compatible object. You could do this
to automatically serialize your own classes, etc. The converter is
responsible for converting back into your object. You can play around
and see what happens when you don't register one of the two.&lt;/p&gt;
&lt;p&gt;When you define your table, you can use your newly created 'array' data
type:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;DROP TABLE IF EXISTS measurements;
CREATE TABLE measurements (
    id INTEGER PRIMARY KEY,
    description VARCHAR ,
    arr array);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is important to note that for the above code to work when you start
the connection with the database, you should add the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;conn = sqlite3.connect('AI_db.sqlite', detect_types=sqlite3.PARSE_DECLTYPES)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The option &lt;code&gt;PARSE_DECLTYPES&lt;/code&gt; is telling SQLite to use the registered
adapters and converters. If you don't include that option, it will not
use what you have registered and will default to the standard data
types.&lt;/p&gt;
&lt;p&gt;To store the array, you can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;x = np.random.rand(10,2)
cur.execute('INSERT INTO measurements (arr) values (?)', (x,))
cur.execute('SELECT arr FROM measurements')
data = cur.fetchone()
print(data)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will transform your array into bytes, and it will store it in the
database. When you read it back, it will transform the Bytes back into
an array.&lt;/p&gt;
&lt;p&gt;What you have to keep in mind is that when you store numpy arrays (or
any non-standard object) into a database, you lose the intrinsic
advantages of databases, i.e. the capabilities to operate on the
elements. What I mean is that with SQL it is very easy to replace a
field in all the entries that match a criterion, for example, but you
won't be able to do that for a numpy array, at least with SQL commands.&lt;/p&gt;
&lt;h2&gt;Combining Information&lt;/h2&gt;
&lt;p&gt;So far, we have seen how to create some tables with values, and how to
relate them through the use of primary and foreign keys. However, SQL is
much more powerful than that, especially when retrieving information.
One of the things that you can do is to join the information from
different tables into a single table. Let's see quickly what can be
done. First, we are going to re-create the tables with the experiments
and the users, as we have seen before. You can check the &lt;a href="https://github.com/PFTL/website/blob/master/example_code/15_databases/AH_foreign_key.py"&gt;code in
here&lt;/a&gt;.
You should have two entries for users and two entries for the
experiments.&lt;/p&gt;
&lt;p&gt;You can run the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import sqlite3

conn = sqlite3.connect('AH_db.sqlite')
cur = conn.cursor()

sql_command = &amp;quot;&amp;quot;&amp;quot;
SELECT users.id, users.name, experiments.description
FROM experiments
INNER JOIN users ON experiments.user_id=users.id;
&amp;quot;&amp;quot;&amp;quot;
cur.execute(sql_command)
data = cur.fetchall()

for d in data:
    print(d)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What you will see printed is the id of the user, the name and the
description of the experiment. This is much handier than just seeing the
id of the user because you immediately see the information that you
need. Moreover, you can filter the results based on the properties of
either of the tables. Imagine you want to get the experiments performed
by &lt;code&gt;'Aquiles'&lt;/code&gt;, but you don't know its user id. You can change the
command above to the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT users.id, users.name, experiments.description
    FROM experiments
    INNER JOIN users ON experiments.user_id=users.id
    WHERE users.name=&amp;quot;Aquiles&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And you will see that only the data related to that user is retrieved.&lt;/p&gt;
&lt;p&gt;Join statements are complex and very flexible. You probably noticed that
we have used the &lt;code&gt;INNER JOIN&lt;/code&gt; option, but it is not the only
possibility. If you want to combine tables that are not related through
a foreign key, for example, you would like to combine data from
different sources that belong to the same day, you can use other types
of joins. The diagram in &lt;a href="https://www.w3schools.com/sql/sql_join.asp"&gt;this
website&lt;/a&gt; is very explicit,
but going through the details exceeds the capabilities of an
introductory tutorial.&lt;/p&gt;
&lt;h2&gt;How to Use Databases in Scientific Projects&lt;/h2&gt;
&lt;p&gt;Leveraging the power of databases is not obvious for first-time
developers, especially if you don't belong to the web-development realm.
One of the main advantages of databases is that you don't need to keep
in memory the entire structure. For example, Imagine that you would have
a very large project, with millions of measurements of thousands of
experiments with hundreds of users. Most likely you can't load all the
information as in memory variables.&lt;/p&gt;
&lt;p&gt;By using databases, you will be able to filter the measurements done by
a specific user in a given time frame, or that match a specific
description without actually loading everything into memory. Even if
simple, this example already shows you a very clear use case where Data
Frames or numpy arrays would fail.&lt;/p&gt;
&lt;p&gt;Databases are used in many large-scale scientific projects, such as
astronomical observations, simulations, etc. By using databases,
different groups are able to give users access to filtering and joining
capabilities, getting the desired data and not the entire collection. Of
course, for small groups, it may look like an overshoot. But imagine
that you could filter through your data, acquired during years, to find
a specific measurement.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;One of the main challenges of using databases is that they require
learning a new language called SQL. In this article we have tried to
point to the most basic concepts, that would allow anyone to get started
and build his/her way up through clever Google searches.&lt;/p&gt;
&lt;p&gt;Python has built-in support for SQLite, a file-based database that is
ideal for getting started. There is no further setting up involved,
everything works out of the box, and many of the tutorials that can be
found online relating to SQL will also work with SQLite.&lt;/p&gt;
&lt;p&gt;Using databases for one-off projects may be an overkill, but for
long-running programs, such as software for controlling setups or custom
data analysis it may open the door to very creative solutions. Combining
databases for metadata and files for data has the added advantage of a
high portability (sharing data is sharing just a file) and an easy way
to search through the collection of metadata stored onto a database.&lt;/p&gt;
&lt;p&gt;Header photo by &lt;a href="https://unsplash.com/photos/PkbZahEG2Ng?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText"&gt;Tobias
Fischer&lt;/a&gt;
on Unsplash&lt;/p&gt;</content><category term="blog"></category><category term="Data"></category><category term="Storing"></category><category term="SQLite"></category><category term="HDF5"></category><category term="ascii"></category><category term="json"></category><category term="Data Storage"></category></entry><entry><title>Storing Binary Data and Serializing</title><link href="https://www.pythonforthelab.com/blog/storing-binary-data-and-serializing" rel="alternate"></link><published>2018-08-11T00:00:00+02:00</published><updated>2018-08-11T00:00:00+02:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2018-08-11:/blog/storing-binary-data-and-serializing</id><summary type="html">&lt;p&gt;Last week we have seen how to store data into plain text files that can
be read by any editor or by other programs. We have also seen that if
you separate your data with commas your file will follow a standard and
it will be automatically compatible with other …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Last week we have seen how to store data into plain text files that can
be read by any editor or by other programs. We have also seen that if
you separate your data with commas your file will follow a standard and
it will be automatically compatible with other applications, such as
spreadsheets. One of the main limitations of this strategy is that if
the data itself contains a comma, your file will not be readable
anymore.&lt;/p&gt;
&lt;p&gt;In this article, we are going to discuss the encoding of data. This will
allow us to understand how come that what you save with Python can be
read by a normal text editor or your web browser. We will also see that
you can save space on your disk if you encode your data in the proper
way. In the end what you will have is a clear picture of the difference
between saving plain text files and binary data.&lt;/p&gt;
&lt;h2&gt;What does it really mean to save text files&lt;/h2&gt;
&lt;p&gt;Last week you have seen different ways of saving text files. One of the
most noticeable attributes is that those files can be opened with any
basic text editor, you don't need Python to read them. This already
should indicate that there is an underlying property that allows
programs to share files with each other.&lt;/p&gt;
&lt;p&gt;As you have probably heard already, computers don't understand about
letters or colors, they only understand about 1's and 0's. This means
that there should be a way of translating that kind of information into
a letter (or a number, or a color). The way of converting from one to
another type of representation is called an encoding. Probably you have
already heard about ascii or Unicode. Those are standards that specify
how to translate from a stream of bytes (i.e. 1's and 0's) to the
letters you are seeing now on the screen.&lt;/p&gt;
&lt;p&gt;ASCII stands for American Standard Code for Information Interchange. It
is a specification on how to translate bytes to characters and
vice-versa. If you look at the &lt;a href="https://www.asciitable.com/"&gt;ASCII
table&lt;/a&gt;, you see that it specifies how to
translate numbers from 0 to 127 to characters. 128 options is not a
random choice, it is 7-bit or all the combinations that a sequence of 7
1's and 0's can generate. You can see also the extended ascii table,
which adds all the characters up to a number of 255 (i.e. 8-bit).&lt;/p&gt;
&lt;p&gt;Let's do a quick test. We can create an array of integers between 0 and
255 (8-bit) and store it to a file, and then compare the size of that
file with the size of the array. The code will look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import sys
import numpy as np

x = np.linspace(0, 255, 256, dtype=np.uint8)

with open('AA_data.dat', 'w') as f:
    for data in x:
        f.write(str(data)+'\n')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each element of the array is 8-bits long (or 1 byte). We are storing 256
elements, and therefore we expect the file to be 256 bytes in size.
However, if you check it, you will see that it is bigger than that:
around 914 bytes. This difference is not negligible, so where is it
coming from?&lt;/p&gt;
&lt;p&gt;We have stored 256 elements, but there more numbers in the file. 10
elements are 1-digit long, 90 are 2-digits and 156 are 3-digits long. In
total, there are 658 digits, plus 256 newline characters. If you add
them up you get exactly 914. This means that each character is taking
exactly 1 byte or 8 bits. If you are on Windows, there is an extra
consideration, because the new line character gets replaced by two
characters and therefore you need to add 512 characters instead of 256.&lt;/p&gt;
&lt;p&gt;When you want to write a &lt;code&gt;1&lt;/code&gt;, it takes 1 byte. However, when you store a
&lt;code&gt;10&lt;/code&gt; it will take 2 bytes. You have to remember that, in the space of
integer numbers of 8 bits, they both take the same amount of memory.
With this simple example, you start seeing that there are a lot of small
details that you have to take into account when saving data.&lt;/p&gt;
&lt;h2&gt;Different encodings for text data&lt;/h2&gt;
&lt;p&gt;You may have realized in the previous section that ASCII is limited to a
special set of characters. If you want to write characters of other
languages, for example, such as the Spanish ñ, you will need to resort
to other standards. This gave rise to a myriad of different encodings,
with a small degree of compatibility between them. If you are
&lt;a href="https://notepad-plus-plus.org/"&gt;Notpad++&lt;/a&gt; user you can see on the menu
that you can select the &lt;em&gt;encoding&lt;/em&gt; for the file.&lt;/p&gt;
&lt;p&gt;When you open a text file, the program needs to translate from bytes to
characters, basically by looking up on a table. If you change that
table, you change the output. If you use text editors such as
&lt;a href="https://notepad-plus-plus.org/"&gt;Notpad++&lt;/a&gt; you will see that you can
specify the encoding of the file. Select &lt;em&gt;encoding&lt;/em&gt; on the menu and then
&lt;em&gt;character sets&lt;/em&gt; and you will find tons of options. If you play with it,
you will see that the output may change, especially if there are special
characters from other languages.&lt;/p&gt;
&lt;p&gt;The problem got worst with websites having users from different
countries expecting to use different character sets. That is why a
superseding standard appeared, called
&lt;a href="https://en.wikipedia.org/wiki/Unicode"&gt;Unicode&lt;/a&gt;. Unicode includes and
expands the ascii table with up to 32-bit characters, which is billions
of different choices. Unicode includes thousands of symbols from modern
and ancient languages, plus all the emojis you are already familiar
with.&lt;/p&gt;
&lt;p&gt;If you want to specify the encoding used while saving a file, you can do
the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import codecs

data_to_save = 'Data to Save'
with codecs.open('AB_unicode.dat', 'w', 'utf-8') as f:
    f.write(data_to_save)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the code above, the important part is the line that says &lt;code&gt;utf-8&lt;/code&gt;.
Unicode has different implementations, and each one uses a different
amount of bits per character. You can choose between 8, 16 and 32. You
can also change the encoding to &lt;code&gt;ascii&lt;/code&gt;. As an exercise, compare how
much space it takes every time you save the data. Open the file being
saved with a text editor and check if you can see the message.&lt;/p&gt;
&lt;h2&gt;Saving Numpy Arrays&lt;/h2&gt;
&lt;p&gt;Last week we have seen that it is possible to save numpy arrays into
text files that can be read by any editor. This means that the
information will be converted to ascii (or Unicode) and then written to
a file. It is very easy to calculate how much space it will take, based
on the number of digits that you are storing. Numpy also offers another
way of storing data, in binary format.&lt;/p&gt;
&lt;p&gt;What we have done in the past was transforming a number to its
representation as characters, which will allow us to read it back on the
screen. However, sometimes we don't want to read back, we just want our
programs to be able to load the information back. Therefore, we could
store directly the bytes to disk and not their representation as
strings.&lt;/p&gt;
&lt;p&gt;Let's start by creating an array and then we save it both as numpy
binary and as ascii to compare between them:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import numpy as np

a = np.linspace(0, 1000, 1024, dtype=np.uint8)

np.save('AC_binay', a)

with open('AC_ascii.dat', 'w') as f:
    for i in a:
        f.write(str(i)+'\n')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You will end up with two different files, one called 'AC_binary.npy'
and the other called 'AC_ascii.dat'. The latter can be opened with any
text editor, while the first one will give you a very weird looking
file. If you compare the size, you will notice that the binary file is
using less memory than the ascii file.&lt;/p&gt;
&lt;p&gt;First, you have to note something strange about the code above. We are
specifying the type of our array to &lt;code&gt;np.uint8&lt;/code&gt;, which means that we are
using 8-bit integers. With 8-bits you can go up to &lt;code&gt;2^8-1&lt;/code&gt;, or &lt;code&gt;255&lt;/code&gt;.
Moreover, since we are generating a linear space between 0 and 1000 with
1024 elements, each one is going to be rounded off. Anyways, this
discussion is for you to start thinking about different data types and
what do they mean. If you inspect the ascii file, you will notice that
the numbers increase up to 255 and then they start again from 0.&lt;/p&gt;
&lt;p&gt;So, we have 1024 numbers, each one taking 8-bits, or equivalently 1
byte. The array, therefore, will take 1KB (1 kilobyte), but the file we
are saving is larger than that (around 1.12KB). You can do the math for
the ascii file and see that you can predict its size. Let's create,
instead, a file with an array of ones:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import numpy as np

a = np.ones((1024), dtype=np.uint8)

np.save('AD_binay', a)

with open('AD_ascii.dat', 'w') as f:
    for i in a:
        f.write(str(i)+'\n')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first thing to notice is that the ascii file is now smaller than in
the example above. You are saving two characters per element (the 1 and
the newline character), while before you could have up to 4 characters
per line. However, the numpy binary file has exactly the same size. What
happens if you run the code above, but specifying the type of the array
as &lt;code&gt;np.uint16&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;You will see that the ascii file is still taking the same space, exactly
2KB (or 3KB on Windows). However, the numpy binary format is taking more
space, exactly 1KB more. The array itself takes 2KB of memory, and there
is an extra 0.12KB, exactly as before. This already gives us a hint of
what is going on, but you can keep testing. Change the type to
&lt;code&gt;np.uint32&lt;/code&gt; and you will see that the ascii files are still the same
size, but the binary file is taking 2KB more than before. Again, you are
saving 4KB to a file that takes 4.12KB.&lt;/p&gt;
&lt;p&gt;Those extra .12KB that numpy is saving are equivalent to the header we
were generating in the previous article. Binary files also need to store
context information in order to be interpreted. You also have to notice
that what you are storing is not 'just' a number, you are storing also
its data type. Next time you read that file, you will have an 8, 16 or
32-bit variable. The ascii file, on the other hand, doesn't have that
information.&lt;/p&gt;
&lt;p&gt;With these examples, it may even look like that saving ascii files is
more efficient than saving binary files. Let's see what happens if you
have more than just 1's in your array:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import numpy as np

a = np.linspace(0,65535,65536, dtype=np.uint16)
np.save('AE_binay', a)
with open('AE_ascii.dat', 'w') as f:
    for i in a:
        f.write(str(i)+'\n')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Compare the size of the two files and try to understand why are they so
different.&lt;/p&gt;
&lt;h2&gt;Intro to Pickle&lt;/h2&gt;
&lt;p&gt;So far we have discussed how to save strings or numpy arrays to a file.
However, Python allows you to define several types of data structures,
such as lists, dictionaries, custom objects, etc. You can think about
how to transform a list into a series of strings and use the opposite
operation to recover the variable. This is what we have done when
writing arrays to plain text files.&lt;/p&gt;
&lt;p&gt;However, this is very cumbersome, because is very susceptible to small
changes. For example, it is not the same saving a list of numbers than a
list that mixes numbers and strings. Fortunately, Python comes with a
package that allows us to save almost everything we want, called
&lt;strong&gt;Pickle&lt;/strong&gt;. Let's first see it in action and then discuss how it works.&lt;/p&gt;
&lt;p&gt;Imagine you have a list that mixes some numbers and some strings and you
want to save them to a file, you can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import pickle

data = [1, 1.2, 'a', 'b']

with open('AF_custom.dat', 'wb') as f:
    pickle.dump(data, f)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you try to open the file &lt;em&gt;AF_custom.dat&lt;/em&gt; with a text editor you will
see a collection of strange characters. It is important to note that we
have opened the file as &lt;code&gt;wb&lt;/code&gt;, meaning that we are writing just as
before, but that the file is opened in binary format. This is what
allows Python to write a stream of bytes to a file.&lt;/p&gt;
&lt;p&gt;If you want to load the data back into Python, you can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with open('AF_custom.dat', 'rb') as f:
    new_data = pickle.load(f)

print(new_data)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, check that we have used &lt;code&gt;rb&lt;/code&gt; instead of just &lt;code&gt;r&lt;/code&gt; for opening the
file. Then you just load the contents of &lt;code&gt;f&lt;/code&gt; into a variable called
&lt;code&gt;new_data&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Pickle is transforming an object, in the example above a list, into a
series of bytes. That procedure is called serialization. The algorithm
responsible for serializing the information is particular to Python and
therefore it is not compatible out of the box with other programming
languages. In the context of Python, serializing an object is called
&lt;em&gt;pickling&lt;/em&gt; and when you deserialize it is called &lt;em&gt;unpickling&lt;/em&gt;.&lt;/p&gt;
&lt;h2&gt;Pickling numpy arrays&lt;/h2&gt;
&lt;p&gt;You can use Pickle to save other kinds of variables. For example, you
can use it to store a numpy array. Let's compare what happens when you
use the default numpy &lt;code&gt;save&lt;/code&gt; method and Pickle:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import numpy as np
import pickle

data = np.linspace(0, 1023, 1000, dtype=np.uint8)

np.save('AG_numpy', data)

with open('AG_pickle.dat', 'wb') as f:
    pickle.dump(data, f)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As in the examples earlier, the numpy file will take exactly 1128 bytes.
1000 are for the data itself and 128 are for the extra information. The
pickle file will take 1159 bytes, which is not bad at all, considering
that it is a general procedure and not specific to numpy.&lt;/p&gt;
&lt;p&gt;To read the file, you do exactly the same as before:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with open('AG_pickle.dat', 'rb') as f:
    new_data = pickle.load(f)

print(new_data)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you check the data you will see that it is actually a numpy array. If
you run the code in an environment in which numpy is not installed, you
will see the following error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;Traceback (most recent call last):
  File &amp;quot;AG_pickle_numpy.py&amp;quot;, line 14, in &amp;lt;module&amp;gt;
    new_data = pickle.load(f)
ModuleNotFoundError: No module named 'numpy'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, you already see that pickle is doing a lot of things under the hood,
like trying to import numpy.&lt;/p&gt;
&lt;h2&gt;Pickling Functions&lt;/h2&gt;
&lt;p&gt;To show you that Pickle is very flexible, you will see how you can store
functions. Probably you already heard that everything in Python is an
object, and Pickle is, in fact, a way of serializing objects. Therefore
it doesn't really matter what it actually is that you are storing. For a
function, you would have something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def my_function(var):
    new_str = '='*len(var)
    print(new_str+'\n'+var+'\n'+new_str)

my_function('Testing')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which is a simple example of a function. It surrounds the text with &lt;code&gt;=&lt;/code&gt;
signs. Storing this function is exactly the same as storing any other
object:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import pickle

with open('AH_pickle_function.dat', 'wb') as f:
    pickle.dump(my_function, f)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And to load it and use it you would do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with open('AH_pickle_function.dat', 'rb') as f:
    new_function = pickle.load(f)

new_function('New Test')
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Limitations of Pickle&lt;/h2&gt;
&lt;p&gt;In order for Pickle to work, you need to have available the definition
of the object you are pickling. In the examples above, you have seen
that you need to have numpy installed in order to unpickle an array.
However, if you try to unpickle your function from a different file than
the one you used to create it, you will get the following error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 2, in &amp;lt;module&amp;gt;
AttributeError: Can't get attribute 'my_function' on &amp;lt;module '__main__' (built-in)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you want to unpickle a function in a different file (as most likely
is going to be the case), you can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import pickle
from AH_pickle_function import my_function

with open('AH_pickle_function.dat', 'rb') as f:
    new_function = pickle.load(f)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, of course, you can wonder what is the use of this. If you imported
&lt;code&gt;my_function&lt;/code&gt;, you don't need to load the pickled file. And this is
true. Storing a function or a class doesn't make a lot of sense, because
in any case, you have it defined. The biggest difference is when you
want to store an instance of a class. Let's define a class that stores
the time at which it is instantiated:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import pickle
from time import time
from datetime import datetime

class MyClass:
    def __init__(self):
        self.init_time = time()

    def __str__(self):
        dt = datetime.fromtimestamp(self.init_time)
        return 'MyClass created at {:%H:%M on %m-%d-%Y}'.\
            format(dt)

my_class = MyClass()
print(my_class)

with open('AI_pickle_object.dat', 'wb') as f:
    pickle.dump(my_class, f)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you do this, you will have an object that stores the time at which it
was created and if you &lt;code&gt;print&lt;/code&gt; that object, you will see the date nicely
formatted. Pay attention also to the fact that that you are saving
&lt;code&gt;my_class&lt;/code&gt; and not &lt;code&gt;MyClass&lt;/code&gt; to the pickled file. This means that you
are saving an instance of your class, with the attributes that you have
defined.&lt;/p&gt;
&lt;p&gt;From a second file, you would like to load what you have saved. You need
to import the &lt;code&gt;MyClass&lt;/code&gt; class, but the instance itself will be what you
saved:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import pickle
from AI_pickle_object import MyClass


with open('AI_pickle_object.dat', 'rb') as f:
    new_class = pickle.load(f)

print(new_class)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that we are not importing &lt;code&gt;time&lt;/code&gt; nor &lt;code&gt;datetime&lt;/code&gt;, just &lt;code&gt;pickle&lt;/code&gt;
for loading the object and the class itself. Pickle is a great tool when
you want to save the specific state of an object in order to keep up
with the work later.&lt;/p&gt;
&lt;h2&gt;Risks of Pickle&lt;/h2&gt;
&lt;p&gt;If you look around, you will definitely find a lot of people warning the
Pickle is not safe to use. The main reason is that when you unpickle,
arbitrary code could be executed on the machine. If you are the only one
using the files, or you definitely trust the one who gave you the file,
there will be no problems. If you are building an online service,
however, unpickling data that was sent by a random user may have
consequences.&lt;/p&gt;
&lt;p&gt;When Pickle runs, it will look for a special method on the class called
&lt;code&gt;__reduce__&lt;/code&gt; that specifies how an object is pickled and unpickled.
Without entering too much into detail, you can specify a callable that
will be executed while unpickling. In the example above, you can add the
extra method to &lt;code&gt;MyClass&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    def __init__(self):
        self.init_time = time()

    def __str__(self):
        dt = datetime.fromtimestamp(self.init_time)
        return 'MyClass created at {:%H:%M:%S on %m-%d-%Y}'.\
            format(dt)

    def __reduce__(self):
        return (os.system, ('ls',))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Run the code again to save the pickled file. If you run the file to load
the pickled object you will see that all the contents of the folder in
which you executed the script are shown. &lt;strong&gt;Windows&lt;/strong&gt; users may not see
it happening because depending on whether you use Power Shell or CMD,
the command &lt;code&gt;ls&lt;/code&gt; is not defined.&lt;/p&gt;
&lt;p&gt;This is a very naïve example. Instead of &lt;code&gt;ls&lt;/code&gt; you could erase a file,
open a connection to an external attacker, send all the files to a
server, etc. You can see that if you open the door to others to execute
commands in your computer, eventually something very bad is going to
happen.&lt;/p&gt;
&lt;p&gt;The scenario of a security risk with Pickle is extremely low for the
vast majority of end users. The most important thing is to trust the
source of your pickled files. If it is yourself, a colleague, etc. then
you should fine. If the source of your pickled files is not trustworthy,
you should be aware of the risks.&lt;/p&gt;
&lt;p&gt;You may wonder why Python opens this security risk. The answer is that
by being able to define how to unpickle an object, you can become much
more efficient at storing data. The idea is that you can define how to
reconstruct an object and not necessarily all the information that it
contains. In the case of the numpy arrays, imagine you define a matrix
of 1024X1024 elements, all ones (or zeroes). You can store each value,
which will take a lot of memory, or you can just instruct Python to run
numpy and create the matrix, which doesn't take that much space (is only
one line of code).&lt;/p&gt;
&lt;p&gt;Having control is always better. If you want to be sure that nothing bad
is going to happen, you have to find other ways of serializing data.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;If you are using Pickle as in the examples above, you should consider
changing &lt;code&gt;pickle&lt;/code&gt; for &lt;code&gt;cPickle&lt;/code&gt; which is the same algorithm but written
directly in C and runs much faster.&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;Serializing with JSON&lt;/h2&gt;
&lt;p&gt;The main idea behind serialization is that you transform an object into
something else, that can be 'easily' stored or transmitted. Pickle is a
very convenient way but with some limitations regarding security.
Moreover, the results of Pickle are not human readable, so it makes it
harder to explore the contents of a file.&lt;/p&gt;
&lt;p&gt;JavaScript Object Notation, or JSON for short, became a popular standard
for exchanging information with web services. It is a definition on how
to structure strings that can be later converted to variables. Let's
first see a simple example with a dictionary:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import json

data = {
    'first': [0, 1, 2, 3],
    'second': 'A sample string'
}

with open('AK_json.dat', 'w') as f:
    json.dump(data, f)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you open the file you will notice that the result is a text file that
can be easily read with a text editor. Moreover, you can quickly
understand what the data is just by looking at the contents of the file.
You can also define more complex data structures, such as a combination
of lists and dictionaries, etc. To read back a json file, you can do the
following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with open('AK_json.dat', 'r') as f:
    new_data = json.load(f)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Json is very handy because it can structure the information in such a
way that can be shared with other programming languages, transmitted
over the network and easily explored if saved to a file. However, if you
try to save an instance of a class, you will get an error like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;TypeError: Object of type 'MyClass' is not JSON serializable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JSON will not work with numpy arrays out of the box either.&lt;/p&gt;
&lt;h2&gt;Combining JSON and Pickle&lt;/h2&gt;
&lt;p&gt;As you have seen, JSON is a way of writing text to a file, structured in
a way that makes it easy to load back the information and transform it
to a list, a dictionary, etc. On the other hand, Pickle transforms
objects into bytes. It would be great to combine both, to write the
bytes to a text file. Combining plain text and bytes can be a good idea
if you would like to explore parts of the file by eye while keeping the
possibility of saving complex structures.&lt;/p&gt;
&lt;p&gt;What we are after is not that complex. We need a way of transforming
bytes into an ASCII string. If you remember the discussion at the
beginning of this article, there is a standard called ASCII that
transforms bytes into characters that you can read. When the internet
started to catch up, people needed to transfer more than just plain
words. Therefore, a new standard appeared, in which you can translate
bytes into characters. This is called &lt;code&gt;Base64&lt;/code&gt; and is supported by most
programming languages, not just Python.&lt;/p&gt;
&lt;p&gt;As an example, we will generate a numpy array, we will pickle it and
then we are going to create a dictionary that holds that array and the
current time. The code looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import pickle
import json
import numpy as np
import time
import base64

np_array = np.ones((1000, 2), dtype=np.uint8)
array_bytes = pickle.dumps(np_array)
data = {
    'array': base64.b64encode(array_bytes).decode('ascii'),
    'time': time.time(),
}

with open('AL_json_numpy.dat', 'w') as f:
    json.dump(data, f)
&lt;/code&gt;&lt;/pre&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;In the example above, we are using &lt;code&gt;pickle.dumps&lt;/code&gt; instead of
&lt;code&gt;pickle.dump&lt;/code&gt;, which returns the information instead of writing it to a
file.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;You can go ahead and look at the file. You will see that you can read
some parts of it, like the words 'array' and the time at which it was
created. However, the array itself is a sequence of characters that
don't make much sense. If you want to load the data back, you need to
repeat the steps in the opposite order:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import pickle
import base64
import json

with open('AL_json_numpy.dat', 'r') as f:
    data = json.load(f)


array_bytes = base64.b64decode(data['array'])

np_array = pickle.loads(array_bytes)
print(data['time'])
print(np_array)
print(type(np_array))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first step is to open the file and read it. Then, you grab the
base64 encoded pickle and decode it. The output is directly the pickled
array, which you proceed to unpickle. You can print the values and see
that effectively you have recovered the numpy array.&lt;/p&gt;
&lt;p&gt;At this point, there are two questions that you may be asking yourself.
Why going through the trouble of pickling, encoding and serializing
through json instead of just pickling the &lt;code&gt;data&lt;/code&gt; dictionary. And why
have we pickled first the array and then encoded in base 64 instead of
writing the output of pickle.&lt;/p&gt;
&lt;p&gt;First, going to the trouble is justified if you look at your data with
other programs. Having files which store extra information that can be
easily read is very handy to quickly decide if it is the file you want
to read or not. For example, you can open the file with a text editor,
see that the date is not the one you were interested in and move
forward.&lt;/p&gt;
&lt;p&gt;The second question is a bit deeper. Remember that when you are writing
to a plain text file, you are assuming a certain encoding. The most
common one nowadays being utf-8. This limits a lot the way in which you
can write bytes to disk because you have only a finite set of characters
you can use. Base64 takes care of using just the allowed characters.&lt;/p&gt;
&lt;p&gt;However, you have to remember that base64 was developed to transmit data
over the network a long time ago. That makes base64 slower and less
memory efficient than what it could be. Nowadays you don't need to be
limited by the ascii specification thanks to Unicode. However, sticking
to standards is a good practice if you want compatibility of your code
in different systems.&lt;/p&gt;
&lt;h2&gt;Other Serialization Options&lt;/h2&gt;
&lt;p&gt;We have seen how to serialize objects with Pickle and JSON, however,
they are not the only two options. There are no doubts that they are the
most popular ones, but you may face the challenge of opening files
generated by other programs. For instance, LabView normally uses XML
instead of JSON to store data.&lt;/p&gt;
&lt;p&gt;While JSON translates very easily to python variables, XML is a bit more
complicated. Normally, XML files come from an external source, such as a
website or another program. To load the data on those files, you need to
rely on
&lt;a href="https://docs.python.org/3/library/xml.etree.elementtree.html"&gt;ElementTree&lt;/a&gt;.
Check the link to see the official documentation to see how it works.&lt;/p&gt;
&lt;p&gt;Another option is YAML. It is a simple markup language that, such as
Python, uses spaces to delimit blocks of content. The advantage of YAML
is that it is easy to type. For instance, imagine that you are using
text files as input for your program. While you respect the tabbing, the
file will be easily parsed. A YAML file looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;data:
  creation_date: 2018-08-08
  values: [1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To read the file, you need to install a package called PyYAML, simply
with &lt;code&gt;pip&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install pyyaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the script to read looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import yaml

with open('AM_example.yml', 'r') as f:
    data = yaml.load(f)

print(data)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also write a yaml file:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import yaml
from time import time

data = {
    'values': [1, 2, 3, 4, 5],
    'creation_date': time(),
}

with open('AM_data.yml', 'w') as f:
    yaml.dump(data, f)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is beyond the scope of this article to discuss YAML, but you can find
a lot of information online. YAML is still not a standard, but it is
gaining traction. Writing configuration files in YAML feels very
natural. There is much less typing involved than with XML and it looks
more organized, at least to me than JSON.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;In this article, we have discussed serialization of objects and how to
store them on the hard drive. We have started discussing what an
encoding is, and started to think about converting from and to bytes.
This opened the door to understand what Pickle does and how to save the
data to disk.&lt;/p&gt;
&lt;p&gt;Remember that Pickle is not perfect and you have to be aware of its
limitations, especially if you are going to deal with user submitted
files, such as what happens on a web server. On the other hand, if you
are using it for storing data for yourself, it is a very efficient way.&lt;/p&gt;
&lt;p&gt;We have also discussed how to use JSON, a very popular tool for web
technologies. The limit of JSON is, however, that you have to store data
as text files, thus limiting its native capabilities. Fortunately,
combining &lt;code&gt;Pickle&lt;/code&gt; and &lt;code&gt;base64&lt;/code&gt;, you can transform bytes to an ascii
string and save it next to easy to read metadata.&lt;/p&gt;
&lt;p&gt;This article has gone much more in depth regarding how to store data in
different formats, but the topic is far from complete. Keep tuned to
find more articles regarding how to save data with Python.&lt;/p&gt;
&lt;p&gt;Header photo by &lt;a href="https://unsplash.com/photos/LqKhnDzSF-8?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText"&gt;Joshua
Sortino&lt;/a&gt;
on Unsplash&lt;/p&gt;</content><category term="blog"></category><category term="Data"></category><category term="Storing"></category><category term="SQLite"></category><category term="HDF5"></category><category term="ascii"></category><category term="json"></category><category term="Data Storage"></category></entry><entry><title>Introduction to Storing Data in Files</title><link href="https://www.pythonforthelab.com/blog/introduction-to-storing-data-in-files" rel="alternate"></link><published>2018-08-10T00:00:00+02:00</published><updated>2018-08-10T00:00:00+02:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2018-08-10:/blog/introduction-to-storing-data-in-files</id><summary type="html">&lt;p&gt;Storing data to reuse it later is a central part in most Python
applications. Whether you are doing a measurement in the lab or
developing a web application, you will need to save information in a
persistent way. For example, you would like to analyze your results
after you have …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Storing data to reuse it later is a central part in most Python
applications. Whether you are doing a measurement in the lab or
developing a web application, you will need to save information in a
persistent way. For example, you would like to analyze your results
after you have performed an experiment. Or you would like to keep a list
of e-mails of people who registered on your website.&lt;/p&gt;
&lt;p&gt;Even if storing data is of utmost importance, every application will
require different strategies. You have to take into account different
factors, such as the volume of data being generated, how
self-descriptive the data is, how are you going to use it later, etc. In
this article, we are going to start exploring different ways of storing
data.&lt;/p&gt;
&lt;h2&gt;Plain Text Files with Numpy&lt;/h2&gt;
&lt;p&gt;When storing data on the hard drive, a common option is to use plain
text files. Let's start with a simple example, a &lt;code&gt;numpy&lt;/code&gt; array of a
given length. We can generate such an array in the following way:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import numpy as np

data = np.linspace(0,1,201)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which will generate an array of 201 values equally spaced between 0 and
1. This means that the elements will look like &lt;code&gt;0, 0.005, 0.01, ..&lt;/code&gt;. If
you want to save the data to a file, numpy allows you to do it very
easily with the &lt;code&gt;savetxt&lt;/code&gt; method, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;np.savetxt('A_data.dat', data)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Go ahead and open the file &lt;strong&gt;a_data.dat&lt;/strong&gt; with any text editor. You
will see that you have a column of all the values in your array. This is
very handy because the file can be read with any other program that
supports reading text files. So far, this example is very simplistic
because it stores only one array. Imagine that you want to store two
arrays, like the ones needed to make a simple plot. First, let's
generate both arrays:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;x = np.linspace(0, 1, 201)
y = np.random.random(201)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can store them very easily by doing the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;np.savetxt('AA_data.dat', [x, y])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you open the file, you will see that instead of having two columns,
the file has only two very long lines. This is normally not a problem,
but it makes your file very hard to read if you open it with a text
editor or with other programs. If you want to save the data as two (or
several) columns, you need to stack them. The code would look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;data = np.column_stack((x, y))
np.savetxt('AA_data.dat', data)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Check the file again, you will see that you have the x values on the
column on the left and the y values on the other. A file like this is
easier to read and, as we will see later, allows you to do partial
reads. However, there is something very important missing. If someone
opens the file, there is no information on what each column means. The
easier solution, in this case, is to add a header describing each
column:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;header = &amp;quot;X-Column, Y-Column&amp;quot;
np.savetxt('AB_data.dat', data, header=header)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Check the file again, you will see a nice header explaining what each
column is. Note that the first character of the line is a &lt;code&gt;#&lt;/code&gt;. This is
very standard in order to easily identify which lines belong to the
header and not to the data itself. If you want to add a multi-line
header, you can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;header = &amp;quot;X-Column, Y-Column\n&amp;quot;
header += &amp;quot;This is a second line&amp;quot;
np.savetxt('AB_data.dat', data, header=header)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The important element to note in the code above is the &lt;code&gt;\n&lt;/code&gt; added at the
end of the first line. This is the new line character, which is
equivalent to pressing &lt;code&gt;enter&lt;/code&gt; in your keyboard when typing a document.
This character tells Python to go to the line below when writing
information to a file.&lt;/p&gt;
&lt;h3&gt;Loading Saved Data with Numpy&lt;/h3&gt;
&lt;p&gt;Of course, saving to a file is only half what you have to do. The other
half is reading it. Fortunately, this is very easy with numpy:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;data = np.loadtxt('AB_data.dat')
x = data[:, 0]
y = data[:, 1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that it automatically discards the headers. The advantage of using
always the same library (in this case numpy) is that it makes it
incredibly easy to go through the write/read cycle. If you are trying to
read data from a file that was generated with another program and that
uses another character for starting comments, you can very easily adapt
the code above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;data = np.loadtxt('data.dat', comments='@')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the example above, the code will skip all the lines that start with
an &lt;code&gt;@&lt;/code&gt; symbol.&lt;/p&gt;
&lt;h2&gt;Saving Partial Files with Numpy&lt;/h2&gt;
&lt;p&gt;One common situation is to save to file while the data acquisition or
generation is happening. This allows you, for example, to monitor the
progress of an experiment and to have the data safe even if something
goes wrong with your program. The code is very similar to what we have
done earlier, but not exactly the same:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import numpy as np

x = np.linspace(0, 1, 201)
y = np.random.random(201)

header = &amp;quot;X-Column, Y-Column\n&amp;quot;
header += &amp;quot;This is a second line&amp;quot;
f = open('AD_data.dat', 'wb')
np.savetxt(f, [], header=header)
for i in range(201):
    data = np.column_stack((x[i], y[i]))
    np.savetxt(f, data)

f.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first thing you have to notice is that we are explicitly opening the
file with the command &lt;code&gt;open&lt;/code&gt;. The important portion of information here
is the &lt;code&gt;wb&lt;/code&gt; that we added at the end. The &lt;code&gt;w&lt;/code&gt; stands for &lt;em&gt;writing&lt;/em&gt; mode,
i.e. the file will be created if it doesn't exist, and if it already
exists it will be erased and started from scratch. The second letter,
the &lt;code&gt;b&lt;/code&gt; is for binary mode, which is needed for letting numpy append
data to a file. In order to generate the header, we first save an empty
list with the header. Within the for-loop, we save every value to the
file, line by line.&lt;/p&gt;
&lt;p&gt;With the example above, if you open the file you will see it exactly as
earlier. However, if you add a &lt;code&gt;sleep&lt;/code&gt; statement within the for-loop,
and open the file, you will see the partial saves. Remember that not all
operating systems allow you to open the file in two different programs
at the same time. Moreover, not all text editors are able to notice
changes to the file from outside themselves, meaning that you won't see
the changes to the file unless you re-open it.&lt;/p&gt;
&lt;h3&gt;Flushing Changes&lt;/h3&gt;
&lt;p&gt;If you start saving partial data often, you will notice that, especially
when your program crashes, some of the data points may be missing.
Writing to disk is a step that is handled by the operating system, and
therefore its behavior can be very different depending on which one you
use and how busy the computer is. Python puts the writing instructions
into a queue, which means that the writing itself can be executed much
later in time. If you want to be sure that changes are being written,
especially when you are aware that your program may give rise to
&lt;a href="https://www.pythonforthelab.com/blog/learning-not-to-handle-exceptions"&gt;unhandled exceptions&lt;/a&gt;, you
can add the &lt;code&gt;flush&lt;/code&gt; command. Simply like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;f = open('AD_data.dat', 'wb')
for i in range(201):
    [...]
    f.flush()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will guarantee that you are writing to disk every single time.
Python normally relies on the operating system defaults for handling
buffering of writing events. However, when trying to push the limits, it
is very important to regain control and be aware of what the
consequences may be.&lt;/p&gt;
&lt;h3&gt;The With Statement&lt;/h3&gt;
&lt;p&gt;When working with files, it is important to ensure that you are closing
it when you finish with it. If you don't do it, you may end up with
corrupted data. In the example above, you can see that if an error
appears within the &lt;code&gt;for&lt;/code&gt;, the line &lt;code&gt;f.close()&lt;/code&gt; will never be executed.
In order to avoid this kind of issues, Python provides the &lt;code&gt;with&lt;/code&gt;
statement. You can use it like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with open('AE_data.dat', 'wb') as f:
    np.savetxt(f, [], header=header)
    for i in range(201):
        data = np.column_stack((x[i], y[i]))
        np.savetxt(f, data)
        f.flush()
        sleep(0.1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first line is the key element here. Instead of doing &lt;code&gt;f=open()&lt;/code&gt;, we
use the &lt;code&gt;with&lt;/code&gt; statement. The file will be open while we are inside the
block. As soon as the block finishes, the file will be closed, even if
there is an exception within the block. The &lt;code&gt;with&lt;/code&gt; allows you to save a
lot of typing since you don't need to handle exceptions nor to close the
file afterward. It may seem like a small gain at the beginning, but the
conscious developer should use it extensively.&lt;/p&gt;
&lt;p&gt;The details of the &lt;code&gt;with&lt;/code&gt; statement deserve their own article, which is
in the pipeline for the future. For the time being, remember what it
means when you see it.&lt;/p&gt;
&lt;h2&gt;Lower-level Writing to Text Files&lt;/h2&gt;
&lt;p&gt;Up to here, we have seen how to use numpy to save data because it is a
standard in many applications. However, it may not fit all the
applications. Python has its own method for writing to and reading from,
files. Let's start writing to a file. The pattern is very simple:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;f = open('BA_data.dat', 'w')
f.write('# This is the header')
f.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or with the &lt;code&gt;with&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with open('BA_data.dat', 'w') as f:
    f.write('# This is the header')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;open&lt;/code&gt; command takes at least one argument, the filename. The second
argument is the mode with which the file is opened. Basically, there are
three: &lt;code&gt;r&lt;/code&gt; for reading, not modifying, &lt;code&gt;a&lt;/code&gt; for appending or creating the
file if it doesn't exist, &lt;code&gt;w&lt;/code&gt; for creating an empty file, even if it
already exists. If no mode is given, &lt;code&gt;r&lt;/code&gt; is assumed, and if the file
doesn't exist, a &lt;code&gt;FileNotFound&lt;/code&gt; exception will be raised.&lt;/p&gt;
&lt;p&gt;Now that we have the header written to the file, we want to write some
data to it. For example, we can try the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;x = np.linspace(0,1,201)
with open('BB_data.dat', 'w') as f:
    f.write('# This is the header')
    for data in x:
        f.write(data)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, you will see an error, &lt;code&gt;TypeError&lt;/code&gt;, because you are trying to
write something that is not a string, in this case, a numpy number.
Therefore, first, you have to transform whatever you want to write to a
string. For numbers, it is very easy, you only need to replace one line:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;f.write(str(data))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you open the file, you will notice something very strange. The header
and all the elements of your array were written to the same line, no
separation whatsoever between them. This is actually expected if you
think about it. Because you are using lower level commands, you have a
much more precise control over what and how you write to a file.&lt;/p&gt;
&lt;p&gt;If you remember from the previous section, you can use the &lt;code&gt;\n&lt;/code&gt;
character to generate a new line after writing to a file. Your code will
look like the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;x = np.linspace(0,1,201)
with open('BB_data.dat', 'w') as f:
    f.write('# This is the header\n')
    for data in x:
        f.write(str(data)+'\n')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you open the file again, you will see that all your data points are
nicely stacked on top of each other. You will also notice that not all
values have the same length. For example, you will find elements such as
&lt;code&gt;0.01&lt;/code&gt;, &lt;code&gt;0.005&lt;/code&gt;, and &lt;code&gt;0.17500000000000002&lt;/code&gt;. The first two make sense,
however, the third one may seem odd. The last digit in that number is
given because of floating-point errors. You can read more about it in
the &lt;a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html"&gt;Oracle
website&lt;/a&gt;
(more technical) or &lt;a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic#Floating-point_numbers"&gt;on
Wikipedia&lt;/a&gt;
(more general public-oriented).&lt;/p&gt;
&lt;h2&gt;Formatting the output&lt;/h2&gt;
&lt;p&gt;One of the most important things to consider when writing data to disk
is how to structure it in order to make it easy to read afterward. In
the section above, we have seen that if you don't append a newline
character after every value, they get printed one after the other, on
the same line. This makes your data almost impossible to read back.
Since every number has a different length, you can't break the line into
smaller information blocks, etc.&lt;/p&gt;
&lt;p&gt;Formatting the output is therefore very important to give sense to your
data in the long run. Python offers different ways for formatting
strings. I will choose the one I normally employ, but you are free to
explore other alternatives. Let's first adapt the example above, with
&lt;code&gt;format&lt;/code&gt;. You can print every value to a different line like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;x = np.linspace(0,1,201)
with open('BC_data.dat', 'w') as f:
    f.write('# This is the header\n')
    for data in x:
        f.write('{}\n'.format(data))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the code, the output file will be the same. When you use
&lt;code&gt;format&lt;/code&gt;, the &lt;code&gt;{}&lt;/code&gt; gets replaced by the data. It is equivalent to the
&lt;code&gt;str(data)&lt;/code&gt; that we have used before. However, imagine that you want to
output all the values with the same amount of characters, you can
replace that last line by:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;f.write('{:.2f}\n'.format(data))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which will give you values like &lt;code&gt;0.00&lt;/code&gt;, &lt;code&gt;0.01&lt;/code&gt;, etc. What you put in
between the &lt;code&gt;{}&lt;/code&gt; is the format string, which instructs Python how to
transform your numbers into strings. In this case, it is telling it to
treat the numbers as fixed point with 2 decimals. In principle, it looks
very nice, but notice that you are losing information. The values like
&lt;code&gt;0.005&lt;/code&gt; are rounded to &lt;code&gt;0.01&lt;/code&gt;. Therefore, you have to be very certain
about what do you want to achieve, in order not to lose important
information. If you are performing an experiment with 0.1 precision, you
don't care about 0.005, but if it is not the case, you have lost half
your information.&lt;/p&gt;
&lt;p&gt;Proper formatting takes a bit of tinkering. Since we want to store at
least three decimals, we should change the line to:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;f.write('{:.3f}\n'.format(data))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you are storing all the decimals up to the third place. Formatting
strings deserve a post on its own. But you can see the basic options
here. If you are working with integers, for instance, or with larger
floating point numbers (not between 0 and 1), you may want to specify
how much space the numbers are going to take. For instance, you can try:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import numpy as np

x = np.linspace(0,100,201)
with open('BC_data.dat', 'w') as f:
    for data in x:
        f.write('{:4.1f}\n'.format(data))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This command is letting Python know that each number should be allocated
4 spaces in total, with only one decimal place. Since the first numbers
have only 3 characters (&lt;code&gt;0.5&lt;/code&gt;), there will be a space preceding the
number. Later on, &lt;code&gt;10.0&lt;/code&gt; will start right from the beginning, and the
decimals will be nicely aligned. However, you will notice that &lt;code&gt;100.0&lt;/code&gt;
is displaced by one position (it takes 5, not 4 spaces).&lt;/p&gt;
&lt;p&gt;You can play a lot with the formatting. You can align the information to
the left or to the right, adding spaces or any other character on either
side, etc. I promise to cover this topic later on. But for now it is
enough, let's keep storing data to a file.&lt;/p&gt;
&lt;h2&gt;Storing Data in Columns&lt;/h2&gt;
&lt;p&gt;Let's recover the example from before, where we stored two columns of
data. We would like to do the same, without the use of numpy's
&lt;code&gt;savetxt&lt;/code&gt;. With what we know of formatting we can already do this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import numpy as np

x = np.linspace(0,100,201)
y = np.random.random(201)

with open('BD_data.dat', 'w') as f:
    for i in range(len(x)):
        f.write('{:4.1f} {:.4f}\n'.format(x[i], y[i]))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Check the saved file, you will see the two columns of data, separated by
a space. You can change the &lt;code&gt;write&lt;/code&gt; line in different ways, for example,
you could have:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;f.write('{:4.1f}\t{:.4f}\n'.format(x[i], y[i]))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which will add a tab between the columns, and not a space. You can
structure your file as you like. However, you have to be careful and
think ahead about how you are going to retrieve the data in case an
inconsistency appears.&lt;/p&gt;
&lt;h2&gt;Reading the data&lt;/h2&gt;
&lt;p&gt;After we have saved the data to a file, it is very important to be able
to read it back into our program. The first approach is unorthodox, but
it will prove a point. You can read the data generated with the &lt;code&gt;write&lt;/code&gt;
method using numpy's &lt;code&gt;loadtxt&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import numpy as np

data = np.loadtxt('BD_data.dat')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One of the advantages of writing text files is that they are relatively
easy to read from any other program. Even your text editor can make
sense of what is inside one of such files. Of course, you can also read
the file without using numpy, just with Python's built-in methods. The
easiest would be:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with open('BD_data.dat', 'r') as f:
    data = f.read()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, if you look into data, you will notice that it is a string.
After all, plain text files are just strings. Depending on how you have
structured the file, transforming the data into an array, a list, etc.
may be more or less simple. However, before going into those details,
another way of reading the file is line by line:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with open('BD_data.dat', 'r') as f:
    data = f.readline()
    data_2 = f.readline()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case, &lt;code&gt;data&lt;/code&gt; will hold the header, because it is the first line
of the file, while &lt;code&gt;data_2&lt;/code&gt; will hold the first line of data. Of course,
this only reads the first two lines of the file. To read all the lines,
we can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with open('BD_data.dat', 'r') as f:
    line = f.readline()
    header = []
    data = []
    while line:
        if line.startswith('#'):
            header.append(line)
        else:
            data.append(line)
        line = f.readline()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you see that things are getting more complicated. After opening the
file, we read the first line and then we enter into a loop, that will
keep running while there are more lines in the file. We start two empty
lists to hold the header and the data information. For each line, we
check whether it starts with &lt;code&gt;#&lt;/code&gt;, which would correspond to the header
(or comment). We append the rest of the lines to &lt;code&gt;data&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If you look into the &lt;code&gt;data&lt;/code&gt; variable, you will notice that it is not
very usable. If you are reading the example with the two columns, you
will see that &lt;code&gt;data&lt;/code&gt; is a list in which every element looks like
&lt;code&gt;0.0\t0.02994\n&lt;/code&gt;. If we want to reconstruct the information we had
before, we have to reverse the procedure of writing. The first thing to
note is that both values are separated by a &lt;code&gt;\t&lt;/code&gt;, therefore our code
would look like the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with open('BD_data.dat', 'r') as f:
    line = f.readline()
    header = []
    x = []
    y = []
    while line:
        if line.startswith('#'):
            header.append(line)
        else:
            data = line.split('\t')
            x.append(float(data[0]))
            y.append(float(data[1]))
        line = f.readline()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The beginning looks the same, but we have separated the data into &lt;code&gt;x&lt;/code&gt;
and &lt;code&gt;y&lt;/code&gt;. The biggest modification, in this case, is that we apply the
method &lt;code&gt;split&lt;/code&gt; to separate a string. Since our columns are delimited by
a tab, we use the character &lt;code&gt;\t&lt;/code&gt;. Data will have two elements, i.e. two
columns, and we append each to x and y. Of course, we don't want the
strings, but the numbers. That is why we transform &lt;code&gt;data&lt;/code&gt; into floats.&lt;/p&gt;
&lt;p&gt;With the steps above you can see that it is possible to recover the
functionality of the &lt;code&gt;loadtxt&lt;/code&gt; of numpy, but with a lot of effort. The
code above works only if you have two columns if you had a file with
just 1 column, or with more than 2 it would fail. &lt;code&gt;loadtxt&lt;/code&gt; didn't ask
explicitly how many columns to expect, it just parsed the text and found
out by itself. However, you will not always have numpy available, or
sometimes you require a higher level of control on how your data is
being read or written.&lt;/p&gt;
&lt;h2&gt;Learning From Others&lt;/h2&gt;
&lt;p&gt;One of the main advantages of open-source software is that you are free
to look into their code in order to understand what they do and learn
from them. In the example above, we have developed a very specialized
solution that is able to handle two columns, but not more nor less.
However, when we are using &lt;code&gt;loadtxt&lt;/code&gt;, we don't need to specify how many
columns there are, the method will find out by itself. Let's look at the
&lt;a href="https://github.com/numpy/numpy/blob/v1.15.0/numpy/lib/npyio.py#L773-L1149"&gt;loadtxt
code&lt;/a&gt;
to try to understand how it works and improve our own code.&lt;/p&gt;
&lt;p&gt;The first you have to notice is that the method &lt;code&gt;loadtxt&lt;/code&gt;, including
comments, is 376 lines long, quite a big difference with our
10-line-long method for reading two columns. In &lt;a href="https://github.com/numpy/numpy/blob/v1.15.0/numpy/lib/npyio.py#L1054"&gt;line
1054&lt;/a&gt;
you can find &lt;code&gt;first_vals = split_line(first_line)&lt;/code&gt;, which sends you to
&lt;a href="https://github.com/numpy/numpy/blob/v1.15.0/numpy/lib/npyio.py#L991"&gt;line
991&lt;/a&gt;,
in which numpy defines how to split the lines. You see that it is simply
doing &lt;code&gt;line.split(delimiter)&lt;/code&gt; and &lt;code&gt;delimiter&lt;/code&gt; could be &lt;code&gt;None&lt;/code&gt; (it comes
from the very line where &lt;code&gt;loadtxt&lt;/code&gt; is defined). Looking at that line
takes you to the official Python docs, in which you can see the
&lt;a href="https://docs.python.org/3.6/library/stdtypes.html#str.split"&gt;documentation for
split&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;What we could do is to look for the first line with data, split it
either with a fixed delimiter or we can let Python do its best by using
&lt;code&gt;None&lt;/code&gt;. Once we read the first line, we will know how many columns are
present, and we assume that all the other lines will have the same
number. If it is not the case, we could raise an exception because of
malformed data. Note that &lt;code&gt;loadtxt&lt;/code&gt; also takes care of parsing the
element as the proper data type. We assume we are dealing with floats,
and we have used &lt;code&gt;float(data[0])&lt;/code&gt;, which will fail if we try to load a
string.&lt;/p&gt;
&lt;p&gt;Loading data in a flexible way such as what numpy does is relatively
complex. The advantage of looking at code developed by others is that
you can learn a lot from seasoned developers, you can see that they
anticipate problems you perhaps never thought about. You could also
implement the same method, without relying on having numpy on the same
computer. Whenever you think you are doing something that it was already
solved, try to leverage from that experience. Reading code is a great
resource for learning.&lt;/p&gt;
&lt;h2&gt;Saving Non-Numeric Data&lt;/h2&gt;
&lt;p&gt;So far we have dealt only with numbers, that is why using numpy provides
such a big advantage. However, a lot of applications need to deal with
different types of data. Let's start with the easiest one: storing
strings. There is a very popular dataset for people learning machine
learning, known as the Iris Dataset. It consists of observations of
several parameters of three different types of flowers.&lt;/p&gt;
&lt;p&gt;I am not going to recreate the dataset here, but I will just use it as
inspiration. Imagine you make several observations, each corresponding
to a specific flower out of three options. However, not all of the
observations are real, some were labeled as fake ones. We can create a
file very easily, with some random data:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import random

observations = ['Real', 'Fake']
flowers = ['Iris setosa', 'Iris virginica', 'Iris versicolor']

with open('DA_data.dat', 'w') as f:
    for _ in range(20):
        observation = random.choice(observations)
        flower = random.choice(flowers)
        f.write('{} {}\n'.format(observation, flower))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are two types of observations, with three different types of
flowers. You pick one random type of observation and one random flower
and you write it to the file. Of course, we don't need to limit
ourselves to string data. We can also save numeric values. The original
dataset includes four numeric values: the length and the width of the
sepals and petals. We can include some fake data modifying the script:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import random

observations = ['Real', 'Fake']
flowers = ['Iris setosa', 'Iris virginica', 'Iris versicolor']

with open('DB_data.dat', 'w') as f:
    for _ in range(20):
        observation = random.choice(observations)
        flower = random.choice(flowers)
        sepal_width = random.random()
        sepal_length = random.random()
        petal_width = random.random()
        petal_length = random.random()

        f.write('{} {} {:.3f} {:.3f} {:.3f} {:.3f}\n'.format(
            observation,
            flower,
            sepal_length,
            sepal_width,
            petal_length,
            petal_width))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you look at the file, you will see that you have the same information
as before, plus the extra four numeric fields. Probably, you are already
seeing the limitations of the approach. But let's see it in more detail.&lt;/p&gt;
&lt;h2&gt;Reading Non-Numeric Data&lt;/h2&gt;
&lt;p&gt;Just as before, reading non-numeric data is as easy as reading numeric
data. For example, you can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with open('DB_data.dat', 'r') as f:
    line = f.readline()
    data = []
    while line:
        data.append(line.split(' '))
        line = f.readline()
print(data)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You see that we are splitting the spaces, which seemed like a good idea
in the examples above. However, if you look closely at the data, you
will notice that the names of the flowers are split, and we end up with
lines of 6 elements instead of 5 as expected. This is a simple example
because every field has exactly one space, and therefore we can merge
together the two that belong to the name.&lt;/p&gt;
&lt;p&gt;More complicated data, like sentences, for example, will require a more
careful handling. In a sentence, you will have a variable number of
spaces and therefore you are going to have a hard time figuring out what
parts belong to which data column. You can replace the space by a comma
when you save the file and it is going to work, provided that there are
no commas in the data you are saving.&lt;/p&gt;
&lt;p&gt;If you delimit your data with commas you will have a file commonly
referred to as Comma Separated Values, or &lt;strong&gt;csv&lt;/strong&gt;. You can see the
output of &lt;a href="https://github.com/PFTL/website/blob/master/example_code/13_storing_data/DB_data.csv"&gt;the file I have
generated&lt;/a&gt;
on Github. This kind of files can be interpreted not only by text
readers but also by numeric programs such as Excel, Libre Office,
Matlab, etc. You can even see that if you look at the file on Github it
appears nicely formatted. There are several standards around, and you
can try to reproduce them.&lt;/p&gt;
&lt;p&gt;Of course, if your data has a comma in it, the file will be broken. The
integrity of your data will be fine, but it is going to be very hard to
specify how to read it back without errors. The idea of storing data is
that you can read back, and if there are exceptions in the process, you
will not be certain about what your data means. You don't need to use
commas, nor single characters. You can separate your data with a dot and
a comma, for instance.&lt;/p&gt;
&lt;p&gt;When you store data, you have to think not only about the process of
storing but also in the process of reading it back in an unambiguous
way. If you store only numeric data, choosing a letter for separating
values may seem like a good idea. Using a comma may seem correct until
you realize that in some countries commas separate the decimal part of
numbers.&lt;/p&gt;
&lt;p&gt;Is this all regarding how to store data? Of course, not, there is much
more to come.&lt;/p&gt;
&lt;p&gt;As always, &lt;a href="https://github.com/PFTL/website/tree/master/example_code/13_storing_data"&gt;the example code can be found
here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Header photo by &lt;a href="https://unsplash.com/photos/n6B49lTx7NM?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText"&gt;Pietro
Jeng&lt;/a&gt;
on Unsplash&lt;/p&gt;</content><category term="blog"></category><category term="Data"></category><category term="Storing"></category><category term="SQLite"></category><category term="HDF5"></category><category term="ascii"></category><category term="json"></category><category term="Data Storage"></category></entry><entry><title>Learning (not) to Handle Exceptions</title><link href="https://www.pythonforthelab.com/blog/learning-not-to-handle-exceptions" rel="alternate"></link><published>2018-06-04T00:00:00+02:00</published><updated>2018-06-04T00:00:00+02:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2018-06-04:/blog/learning-not-to-handle-exceptions</id><summary type="html">&lt;p&gt;When you develop code, it is almost impossible not to run into an
error. Some problems are going to arise as soon as you start your
program, for example, if you forgot to close a parenthesis, or forgot
the &lt;code&gt;:&lt;/code&gt; after an if-statement. However, errors at runtime are also
very frequent …&lt;/p&gt;</summary><content type="html">&lt;p&gt;When you develop code, it is almost impossible not to run into an
error. Some problems are going to arise as soon as you start your
program, for example, if you forgot to close a parenthesis, or forgot
the &lt;code&gt;:&lt;/code&gt; after an if-statement. However, errors at runtime are also
very frequent and harder to deal with. In this article, you are going
to learn how to handle exceptions, i.e. how to avoid program crashes
when you can anticipate that an error may appear.&lt;/p&gt;
&lt;p&gt;We are going to cover from the basics of error handling to defining your
own exceptions. You will learn why sometimes it is better not to catch
exceptions and how to develop a pattern that can be useful for future
users of your code. Exceptions are a crucial part of any code, and
dealing with them elegantly can improve a lot the value of your code.&lt;/p&gt;
&lt;p&gt;All the code of this article is &lt;a href="https://github.com/PFTL/website/tree/master/example_code/12_exceptions"&gt;available on Github&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Try ... Except&lt;/h2&gt;
&lt;p&gt;Imagine that you are reading data from a file. You can simply write
something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;f = open('my_file.dat')
data = f.readfile()
print('Data loaded')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the code, you will see a message like the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;FileNotFoundError: [Errno 2] No such file or directory: 'my_file.dat'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When an error is raised, the code that follows will not be executed.
That is why you don't see the statement &lt;code&gt;Data loaded&lt;/code&gt; on the console.
This is a somewhat innocent problem but imagine that you are
communicating with a device. If there is an error in your program, you
won't have the chance to close the communication with the device, or you
won't be able to close a shutter to prevent damages to the detectors,
etc.&lt;/p&gt;
&lt;p&gt;Dealing with this kind of errors is normally done within a &lt;code&gt;try&lt;/code&gt; /
&lt;code&gt;except&lt;/code&gt; block. This means that if there is an error inside the &lt;code&gt;try&lt;/code&gt;,
the block &lt;code&gt;except&lt;/code&gt; will be executed. In the example above, we can do the
following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;try:
    f = open('my_file.dat')
    f.readfile()
    print('Loaded data')
except:
    print('Data not loaded')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the code, you will see a nice message being printed to screen
saying &lt;code&gt;Data not loaded&lt;/code&gt;. This is great! Now our program is not crashing
and we can close the shutter, or stop the communication with our device.
However, we don't know the reason why the data was not loaded.&lt;/p&gt;
&lt;p&gt;Before continuing, create an empty file called &lt;strong&gt;my_file.dat&lt;/strong&gt;, and run
the script again. You will see that data is not being loaded, regardless
whether the file exists or not. With this trivial example, you are
seeing the risks around unspecific &lt;code&gt;except&lt;/code&gt; blocks. If we make a simpler
script:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;f = open('my_file.dat')
f.readfile()
print('Loaded data')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output will be:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;AttributeError: '_io.TextIOWrapper' object has no attribute 'readfile'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which is telling us that the problem is the method that we tried to use,
&lt;code&gt;readfile&lt;/code&gt; doesn't exist. When you use a plain &lt;code&gt;try/except&lt;/code&gt; block, you
are sure you are handling all possible exceptions, but you have no way
of knowing what actually went wrong. In simple cases like the one above,
you have only two lines of code to explore. However, if you are building
a package or a function, some errors will propagate downstream, and you
don't know how they are going to affect the rest of the program.&lt;/p&gt;
&lt;p&gt;For you to have an idea of the importance of correct handling of errors,
I will tell you what I have witnessed using a program that ships with a
very sophisticated lab instrument. The program that controls the &lt;a href="https://www.malvernpanalytical.com/en/products/product-range/nanosight-range"&gt;Nano
Sight&lt;/a&gt;
has a very nice user interface. However, when you are saving data, if
the filename you choose has a dot in it, the data will not be saved.
Sadly, the data will also be lost and the user will never know that the
problem was having a simple &lt;code&gt;.&lt;/code&gt; in the filename.&lt;/p&gt;
&lt;p&gt;Handling all possible errors in a graceful way is very complicated and
sometimes almost impossible. However, you can see that even the software
that ships with very expensive instruments (in this case I mean
instruments with a price tag similar to a small apartment), also has to
deal with all kinds of exceptions, and not always in the most
user-friendly way.&lt;/p&gt;
&lt;h2&gt;Catching Specific Exceptions&lt;/h2&gt;
&lt;p&gt;The proper way of handling exceptions in Python is to specify what
exception are we expecting. In this way, we know that if the problem is
that the file doesn't exist, we can create it, while if the problem is
of a different nature, it will be raised and displayed to the user. We
can alter the above examples like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;try:
    file = open('my_file.dat')
    data = file.readfile()
    print('Data Loaded')
except FileNotFoundError:
    print('This file doesn\'t exist')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the script, and the file &lt;strong&gt;my_file.dat&lt;/strong&gt; doesn't exist, it
will print to screen that the file doesn't exist and the program will
keep running. However, if the file does exist, you will see the
exception with &lt;code&gt;readfile&lt;/code&gt;. Of course, you are not limited to printing a
message when an exception happens. In the case of the non-existing file,
it is easy to create one:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;try:
    file = open('my_file.dat')
    data = file.readfile()
    print('Data Loaded')
except FileNotFoundError:
    file = open('my_file.dat', 'w')
    print('File created')
file.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the script once, you will see that the file is being created.
If you run the script a second time, you will see the exception with the
&lt;code&gt;readfile&lt;/code&gt; method. Imagine that you don't specify which exception you
are catching, and you have the following code, what will happen when you
run it?:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;try:
    file = open('my_file.dat')
    data = file.readfile()
    print('Data Loaded')
except:
    file = open('my_file.dat', 'w')
    print('File created')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you look carefully, you will realize that even if the file
&lt;strong&gt;my_file.dat&lt;/strong&gt; exists, an exception is going to be raised because of
the &lt;code&gt;readfile&lt;/code&gt; method. Then the &lt;code&gt;except&lt;/code&gt; block is going to be executed.
In this block, the program is going to create a new &lt;strong&gt;my_file.dat&lt;/strong&gt;,
even if it already existed, and therefore you are going to lose the
information stored in it.&lt;/p&gt;
&lt;h2&gt;Re-raising Exceptions&lt;/h2&gt;
&lt;p&gt;A very common scenario is that when an exception appears, you want to do
something but then raise the same exception. This is a very common case
when writing to a database or to different files. Imagine the case where
you are storing information in two files, in the first one you store
spectra and in the second one the temperature at which you acquire each
one. You first save the spectra and then the temperature, and you know
that each line on one file corresponds to one file on the second file.&lt;/p&gt;
&lt;p&gt;Normally, you save first a spectrum and then you save the temperature.
However, once in a while, when you try to read from the instrument, it
crashes and the temperature is not recorded. If you don't save the
temperature, you will have an inconsistency in your data, because a line
is missing. At the same time, you don't want the experiment to keep
going, because the instrument is frozen. Therefore, you can do the
following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;[data already saved]

try:
    temp = instrument.readtemp()
except:
    remove_last_line(data_file)
    raise
save_temperature(temp)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What you can see here is that we try to read the temperature and if
anything happens, we will catch it. We remove the last line from our
data file, and then we just call &lt;code&gt;raise&lt;/code&gt;. This command will simply
re-raise anything that was caught by the &lt;code&gt;except&lt;/code&gt;. With this strategy,
we are sure that we have consistent data, that the program will not keep
running and that the user will see all the proper information regarding
what went wrong.&lt;/p&gt;
&lt;h2&gt;Exceptions in Exceptions&lt;/h2&gt;
&lt;p&gt;Imagine that the code is part of a larger function, responsible for
opening a file, loading its contents or creating a new file in case the
specified filename doesn't exist. The script will look the same as
earlier, with the difference that the filename is going to be a
variable:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;try:
    file = open(filename)
    data = file.readfile()
except FileNotFoundError:
    file = open(filename, 'w')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To run the code above, the only thing you have to do is to specify the
filename before, for instance:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;filename = 'my_data.dat'
try:
    [...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run this code, you will notice that it behaves exactly as
expected. However, if you specify an empty filename:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;filename = ''
try:
    [...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You will see a much longer error printed to screen, with one important
line:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;During handling of the above exception, another exception occurred:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you look carefully at the error, you will see that it outputs
information regarding that an error occurred while the code was already
handling another error. This is, unfortunately, a common situation,
especially when dealing with user input. The way around it would be to
nest another try/except block or to verify the integrity of the inputs
before calling &lt;code&gt;open&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Several Exceptions&lt;/h2&gt;
&lt;p&gt;So far we have been dealing with only one possible exception,
&lt;code&gt;FileNotFoundError&lt;/code&gt;. However, we know that the code will raise two
different exceptions, the second one being an &lt;code&gt;AttributeError&lt;/code&gt;. If you
are not sure about which errors can be raised, you can generate them on
purpose. For instance, if you run this code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;file = open('my_data.dat', 'a')
file.readfile()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You will get the following message:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;AttributeError: '_io.TextIOWrapper' object has no attribute 'readfile'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first string is the type of exception, &lt;code&gt;AttributeError&lt;/code&gt;, while the
second part is the message. The same exception can have different
messages, which describe better what has happened. What we want is to
catch the &lt;code&gt;AttributeError&lt;/code&gt;, but also we want to catch the
&lt;code&gt;FileNotFound&lt;/code&gt;. Therefore, our code would look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;filename = 'my_data.dat'

try:
    file = open(filename)
    data = file.readfile()
except FileNotFoundError:
    file = open(filename, 'w')
    print('Created file')
except AttributeError:
    print('Attribute Error')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you are dealing with several exceptions. Remember that when an
exception is raised within the &lt;code&gt;try&lt;/code&gt; block, the rest of the code will
not be executed, and Python will go through the different &lt;code&gt;except&lt;/code&gt;
blocks. Therefore, only one exception is raised at a time. In the case
where the file doesn't exist, the code will deal only with the
&lt;code&gt;FileNotFoundError&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Of course, you can also add a final exception to catch all other
possible errors in the program, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;filename = 'my_data.dat'

try:
    file = open(filename)
    data = file.read()
    important_data = data[0]
except FileNotFoundError:
    file = open(filename, 'w')
    print('Created file')
except AttributeError:
    print('Attribute Error')
except:
    print('Unhandled exception')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case, if the file exists but it is empty, we are going to have a
problem trying to access &lt;code&gt;data[0]&lt;/code&gt;. We are not prepared for that
exception and therefore we are going to print a message saying
&lt;em&gt;Unhandled exception&lt;/em&gt;. It would be, however, more interesting to let the
user know what exception was actually raised. We can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;filename = 'my_data.dat'

try:
    file = open(filename)
    data = file.read()
    important_data = data[0]
except Exception as e:
    print('Unhandled exception')
    print(e)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which will output the following message:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;Unhandled exception
string index out of range
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The exception also has a &lt;code&gt;type&lt;/code&gt;, which you can use. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;filename = 'my_data.dat'

try:
    file = open(filename)
    data = file.read()
    important_data = data[0]
except Exception as e:
    print('Unhandled exception')
    if isinstance(e, IndexError):
        print(e)
        data = 'Information'
        important_data = data[0]

print(important_data)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which will print the first letter of &lt;code&gt;Information&lt;/code&gt;, i.e. &lt;code&gt;I&lt;/code&gt;. The
pattern above has a very important drawback, and is that
&lt;code&gt;important_data&lt;/code&gt; may end up not being defined. For example, if the file
&lt;strong&gt;my_data.dat&lt;/strong&gt; doesn't exist, we will get another error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;NameError: name 'important_data' is not defined
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;The Finally Statement&lt;/h2&gt;
&lt;p&gt;To prevent what we just saw in the previous section, we can add one more
block to the sequence: &lt;code&gt;finally&lt;/code&gt;. This block is always going to be
executed, regardless of whether an exception was raised or not. For
example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;filename = 'my_data.dat'

try:
    file = open(filename)
    data = file.read()
    important_data = data[0]
except Exception as e:
    if isinstance(e, IndexError):
        print(e)
        data = 'Information'
        important_data = data[0]
    else:
        print('Unhandled exception')
finally:
    important_data = 'A'

print(important_data)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is, in the end, a very silly example, because we are setting
&lt;code&gt;important_data&lt;/code&gt; to a special value, but I hope you can see the use of
&lt;code&gt;finally&lt;/code&gt;. If there is something that you must absolutely be sure that
is executed, you can include it in a finally statement.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;finally&lt;/code&gt; is very useful to be sure that you are closing a connection,
the communication with a device, closing a file, etc. Generally
speaking, releasing the resources. Finally has a very interesting
behavior, because it is not executed always at the same moment. Let's
see the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;filename = 'my_data.dat'

try:
    print('In the try block')
    file = open(filename)
    data = file.read()
    important_data = data[0]
except FileNotFoundError:
    print('File not found, creating one')
    file = open(filename, 'w')
finally:
    print('Finally, closing the file')
    file.close()
    important_data = 'A'

print(important_data)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, run the code when the file &lt;strong&gt;my_data.dat&lt;/strong&gt; doesn't exist. You
should see the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;In the try block
File not found, creating one
Finally, closing the file
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, you see you went from the &lt;code&gt;try&lt;/code&gt; to the &lt;code&gt;except&lt;/code&gt; to the &lt;code&gt;finally&lt;/code&gt;. If
you run the code again, the file will exist, and therefore the output
will be completely different:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;In the try block
Finally, closing the file
Traceback (most recent call last):
  File &amp;quot;JJ_exceptions.py&amp;quot;, line 7, in &amp;lt;module&amp;gt;
    important_data = data[0]
IndexError: string index out of range
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What you can see here is that when an unhandled exception is raised, the
first block to be executed is the &lt;code&gt;finally&lt;/code&gt;. You close the file
immediately. And then, the error is re-raised. This is very handy
because it prevents any kind of conflict with downstream code. You open,
you close the file and then the rest of the program has to deal with the
problem of the &lt;code&gt;IndexError&lt;/code&gt;. If you want to try a program without
exceptions, just write something into &lt;strong&gt;my_data.dat&lt;/strong&gt; and you will see
the output.&lt;/p&gt;
&lt;h2&gt;The else Block&lt;/h2&gt;
&lt;p&gt;There is only one more block to discuss in the exception handling
pattern, the &lt;code&gt;else&lt;/code&gt; block. The core idea of this block is that it gets
executed if there were no exceptions within the &lt;code&gt;try&lt;/code&gt; block. Is very
easy to understand how it works, you could, for example, do the
following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;filename = 'my_data.dat'

try:
    file = open(filename)
except FileNotFoundError:
    print('File not found, creating one')
    file = open(filename, 'w')
else:
    data = file.read()
    important_data = data[0]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The most difficult part of the else block is understanding its
usefulness. In principle, the code that we have included in the &lt;code&gt;else&lt;/code&gt;
block could have also been placed right after opening the file, as we
have done earlier. However, we can use the &lt;code&gt;else&lt;/code&gt; block to prevent
catching exceptions that do not belong to the &lt;code&gt;try&lt;/code&gt;. It is a bit
far-fetched examples, but imagine that you need to read a filename from
a file and open it. The code would look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;try:
    file = open(filename)
    new_filename = file.readline()
except FileNotFoundError:
    print('File not found, creating one')
    file = open(filename, 'w')
else:
    new_file = open(new_filename)
    data = new_file.read()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since we are opening two files, it may very well be that the problem is
that the second file doesn't exist. If we would put this code into the
&lt;code&gt;try&lt;/code&gt; block, we would end up triggering the &lt;code&gt;except&lt;/code&gt; for the second file
even if we didn't mean to. At first, it is not obvious the true use of
the &lt;code&gt;else&lt;/code&gt; block, but it can be very useful and therefore it is
important that you are aware that it exists.&lt;/p&gt;
&lt;p&gt;Of course, it is possible to combine everything that you have learned so
far:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;try:
    file = open(filename)
    new_filename = file.readline()
except FileNotFoundError:
    print('File not found, creating one')
    file = open(filename, 'w')
else:
    new_file = open(new_filename)
    data = new_file.read()
finally:
    file.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You are very encouraged to play around and try to find different usages
for each block. If you have worked enough with Python, probably you
encounter plenty of exceptions that forced you to re-run your script
from the beginning. Now you know that there may be workarounds. A great
resource, as almost always, is the &lt;a href="https://docs.python.org/3/tutorial/errors.html"&gt;Python Documentation on
Exceptions&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Things are not over yet, there are many more things that can be done
with exceptions.&lt;/p&gt;
&lt;h2&gt;The Traceback&lt;/h2&gt;
&lt;p&gt;As you have probably seen already, when there is an exception, a lot of
information is printed to the screen. For example, if you try to open a
not existing file you get:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;Traceback (most recent call last):
  File &amp;quot;P_traceback.py&amp;quot;, line 13, in &amp;lt;module&amp;gt;
    file = open(filename)
FileNotFoundError: [Errno 2] No such file or directory: 'my_data.dat'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Interpreting the message may take a bit of practice, but for simple
cases it is clear. First, it tells you that you are seeing a traceback,
in simple words the history of things that lead to the exception. I will
cover more on this on a separate post. However, you can clearly see the
file that generated the problem and the line. If you open the file and
go to that line, you will see that it is exactly the one that says
&lt;code&gt;file = open(filename)&lt;/code&gt;. Finally, you see the exception.&lt;/p&gt;
&lt;p&gt;This last message is the one we were printing to screen, but we were
neglecting the traceback that would allow us to find the real source of
the exception and act accordingly. Fortunately, Python allows us to
access the traceback very easily. Slightly modifying the example of
opening a file, we would have:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import traceback

filename = 'my_data.dat'

try:
    file = open(filename)
    data = file.read()
except FileNotFoundError:
    traceback.print_exc()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the code again, you will see printed to screen the same
information than before. The main difference is that your program didn't
crash, because you were handling the exception. Working with tracebacks
is very handy for debugging. The examples that you have seen here are
very simple, but when you have a very nested code, i.e., one function
calls another that creates an object, that runs a method, etc. it is
very important to pay attention to the traceback in order to know what
triggered the exception.&lt;/p&gt;
&lt;h2&gt;Raising Custom Exceptions&lt;/h2&gt;
&lt;p&gt;When you are developing your own packages, it is often useful to define
some common exceptions. This gives a great deal of flexibility because
it allows other developers to handle those exceptions as they find
appropriate. Let's see an example. Imagine that you want to write a
function that calculates the average between two numbers, but you want
both numbers to be positive. This is the same example that we have seen
when working with
&lt;a href="https://www.pythonforthelab.com/blog/how-to-use-decorators-part-2"&gt;decorators&lt;/a&gt;. We start by
defining the function:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def average(x, y):
    return (x + y)/2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now we want to raise an &lt;code&gt;Exception&lt;/code&gt; if either input is negative. We
can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def average(x, y):
    if x&amp;lt;=0 or y&amp;lt;=0:
        raise Exception('Both x and y should be positive')
    return (x + y)/2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you try it yourself with a negative input, you will see the following
printed:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;Exception: Both x and y should be positive
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which is great, it even points to the line number with the issue, etc.
However, if you are building a module and you expect others to use it,
it would be much better to define a custom Exception, that can be
explicitly caught. It is as easy as this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class NonPositiveError(Exception):
    pass

def average(x, y):
    if x &amp;lt;= 0 or y &amp;lt;= 0:
        raise NonPositiveError('Both x and y should be positive')
    return (x + y) / 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An exception is a class, and therefore it should inherit from the
general &lt;code&gt;Exception&lt;/code&gt; class. We don't really need to customize anything at
this stage, we just type &lt;code&gt;pass&lt;/code&gt; in the body of the class. If we run the
code above with a negative value, we will get:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;NonPositiveError: Both x and y should be positive
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you want to catch that exception in downstream code, you will do it
as always. The only difference is that custom exceptions are not
available by default and you should import them. For example, you would
do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from exceptions import NonPositiveError
from tools import average

try:
    avg = average(1, -2)
except NonPositiveError:
    avg = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you have worked long enough with packages, probably you have already
encountered a lot of different exceptions. They are a great tool to let
the user know exactly what was wrong and act accordingly. Sometimes we
can be prepared for some exceptions and is very appreciated when custom
ones are included into the package and not just a generic one that
forces us to catch any exception, even if it is something that we were
not actually expecting.&lt;/p&gt;
&lt;h2&gt;Best Practices for Custom Exceptions&lt;/h2&gt;
&lt;p&gt;When you are developing a package, it is very handy to define exceptions
that are exclusive to it. This makes it much easier to handle different
behaviors and gives developers a very efficient way to filter whether
the problems are within your package or with something else. Imagine,
for instance, that you are working with a complex package, and you want
to write to a file every time an exception from that specific package
appears.&lt;/p&gt;
&lt;p&gt;This is very easy to achieve if all the exceptions inherit from the same
base class. The code below is a bit longer, but it is built on top of
all the examples above, so it should be easy to follow:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyException(BaseException):
    pass

class NonPositiveIntegerError(MyException):
    pass

class TooBigIntegerError(MyException):
    pass

def average(x, y):
    if x&amp;lt;=0 or y&amp;lt;=0:
        raise NonPositiveIntegerError('Either x or y is not positive')

    if x&amp;gt;10 or y&amp;gt;10:
        raise TooBigIntegerError('Either x or y is too large')
    return (x+y)/2

try:
    average(1, -1)
except MyException as e:
    print(e)

try:
    average(11, 1)
except MyException as e:
    print(e)

try:
    average('a', 'b')
except MyException as e:
    print(e)

print('Done')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We first define an exception called &lt;code&gt;MyException&lt;/code&gt;, which is going to be
our base exception. We then define two errors, &lt;code&gt;NonPositiveIntegerError&lt;/code&gt;
and &lt;code&gt;TooBigIntegerError&lt;/code&gt; which inherit from &lt;code&gt;MyException&lt;/code&gt;. We define the
function &lt;code&gt;average&lt;/code&gt; again but this time we raise two different
exceptions. If one of the numbers is negative or larger than 10.&lt;/p&gt;
&lt;p&gt;When you see the different use cases below, you will notice that in the
&lt;code&gt;try/except&lt;/code&gt; block, we are always catching &lt;code&gt;MyException&lt;/code&gt;, but not one of
the specific errors. In the first two examples, when passing &lt;code&gt;-1&lt;/code&gt; and
&lt;code&gt;11&lt;/code&gt; as arguments, we successfully print to screen the error message,
and the program keeps running. However, when we try to calculate the
average between two letters, the &lt;code&gt;Exception&lt;/code&gt; is going to be of a
different nature, and is not going to be caught by the &lt;code&gt;Except&lt;/code&gt;. You
should see the following on your screen:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;TypeError: '&amp;lt;=' not supported between instances of 'str' and 'int'
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Adding Arguments to Exceptions&lt;/h2&gt;
&lt;p&gt;Sometimes it is handy to add arguments to exceptions in order to give a
better context to users. With the example of the average, let's first
define a more complex exception:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyException(BaseException):
    pass

class NonPositiveIntegerError(MyException):
    def __init__(self, x, y):
        super(NonPositiveIntegerError, self).__init__()
        if x&amp;lt;=0 and y&amp;lt;=0:
            self.msg = 'Both x and y are negative: x={}, y={}'.format(x, y)
        elif x&amp;lt;=0:
            self.msg = 'Only x is negative: x={}'.format(x)
        elif y&amp;lt;=0:
            self.msg = 'Only y is negative: y={}'.format(y)

    def __str__(self):
        return self.msg


def average(x, y):
    if x&amp;lt;=0 or y&amp;lt;=0:
        raise NonPositiveIntegerError(x, y)
    return (x+y)/2

try:
    average(1, -1)
except MyException as e:
    print(e)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What you can see is that the exception takes two arguments, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;
and it generates a message based on them. They can be both negative or
only one of them is negative. It doesn't only give you that information,
but it actually displays the value that gave problems. This is very
handy to understand what went wrong exactly. The most important part is
at the end of the class: the &lt;code&gt;__str__&lt;/code&gt; method. This method is
responsible for what appears on the screen when you do &lt;code&gt;print(e)&lt;/code&gt; in the
&lt;code&gt;except&lt;/code&gt; block. In this case, we are just returning the message
generated within the &lt;code&gt;__init__&lt;/code&gt;, but many developers choose to generate
the message in this method, based on the parameters passed at the
beginning.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;Exceptions are something nobody wants to see but they are virtually
unavoidable. Maybe you try to read a file that doesn't exist, the user
of your code has chosen invalid values, the matrix you are analyzing has
different dimensions than expected, etc. Handling exceptions is a
sensitive topic because it can lead to even more problems downstream. An
Exception is a clear message that there is something wrong going on and
if you don't fix it properly, it is going to become even worse.&lt;/p&gt;
&lt;p&gt;Handling exceptions can help you to avoid having inconsistent data, not
closing resources such as devices, connections or files, etc. However,
not handling exceptions correctly can lead to even more problems later
on. The &lt;code&gt;try/except&lt;/code&gt; block is very handy when you know what kind of
exceptions can appear and you know how to handle them. Imagine you are
performing several steps of a complex operation, like writing to a
database. If an error happens, you can revert all the changes and avoid
inconsistencies.&lt;/p&gt;
&lt;p&gt;As with almost any other Python topic, the best way to learn is to look
closely at other's code and judge by yourself. Not all packages define
their own exceptions, nor handle them in the same way. If you are
looking for inspiration, you can see the &lt;a href="https://github.com/hgrecco/pint/blob/master/pint/errors.py"&gt;errors of
Pint&lt;/a&gt;, a
relatively small package, or the &lt;a href="https://github.com/django/django/blob/master/django/core/exceptions.py"&gt;exceptions of
Django&lt;/a&gt;,
a much more complex package.&lt;/p&gt;
&lt;p&gt;Photo by &lt;a href="https://unsplash.com/photos/5E5N49RWtbA?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText"&gt;Cody
Davis&lt;/a&gt;
on Unsplash&lt;/p&gt;
&lt;p&gt;Remember, that both &lt;a href="https://github.com/PFTL/website/tree/master/example_code/12_exceptions"&gt;the
code&lt;/a&gt;
and &lt;a href="https://github.com/PFTL/website/blob/master/content/blog/12_handling_exceptions.rst.md"&gt;the
text&lt;/a&gt;
of the article is available, in case you have any comments or
suggestions to improve it.&lt;/p&gt;</content><category term="blog"></category><category term="Exceptions"></category><category term="Errors"></category><category term="Try"></category><category term="Except"></category><category term="Catch"></category><category term="Handling"></category></entry><entry><title>Documenting with Sphinx and Readthedocs</title><link href="https://www.pythonforthelab.com/blog/documenting-with-sphinx-and-readthedocs" rel="alternate"></link><published>2018-05-31T00:00:00+02:00</published><updated>2018-05-31T00:00:00+02:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2018-05-31:/blog/documenting-with-sphinx-and-readthedocs</id><summary type="html">&lt;p&gt;If you have ever followed a guide on how to start programming, most
likely you have encounter reflections about the importance of adding
comments to your code. Comments allow you to understand what the
developer was thinking when programming, maybe left some traces of what
could be improved. If you …&lt;/p&gt;</summary><content type="html">&lt;p&gt;If you have ever followed a guide on how to start programming, most
likely you have encounter reflections about the importance of adding
comments to your code. Comments allow you to understand what the
developer was thinking when programming, maybe left some traces of what
could be improved. If you are developing software in places where people
change often, it is crucial to leave extra information behind, to speed
up the catching up of the new developers.&lt;/p&gt;
&lt;p&gt;Python has a very robust system for documenting functions, classes and
variables. It is so robust that allows you to check for help in the
interactive console, it can be used for testing your code and can be
converted into beautifully formatted HTML or PDF documentation. In this
tutorial, you will see how to write documentation for your projects and
how to host it for free on &lt;a href="https://readthedocs.org/"&gt;Read The Docs&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Building a Simple Module&lt;/h2&gt;
&lt;p&gt;To start with this tutorial, we will need to build a simple module, with
some classes and functions. My recommendation is to work inside a
&lt;a href="https://www.pythonforthelab.com/blog/virtual-environment-is-a-must-have-tool"&gt;Virtual Environment&lt;/a&gt;. Start
by creating a folder to hold your project. Inside create a new folder
called my_module and add an empty &lt;strong&gt;__init__.py&lt;/strong&gt; file. Create a
file called &lt;strong&gt;factorial.py&lt;/strong&gt; and add the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import math

def factorial(n):
    if not n &amp;gt;= 0:
        raise ValueError(&amp;quot;n must be &amp;gt;= 0&amp;quot;)
    if math.floor(n) != n:
        raise ValueError(&amp;quot;n must be exact integer&amp;quot;)
    if n + 1 == n:  # catch a value like 1e300
        raise OverflowError(&amp;quot;n too large&amp;quot;)
    result = 1
    factor = 2
    while factor &amp;lt;= n:
        result *= factor
        factor += 1
    return result
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can find the files &lt;a href="https://github.com/PFTL/website/tree/0.1/example_code/11_documenting/my_module"&gt;in tag
0.1&lt;/a&gt;
on GitHub. If you would like to use the code, you can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; from my_module.factorial import factorial
&amp;gt;&amp;gt;&amp;gt; factorial(5)
120
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And you can also use the help, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; help(factorial)
Help on function factorial in module my_module.factorial:

factorial(n)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which is not very descriptive, but we will get to it.&lt;/p&gt;
&lt;h2&gt;Adding Docstrings&lt;/h2&gt;
&lt;p&gt;When you use the command &lt;code&gt;help&lt;/code&gt;, Python will look for a string right
after the definition of the function. In the case of &lt;code&gt;factorial&lt;/code&gt; there
we no string, so let's add one and see how it works. I will remove the
extra code for brevity and will replace it by &lt;code&gt;[...]&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def factorial(n):
    'Function to calculate the factorial'
[...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Remember that if you make changes to a module in Python, you have to
quit and import it again. If you just reimport a module, you won't see
the latest changes. And now you will see the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; help(factorial)
factorial(n)
    Function to calculate the factorial
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The string that is being printed is the same that you wrote right after
the definition of your function. Traditionally in Python, docstrings are
defined using three &lt;code&gt;''&lt;/code&gt;, which will allow you to span the documentation
into several lines as well. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def factorial(n):
    &amp;quot;&amp;quot;&amp;quot;Function to calculate the factorial.
    For example:

    &amp;gt;&amp;gt;&amp;gt; factorial(5)
    120
    &amp;quot;&amp;quot;&amp;quot;
    [...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The example above is showing you that you can extend the documentation
of a function also with examples. Next time you use &lt;code&gt;help&lt;/code&gt;, you will see
a more complete explanation of what the function does and how to use it.
If you are familiar with numpy, for example, you should try to run help
on any of its modules. You will notice the level of detail that they
accomplish in their documentation.&lt;/p&gt;
&lt;p&gt;Of course, you are not limited to documenting functions. You can
document the entire module by adding a string right at the top of the
file.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;quot;&amp;quot;&amp;quot;
Module factorial
================
This module supplies one function, factorial() to calculate the factorial of an integer.
&amp;quot;&amp;quot;&amp;quot;
import math
[...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If instead of importing the function, you import the module, you can
see:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; from my_module import factorial
&amp;gt;&amp;gt;&amp;gt; help(factorial)
Help on module factorial:

NAME
    factorial

DESCRIPTION
    Module factorial
    ================
    This module supplies one function, factorial() to calculate the factorial of an integer.

FUNCTIONS
    factorial(n)
        Function to calculate the factorial of a number.
        For example:

        &amp;gt;&amp;gt;&amp;gt; factorial(5)
        120
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, docstrings are very useful when you are trying to
navigate a package full of modules. You can quickly understand if the
module factorial is what you are looking for or not. It doesn't matter
if you are reading the code itself or if you are working from the
command line, the docstrings are a great way of communicating with other
developers (and even with your future self).&lt;/p&gt;
&lt;p&gt;The code up to here can be found in &lt;a href="https://github.com/PFTL/website/tree/0.3/example_code/11_documenting/my_module"&gt;Tag
0.3&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;From docstrings to doctest&lt;/h2&gt;
&lt;p&gt;A very useful approach when developing code is to test it. Especially if
you are going to collaborate with others. Testing means to run the code
with inputs to which you know the expected outcome. If the output is
correct, the test passes, if the output is not correct, the test fails.
This is a very systematic way to be sure that modifications to existing
code are not going to ruin code downstream, for example.&lt;/p&gt;
&lt;p&gt;Building tests is no simple task because you have to be sure of what you
want to test. Docstrings allow you an easy path to testing through the
examples that you provide. If you pay attention to the code above, you
can see that we have already provided an example of how to use the code
and the expected output. You can instruct Python to look for these
examples and check if the output matches.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;python -m doctest -v factorial.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And you will see that the output actually says that it is trying to
execute &lt;code&gt;factorial(5)&lt;/code&gt; and that it is expecting the output to be &lt;code&gt;120&lt;/code&gt;.
This is great because if you are trying to improve the code, you have to
be sure that at least when you use the number 5 it works correctly.
Another possible behavior is to check that if you are outside of the
limits, and an error is raised. You don't want to calculate the
factorial of &lt;code&gt;-1&lt;/code&gt;, for instance. We can add a new example to the
docstring:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def factorial(n):
    &amp;quot;&amp;quot;&amp;quot; [...]
    &amp;gt;&amp;gt;&amp;gt; factorial(-1)
    Traceback (most recent call last):
    ...
    ValueError: n must be &amp;gt;= 0
    &amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you test your code again, you will see that this time there are two
tests that pass. This article is not really on testing, but it was
important to point out that docstrings are a very easy way to testing,
at least the basic functionality of your packages. You can also add
examples at a module level, not only at a function level.&lt;/p&gt;
&lt;h2&gt;Documenting classes and methods&lt;/h2&gt;
&lt;p&gt;When you work with classes and methods, the docstrings work in exactly
the same way. Let's create a new file called &lt;strong&gt;people.py&lt;/strong&gt; with two
classes and some methods:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Person:
    def __init__(self, name):
        self.name = name

class Teacher(Person):
    def __init__(self, name, course):
        super().__init__(name)
        self.course = course

    def get_course(self):
        return self.course

    def set_course(self, new_course):
        self.course = new_course
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As an exercise, you can write the docstrings for each class and method,
or you can go directly to &lt;a href="https://github.com/PFTL/website/blob/0.5/example_code/11_documenting/my_module/people.py"&gt;Tag
0.5&lt;/a&gt;
and grab the example from there. There is something very important to
note and is that classes should document all the methods, also the
&lt;code&gt;__init__&lt;/code&gt; and the class itself. If you use the &lt;code&gt;help&lt;/code&gt; command, you will
see the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; from people import Person
&amp;gt;&amp;gt;&amp;gt; help(Person)
class Person(builtins.object)
 |  Class to store a general person information. For example the name.
 |
 |  Methods defined here:
 |
 |  __init__(self, name)
 |      Create a person object by providing a name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is important to note that you can get the help not only of the class
but also of an instance of that class. For example, you can generate the
same output if you do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; me = Person('My Self')
&amp;gt;&amp;gt;&amp;gt; help(me)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Moreover, you can access the docstring directly, as an attribute of the
class, and you can modify it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; Person.__doc__
'Class to store a general person information. For example the name.'
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Building Documentation with Sphinx&lt;/h2&gt;
&lt;p&gt;Now you have developed a package with several modules, each with its own
docstring. However, this can be even better. You can compile all the
docstrings of your modules into a single place, a website or a pdf, that
will make it very easy to share the information, look for help and
provide examples that extend what is appropriate for a docstring. To
achieve all this, you need to install a package called &lt;em&gt;Sphinx&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install sphinx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Sphinx can convert a special format of files, called &lt;em&gt;RestructuredText&lt;/em&gt;
into other handy formats, such as html, pdf, etc. After you have
installed sphinx, the quickest is to run &lt;code&gt;sphinx-quickstart&lt;/code&gt; which will
guide you through some questions in order to create the needed folders,
the base &lt;strong&gt;config.py&lt;/strong&gt; file and a starting point. You are free to try it
out. I am going to take the slightly longer path, covering the details
of what you should do.&lt;/p&gt;
&lt;p&gt;First, create a folder called &lt;strong&gt;docs&lt;/strong&gt;, next to the folder
&lt;strong&gt;my_module&lt;/strong&gt;. This will allow you to separate the development of code
from the development of the code itself. If you are using version
control, this can make your life much easier. Inside the &lt;strong&gt;docs&lt;/strong&gt;,
create a folder &lt;strong&gt;source&lt;/strong&gt; and place a file called &lt;strong&gt;config.py&lt;/strong&gt;, with
the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;project = 'My Module'
copyright = '2018, Aquiles Carattino'
author = 'Aquiles Carattino'
version = ''
release = '0.1'
templates_path = ['_templates']
source_suffix = '.rst'
master_doc = 'index'
pygments_style = 'sphinx'
html_theme = 'alabaster'
html_static_path = ['_static']
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This file specifies some general properties of the project, such as the
version, the release, the author, etc. And some options that are
important for building the documentation, such as the default source
suffix, i.e. which files are going to be parsed. The &lt;a href="http://www.sphinx-doc.org/en/master/usage/configuration.html"&gt;configuration
help&lt;/a&gt; has
all the information that you need to customize the build. Create a new
file, called &lt;em&gt;index.rst&lt;/em&gt; and add the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-rst"&gt;Welcome to My Module's documentation!
=====================================
This is going to become the future documentation of My Project

.. toctree::
     :maxdepth: 2
     :caption: Contents:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, just run the following command from the &lt;strong&gt;docs&lt;/strong&gt; folder:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;sphinx-build -b html source/ build/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you check now the &lt;strong&gt;build&lt;/strong&gt; folder, you will see that several files
were generated. Open &lt;strong&gt;index.html&lt;/strong&gt; and you will find a page that looks
like the following:&lt;/p&gt;
&lt;p&gt;&lt;img alt="screenshot of the documentation" class="center-img" src="/images/10_images/01_base_page.png"&gt;&lt;/p&gt;
&lt;h3&gt;Adding the documentation of your modules&lt;/h3&gt;
&lt;p&gt;One of the advantages of Sphinx is that it can automatically build the
documentation for your modules. Let's see how to do it. Next to the file
index.rst create a new file called &lt;strong&gt;people.rst&lt;/strong&gt; and add the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-rst"&gt;.. automodule:: my_module.people
    :members:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You will need to update the file &lt;strong&gt;config.py&lt;/strong&gt; in order to instruct
sphinx to build the documentation for your modules. Add the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import os
import sys

sys.path.insert(0, os.path.abspath('../..'))
extensions = [
'sphinx.ext.autodoc',]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first few lines are needed in order to tell Sphinx where your
package is. In this case, since you start in the &lt;em&gt;source&lt;/em&gt; folder, it is
two levels up. Then, you need to add an extension, that will allow you
to build the documentation for modules. Run again the command:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;sphinx-build -b html source/ build/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You should see a warning message stating:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;[...] people.rst: WARNING: document isn't included in any toctree
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Don't worry about it now. It is just telling you that there are no links
to the file, and therefore someone who is browsing through your
documents will not be able to reach that file. If you look again at the
folder &lt;em&gt;build&lt;/em&gt; you will see a new file called &lt;strong&gt;people.html&lt;/strong&gt;. Open it,
and you should see the following:&lt;/p&gt;
&lt;p&gt;&lt;img alt="screenshot of the documentation of a module" class="center-img" src="/images/10_images/02_base_module.png"&gt;&lt;/p&gt;
&lt;p&gt;Which is a great starting point for the documentation of your project!
You see the code nice highlighted. You should see that the first part of
the page corresponds to the docstring of the module, this is the first
string that you defined at the beginning of the file. The rest is
grabbing each of the classes that you have defined within that module.&lt;/p&gt;
&lt;p&gt;Now we can add the documentation for &lt;strong&gt;factorial&lt;/strong&gt;, creating a new file
called &lt;strong&gt;factorial.rst&lt;/strong&gt; next to &lt;strong&gt;index.rst&lt;/strong&gt; and &lt;strong&gt;people.rst&lt;/strong&gt;. Add
the following content:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-rst"&gt;.. automodule:: my_module.factorial
    :members:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now it is time to link to these files from &lt;strong&gt;index.rst&lt;/strong&gt; in order to
be able to navigate through the documentation. Add the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-rst"&gt;.. toctree::
    :maxdepth: 2
    :caption: Contents:

    factorial
    people
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Build again the documentation and now you should see that there are no
more warnings. Moreover, if you open &lt;strong&gt;index.html&lt;/strong&gt; you will see the
links to the two pages. You can find all the code at &lt;a href="https://github.com/PFTL/website/tree/0.6/example_code/11_documenting/docs/source"&gt;Tag
0.6&lt;/a&gt;
on Github.&lt;/p&gt;
&lt;h3&gt;Customizing the pages&lt;/h3&gt;
&lt;p&gt;So far you have used the &lt;code&gt;automodule&lt;/code&gt; command, together with the option
&lt;code&gt;:members:&lt;/code&gt;, but you are not obliged to do that. You can build the
documentation for specific elements, and you can add more information
than the provided in the docstrings. Let's update the &lt;strong&gt;factorial.rst&lt;/strong&gt;
file. Add the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-rst"&gt;How to calculate the factorial
==============================
The factorial is a mathematical operation that calculates the product of all the numbers up to the specified integer.

For example, the factorial of 5 would be 1*2*3*4*5 = 120. With our code we can do the following::

    &amp;gt;&amp;gt;&amp;gt; factorial(5)
    120

.. automodule:: my_module.factorial

The function Factorial
======================
The function factorial is also well documented.

.. autofunction:: my_module.factorial.factorial
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you build again the documentation, you will see that the output has
changed a lot. First, the title of the page is &lt;em&gt;How to calculate the
factorial&lt;/em&gt; and now you have some structure in the &lt;em&gt;Table Of Contents&lt;/em&gt;.
You will see these changes also if you check the &lt;em&gt;index.html&lt;/em&gt; file.
Restructured text is very complex, and it is not our scope to cover it
all. What you should know, at least, is that to make titles you have to
underline them with &lt;code&gt;=&lt;/code&gt;. Subtitles, i.e. second order titles, are
underlined with &lt;code&gt;-&lt;/code&gt; and so forth. You can check the &lt;a href="http://docutils.sourceforge.net/docs/user/rst/quickref.html"&gt;Quick Reference to
Restructured
Text&lt;/a&gt; if
you want to learn more.&lt;/p&gt;
&lt;p&gt;If you want to include code, you have two options.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-rst"&gt;This is an example::

    &amp;gt;&amp;gt;&amp;gt; factorial(5)
    120

But this also works:

.. code-block:: pycon

    &amp;gt;&amp;gt;&amp;gt; factorial(5)
    120

The indenting is important to establish beginning and ending of blocks.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you see that the complexity of the documentation is growing. You can
add examples, extra information, math formulas. You are actually
building a complete website, just that a part of it is automatically
created from code. If you are curious, this website is built using a
similar approach, you can check the code of the articles in &lt;a href="https://github.com/PFTL/website/tree/master/content"&gt;the website
repository&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Styling the Docstrings&lt;/h3&gt;
&lt;p&gt;So far we have added some simple information in the docstrings, but this
is not all that you can do. For example, the &lt;strong&gt;factorial&lt;/strong&gt; function
takes as arguments integers and returns integers. This can also be
specified in the docstring, making it very easy to track possible
errors. When you want to go to this extent of detail, you will see that
different packages use different styles, i.e., you specify inputs and
outputs in different ways. We are going to follow the &lt;strong&gt;reST&lt;/strong&gt; style,
which is automatically supported by Sphinx and editors such as Pycharm.&lt;/p&gt;
&lt;p&gt;Edit &lt;strong&gt;factorial.py&lt;/strong&gt; with the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def factorial(n):
    &amp;quot;&amp;quot;&amp;quot;
    [...]
    :param n: Number to calculate the factorial
    :type n: int
    :return: The calculated factorial
    :rtype: int
     &amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, you explain what the parameter is, in this case, the input &lt;strong&gt;n&lt;/strong&gt;.
You can also explicitly tell the type of the input. If the function
returns something, you can explain what it returns and the type of the
return. In this case, it is again an integer. If you build the
documentation again, you will see that this information is automatically
added to the page &lt;strong&gt;factorial.html&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Some other possible styles are &lt;a href="http://epydoc.sourceforge.net/"&gt;Epydoc&lt;/a&gt;,
which relies on its own generator, instead of Sphinx,
&lt;a href="http://www.sphinx-doc.org/en/master/"&gt;reST&lt;/a&gt;, which we used above,
&lt;a href="https://google.github.io/styleguide/pyguide.html?showone=Comments#Comments"&gt;Google&lt;/a&gt;
has its own style, and finally, you can also use the &lt;a href="https://numpydoc.readthedocs.io/en/latest/"&gt;Numpy
Style&lt;/a&gt;. You have to find the
one you feel more comfortable with. In the end, they all provide the
same functionality.&lt;/p&gt;
&lt;h3&gt;Linking to other modules&lt;/h3&gt;
&lt;p&gt;When you are documenting your programs, you will notice that you will
need to refer to some other pieces of code that you have written. In our
example, &lt;code&gt;Teacher&lt;/code&gt; subclasses &lt;code&gt;Person&lt;/code&gt;, and therefore it can be handy to
add a link to it in the docstring. You can edit &lt;strong&gt;people.py&lt;/strong&gt; with the
following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Teacher(Person):
    &amp;quot;&amp;quot;&amp;quot;Class to store a teacher's information. It subclasses :class:`Person`.&amp;quot;&amp;quot;&amp;quot;
    [...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note the addition of
&lt;code&gt;:class:`Person&lt;/code&gt;. If you build the documentation again, you will see that that code turns into a link the appropriate file. If you check Tag
0.7
&amp;lt;&lt;a href="https://github.com/PFTL/website/tree/0.7/example_code/11_documenting/docs/source"&gt;https://github.com/PFTL/website/tree/0.7/example_code/11_documenting/docs/source&lt;/a&gt;&amp;gt;_ you will see that it works even if you split the documentation into different files. For example, we have created a new page for the teacher documentation, but the link still points to where the class Person`
is defined.&lt;/p&gt;
&lt;h3&gt;Running tests with Sphinx&lt;/h3&gt;
&lt;p&gt;We have seen before that you can use the docstrings to run tests in your
code. You can think about them as testing your code or testing whether
your documentation is up to date. In any case, it would be very handy if
sphinx could run the &lt;code&gt;doctest&lt;/code&gt; while building the documentation. In this
way, you can check all your files, instead of testing one by one.&lt;/p&gt;
&lt;p&gt;The first step is to update your &lt;strong&gt;conf.py&lt;/strong&gt; file by adding the doctest
extension:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.doctest',]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now you can trigger sphinx with another parameter:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;sphinx-build -b doctest source/ output/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will generate a new file called &lt;strong&gt;output.txt&lt;/strong&gt; with the same
information that was printed to screen. Most likely you will see that
some fails appear, and if you look closely you will see that the problem
is that, for example, &lt;code&gt;NameError: name 'factorial' is not defined&lt;/code&gt;. This
happens because doctest is trying to run the example code without
importing the appropriate modules. The easiest solution is to explicitly
import the function you need. For example, &lt;code&gt;factorial&lt;/code&gt; will look like
this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def factorial(n):
    &amp;quot;&amp;quot;&amp;quot;Function to calculate the factorial of a number.
    First import, and then use, for example:

    &amp;gt;&amp;gt;&amp;gt; from my_module.factorial import factorial
    &amp;gt;&amp;gt;&amp;gt; factorial(5)
    120
    &amp;gt;&amp;gt;&amp;gt; factorial(-1)
    Traceback (most recent call last):
        ...
    ValueError: n must be &amp;gt;= 0

    :param n: Number to calculate the factorial
    :type n: int
    :return: The calculated factorial
    :rtype: int
    &amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also add the import statement to the docstring of the module,
and with this, you know that you will have it available in the rest of
the code. You can see, for example, the code at &lt;a href="https://github.com/PFTL/website/tree/0.8/example_code/11_documenting"&gt;Tag
0.8&lt;/a&gt;.
Running doctests is a great way of improving the quality of your
documentation and of your code without too much effort. Moreover, you
also give people the possibility to check that everything is behaving
correctly before sending your suggestions for code changes (pull
requests on Github).&lt;/p&gt;
&lt;h3&gt;Read The Docs&lt;/h3&gt;
&lt;p&gt;Now you have learned how to build the documentation on your local
machine. Anybody with your code and Sphinx installed can run the same
commands and build the HTML files. However, being able to host them
somewhere will make it very handy for people who would like to see and
learn from your code. It will also be indexed by search engines,
effectively increasing your online visibility. If you look around, all
big projects have their documentation hosted online.&lt;/p&gt;
&lt;p&gt;If you want to host the documentation on your own web server, you can do
it easily. However, this adds not only money for the web server, but
also effort, since you need to maintain the pages updated every time
there is a change to the documentation. This is when Read The Docs comes
into play. It is a service that automatically builds the documentation
of your projects and hosts it open to the public.&lt;/p&gt;
&lt;p&gt;The only requirement for Read the Docs to work is that you have your
code in a repository such as Github, GitLab or Bitbucket. I won't cover
the details of those repositories here, I will assume you know how to
work with them.&lt;/p&gt;
&lt;p&gt;Go to &lt;a href="https://readthedocs.org"&gt;Read The Docs (RTL)&lt;/a&gt; and create an
account. Follow the steps and activate your e-mail. Once you have logged
in, go to your settings:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Read the docs settings" class="center-img" src="/images/10_images/RTL_settings.png"&gt;&lt;/p&gt;
&lt;p&gt;And then you have to select the services you want to connect to your
account:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Connecting services to RTL" class="center-img" src="/images/10_images/RTL_settings.png"&gt;&lt;/p&gt;
&lt;p&gt;If for some reason you cannot connect the service that you want, you can
manually import the repository. Just go to &lt;strong&gt;My Projects&lt;/strong&gt; and select
the option that says &lt;strong&gt;Import Manually&lt;/strong&gt;. Once you have imported your
project, you have to configure how do you want your documentation to be
built. You have to open the project and go the*&lt;em&gt;Admin&lt;/em&gt;* panel. Select
&lt;strong&gt;Advanced Settings&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Connecting services to RTL" class="center-img" src="/images/10_images/RTL_advance_settings.png"&gt;&lt;/p&gt;
&lt;p&gt;You will see that the platform allows you to install the package inside
a Virtual Environment. This is very important and is something we
haven't discussed yet. When you build the documentation with Sphinx,
what is actually happening is that the program imports all the modules
and checks for the docstrings. For this to work, Sphinx needs to be able
to import the module. Let's say that you use numpy, which is not
installed by default with Python. If you import a module that depends on
numpy but it is not installed, the import process will fail.&lt;/p&gt;
&lt;p&gt;If you have a file that lists all the packages that have to be installed
for your program to work, Read The Docs can automatically install them
in a virtual environment and then build the documentation. That is what
the &lt;strong&gt;requirements.txt&lt;/strong&gt; file is for. You can see how to generate one by
reading &lt;a href="https://www.pythonforthelab.com/blog/virtual-environment-is-a-must-have-tool"&gt;our article on the Virtual
Environment&lt;/a&gt;. The other
important parameter is the location of the &lt;strong&gt;conf.py&lt;/strong&gt; file. Normally
you would place it in &lt;strong&gt;docs/source/conf.py&lt;/strong&gt;, but that can change from
project to project. You can go through the rest of the options. Remember
to set the proper Python version that you need for your program to run.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Connecting services to RTL" class="center-img" src="/images/10_images/RTL_advanced_settings.png"&gt;&lt;/p&gt;
&lt;p&gt;If you go to the &lt;strong&gt;Versions&lt;/strong&gt; option, you will be able to select for
which version to build the documentation. For example, you can build
documentation only for a specific branch, or for a specific version. In
this way you won't risk users reading documentation is not supposed to
be online yet but that is work in progress. Remember that if there is a
mismatch between the documentation and the code, a lot of questions are
going to arise.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Connecting services to RTL" class="center-img" src="/images/10_images/RTL_versions.png"&gt;&lt;/p&gt;
&lt;p&gt;That is basically it. You can trigger a build of your documentation and
see what happens. You can see the history of builds and their results.
If you click on any of them, you will see all the commands that were
executed and their outcome, if any. Including any errors. If the build
passes, you can click the green button that says &lt;strong&gt;View Docs&lt;/strong&gt;. Now you
have a beautiful, online version of the documentation of your program.&lt;/p&gt;
&lt;p&gt;Read the Docs even allows you to add the code of Google analytics to
track how many visitors your project has. However, when you start
building up in complexity, it is also harder for Read the Docs to work
out of the box. Special packages, which cannot be installed with &lt;code&gt;pip&lt;/code&gt;
need special handling, which we may cover in a future article.&lt;/p&gt;
&lt;p&gt;If you want the documentation to automatically build when there is an
update in the repository, you need to add a &lt;em&gt;webhook&lt;/em&gt;. Head over to the
Admin of your project and select &lt;strong&gt;Integrations&lt;/strong&gt; which will allow you
to set up a webhook. If you have any doubt, &lt;a href="https://docs.readthedocs.io/en/latest/webhooks.html"&gt;webhooks are very well
documented&lt;/a&gt; in Read
The Docs. The core idea is that any time there is a change in a
repository, it will use the webhook to let different services know about
the update, and that will trigger, for example, a new built of the
documentation.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;Documenting your code is fundamental if you want your programs to be
sustainable over time. Adding comments where appropriate is the first
step any good programmer should take. Adding docstrings to modules,
functions, and classes is the first step. If you add Sphinx to the mix,
you can start building beautiful documentation in the form of websites,
for example. Moreover, you can host the website with Read The Docs,
which will automatically build the documentation for you.&lt;/p&gt;
&lt;p&gt;Having the documentation as a website is a great way of attracting
attention. It will be indexed by search engines, making it more
discoverable. You can also supply examples, images, whatever you think
that can be useful. I really appreciate when the documentation guides
you quickly through the installation process and some examples. Just for
you to get started.&lt;/p&gt;
&lt;p&gt;Heder photo by
&lt;a href="https://unsplash.com/photos/AG2Ct_DqCh0?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText"&gt;chuttersnap&lt;/a&gt;
on Unsplash&lt;/p&gt;</content><category term="blog"></category><category term="Threads"></category><category term="Processes"></category><category term="Parallel"></category><category term="Speed"></category><category term="Async"></category><category term="Advanced"></category></entry><entry><title>Implementing Threads for Measurements</title><link href="https://www.pythonforthelab.com/blog/implementing-threads-for-measurements" rel="alternate"></link><published>2018-05-29T00:00:00+02:00</published><updated>2018-05-29T00:00:00+02:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2018-05-29:/blog/implementing-threads-for-measurements</id><summary type="html">&lt;p&gt;Probably you have run into the problem of wanting to update a plot while
acquiring a signal, but finding that Python is busy during the
acquisition. This happens, for example, when functions or methods take
long to execute and you can't regain control until it is done. Python
has at …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Probably you have run into the problem of wanting to update a plot while
acquiring a signal, but finding that Python is busy during the
acquisition. This happens, for example, when functions or methods take
long to execute and you can't regain control until it is done. Python
has at least two different ways of solving this issue, one is the
&lt;strong&gt;threading&lt;/strong&gt; module and the other is the &lt;strong&gt;multiprocessing&lt;/strong&gt; module.
They look the same but are fundamentally different, and therefore you
need to understand their differences in order to decide when to use one
or the other.&lt;/p&gt;
&lt;h2&gt;A Simple Measurement Class&lt;/h2&gt;
&lt;p&gt;First, let's build a simple measurement class to simulate what you would
normally find when performing an experiment. Imagine that you would like
to measure Ohm's law, i.e. the current that flows through a circuit as a
function of the voltage applied to it. We can create a class for the
measurement and within it, we can define a method to gather results.
Later it will become clear why we use a class instead of just a
function:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import numpy as np
from time import sleep

class OhmLaw:
    def make_measurement(self, start, stop, num_points, delay):
        x_axis = np.linspace(start, stop, num_points)
        data = []
        for i in x_axis:
            # Acquire fake data
            data.append(np.random.random())
            sleep(delay)

        return data
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a toy example, in which the data is randomly generated and we
are not really using the input parameters at all, but it shouldn't be
too hard to relate this to what you normally do in your lab. If you want
to run the code, you can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;ohm = OhmLaw()
result = ohm.make_measurement(0,1,11,1)
print(result)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, as soon as the code reaches the highlighted line, it
will hang until all the data is generated. This is a very common
scenario when the measurement is actively controlled by the computer. In
the example above you may wait for 10 seconds, which is not too bad, but
normally you would like to see the progress of your experiment in order
to decide how to continue.&lt;/p&gt;
&lt;h2&gt;Running the measurement in a non-blocking way&lt;/h2&gt;
&lt;p&gt;The first way of solving the issue is to run the measurement in the
background. This will allow you to continue with the execution of the
code after you have called &lt;code&gt;make_measurement&lt;/code&gt;.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;When you start dealing with threads, you will find yourself in the
situation of having a program that is running an infinite loop and
therefore it will never finish. &lt;strong&gt;Ctrl&lt;/strong&gt; + &lt;strong&gt;C&lt;/strong&gt; is your best friend to
stop the execution.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;The easiest way to achieve this behavior in Python is by using the
&lt;strong&gt;threading&lt;/strong&gt; module. Let's first see how to implement our solution and
then we can go into the details.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import threading

ohm = OhmLaw()

t = threading.Thread(target=ohm.make_measurement, args=(0,1,11,1))
t.start()
print('Triggered measurement')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the code above, what you will see is that right after
starting the thread, the &lt;code&gt;print&lt;/code&gt; statement is executed. You will also
notice that the program, even if it reached the end, is waiting for the
thread &lt;code&gt;t&lt;/code&gt; to be complete before exiting. We can add a bit more of
action in order to realize what is happening:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import threading
ohm = OhmLaw()

t = threading.Thread(target=ohm.make_measurement, args=(0,1,11,1))
t.start()
print('Triggered measurement')
i = 0
while t.is_alive():
    i += 1
    print('Acquiring {}\r'.format('.'*i), end=' ')
    sleep(0.5)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the code, you will see on the screen the message 'Acquiring'
with an incrementing number of dots. If you add a print statement to the
&lt;code&gt;make_measurement&lt;/code&gt; method, you will see that it gets interleaved into
the output. You can already see that there are two different tasks
running at the same time. On one hand, you have the &lt;code&gt;make_measurement&lt;/code&gt;
method that takes longer to run, on the other you are refreshing the
screen every half a second. But it is time to learn a bit more about
what are the threads we have just created.&lt;/p&gt;
&lt;h2&gt;What are Threads&lt;/h2&gt;
&lt;p&gt;A crucial component of every computer is its processor. It is the piece
of hardware that makes all the calculations and decisions. You probably
know that the amount of computations per unit of time that a processor
can perform is limited. That is why some programs take longer to open,
or complex code takes longer to complete. However, you may have noticed
that on your computer several programs can be performing tasks
simultaneously. This is thanks to the operating system, which iterates
through different programs in order to keep them all responding.&lt;/p&gt;
&lt;p&gt;Within Python, the same functionality can be achieved. Each thread is
nothing more than a Python program interpreter running specific tasks.
Each program will have a main thread and you may spawn child threads
from within it, as you have seen above. This means that in the line
where you define &lt;code&gt;threading.Thread&lt;/code&gt;, what you are actually doing is
creating a new python interpreter within your own program, and that
interpreter will be running the method &lt;code&gt;make_measurement&lt;/code&gt; with the given
arguments.&lt;/p&gt;
&lt;h2&gt;Plotting Results During Acquisition&lt;/h2&gt;
&lt;p&gt;So far, the only thing we have done is to print to screen that the
acquisition is happening. However, the results of the measurement are
lost, we don't plot nor save them after the program finishes. Now is the
time when we can exploit the use of a class instead of a simple
function. Remember that the core objective of using classes is to
preserve state, exactly what we want to do. We can improve &lt;code&gt;OhmLaw&lt;/code&gt; like
this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class OhmLaw:
    def __init__(self):
        self.data = np.zeros(0)  # To store the data of the measurement
        self.step = 0  # To keep track of the step

    def make_measurement(self, start, stop, num_points, delay):
        x_axis = np.linspace(start, stop, num_points)
        self.data = np.zeros(num_points)
        self.step = 0
        for i in x_axis:
            # Acquire fake data
            self.data[self.step] = np.random.random()
            self.step += 1
            sleep(delay)

        return self.data
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What we have done now is to define attributes of &lt;code&gt;OhmLaw&lt;/code&gt; (i.e.,
&lt;code&gt;self.data&lt;/code&gt; and &lt;code&gt;self.step&lt;/code&gt;) that will keep track of the acquisition.
The data is immediately available after it has been generated, and
therefore we can change how we trigger the measurement, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import threading
ohm = OhmLaw()

t = threading.Thread(target=ohm.make_measurement, args=(0,1,11,1))
t.start()
print('Triggered measurement')
i = ohm.step
while t.is_alive():
    if i != ohm.step:
        print('Latest data value: {}'.format(ohm.data[ohm.step-1]))
        i = ohm.step
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first few lines are the same, but what we are changing is the
&lt;code&gt;while&lt;/code&gt; loop. First, we check if the &lt;code&gt;step&lt;/code&gt; we are measuring is
different from the last step we saw. If it is different, then we get the
latest data point. Remember that, since the step is incremented right
after the acquisition, we should retrieve &lt;code&gt;data[ohm.step-1]&lt;/code&gt; or we would
be ahead one data point.&lt;/p&gt;
&lt;p&gt;As you can see, the &lt;code&gt;while&lt;/code&gt; loop doesn't have any kind of delay, as soon
as a new data point is detected, it will be fetched. If you change the
&lt;code&gt;delay&lt;/code&gt; for &lt;code&gt;make_measurement&lt;/code&gt; you will see that the printing to the
screen is also altered. This may not be exactly the behavior that you
want. In our case, poking the &lt;code&gt;ohm.step&lt;/code&gt; is fast, but it may be that you
have to communicate to a device to see if there are new data points and
perhaps you don't want to do that as fast as possible but after a
certain interval. The code would become:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import threading
ohm = OhmLaw()

t = threading.Thread(target=ohm.make_measurement, args=(0,1,11,1))
t.start()
print('Triggered measurement')
i = ohm.step
while t.is_alive():
    if i != ohm.step:
        print('Number of points acquired: {}'.format(ohm.step-1))
        i = ohm.step
    sleep(2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As simple as that, now you are checking the &lt;code&gt;ohm.step&lt;/code&gt; attribute only
once every two seconds. If you start playing around you will see a lot
of different behaviors. For example, you will notice that you may lose
the last few steps of the measurement if the refresh rate is not fast
enough, etc. All these considerations are natural when you start dealing
with threads and actions happening simultaneously.&lt;/p&gt;
&lt;h2&gt;Multiple Threads&lt;/h2&gt;
&lt;p&gt;If you are of a curious type, probably you are wondering if you could
start as many threads as you like. In principle the answer is yes, you
are not limited to only one. In fact, when you start a thread, it is
technically the second one running, since the main thread is the one
that holds the code. Imagine that you want to start a second
measurement, you can do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;meas_1 = threading.Thread(target=ohm.make_measurement, args=(0, 1, 11, 1))
meas_1.start()
meas_2 = threading.Thread(target=ohm.make_measurement, args=(0, 1, 20, 1))
meas_2.start()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the code above, you will have two threads, one called
&lt;code&gt;meas_1&lt;/code&gt; and the other &lt;code&gt;meas_2&lt;/code&gt;, however they share the same &lt;code&gt;data&lt;/code&gt; and
&lt;code&gt;step&lt;/code&gt; attribute in the object &lt;code&gt;ohm&lt;/code&gt;. Every time a data point is
generated, it will overwrite the value acquired in the other thread. If
you were dealing with a real device, it would become much worse, because
you would be trying to set two different output voltages on the same
device at the same time.&lt;/p&gt;
&lt;p&gt;There are different ways around this, the first one is altering the
method &lt;code&gt;make_measurement&lt;/code&gt; in order to allow only one execution at a
time. This can be done by checking if an attribute &lt;code&gt;running&lt;/code&gt; is set to
&lt;code&gt;True&lt;/code&gt; or not. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class OhmLaw:
    def __init__(self):
        self.data = np.zeros(0)  # To store the data of the measurement
        self.step = 0  # To keep track of the step
        self.running = False

    def make_measurement(self, start, stop, num_points, delay):
        if self.running:
            raise Exception(&amp;quot;Can't trigger two measurements at the same time&amp;quot;)

        x_axis = np.linspace(start, stop, num_points)
        self.data = np.zeros(num_points)
        self.step = 0
        self.running = True
        for i in x_axis:
            # Acquire fake data
            self.data[self.step] = np.random.random()
            self.step += 1
            sleep(delay)
        self.running = False
        return self.data
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The main changes here are that we set the attribute &lt;code&gt;running&lt;/code&gt; to &lt;code&gt;False&lt;/code&gt;
when we instantiate the class. Then, when we trigger the
&lt;code&gt;make_measurement&lt;/code&gt; method, we check if running is set or not. If it is
set, we raise an error that will prevent the method to be run again. If
it is not set, we continue as always. Check that before entering into
the time-consuming loop, we set &lt;code&gt;self.running&lt;/code&gt; to &lt;code&gt;True&lt;/code&gt; and we set it
back to &lt;code&gt;Flase&lt;/code&gt; when it is finished. Go ahead and try to run twice the
measurement and you won't be allowed.&lt;/p&gt;
&lt;p&gt;It may seem a bit far-fetched, but trying to run the measurement twice
is a very common mistake when you have a graphical user interface.
Sometimes you don't realize that a measurement is going on and you try
to start a new one. Now we know how to avoid triggering twice the same
measurement, but there is one big functionality missing: how to stop a
measurement.&lt;/p&gt;
&lt;h2&gt;Stopping a Thread&lt;/h2&gt;
&lt;p&gt;When you are running a long task, such as acquiring from a device, it
may happen that you need to stop it. For example, you may notice that
something is not right with your data, or you already have sufficient
information to move on and doesn't make sense to wait until the end.
Python doesn't allow you to kill threads, which means that we have to
find a way around it. As you have seen in the examples above, we are
normally exchanging information with the thread through attributes in a
class. This means that we could use the same strategy to stop a thread,
by breaking the loop. The &lt;code&gt;OhmLaw&lt;/code&gt; class will look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class OhmLaw:
    def __init__(self):
        self.data = np.zeros(0)  # To store the data of the measurement
        self.step = 0  # To keep track of the step
        self.running = False
        self.stop = False

    def make_measurement(self, start, stop, num_points, delay):
        if self.running:
            raise Exception(&amp;quot;Can't trigger two measurements at the same time&amp;quot;)

        x_axis = np.linspace(start, stop, num_points)
        self.data = np.zeros(num_points)
        self.step = 0
        self.stop = False
        self.running = True
        for i in x_axis:
            if self.stop:
                print('Stopping')
                break
            # Acquire fake data
            self.data[self.step] = np.random.random()
            self.step += 1
            sleep(delay)
        self.running = False
        return self.data
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The highlighted lines point to the changes that we have done in order to
stop the loop. Whenever you feel like stopping the acquisition, the only
thing you need to do is the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;ohm.stop = True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And as soon as the last point is generated, the loop will exit without
errors. Since you will have access to &lt;code&gt;ohm.step&lt;/code&gt; you will know exactly
how many data points were acquired, and those will be available in
&lt;code&gt;ohm.data&lt;/code&gt;. At this point, something that should be bugging you is that
we are polluting the &lt;code&gt;OhmLaw&lt;/code&gt; class with attributes and considerations
that are inherent to working with threads. If you were to use the class
in a non-threaded application, the &lt;code&gt;self.stop&lt;/code&gt;, &lt;code&gt;self.running&lt;/code&gt;, etc. are
not useful and are just making the code more complicated.&lt;/p&gt;
&lt;h2&gt;Subclassing a Thread&lt;/h2&gt;
&lt;p&gt;One of the many advantages of Python's syntax is that it is very easy to
extend the functionality of any module. In this case, we want to expand
how the &lt;code&gt;Thread&lt;/code&gt; works, by allowing a direct interaction with the
&lt;code&gt;OhmLaw&lt;/code&gt; class. Let's see first how to subclass a &lt;code&gt;Thread&lt;/code&gt; in order to
start personalizing it. In the examples above, we have constructed a
thread and we have called the &lt;code&gt;start&lt;/code&gt; method. When you subclass a
thread, you don't define a &lt;code&gt;start&lt;/code&gt;, but rather a &lt;code&gt;run&lt;/code&gt; method. The
&lt;a href="https://docs.python.org/3/library/threading.html#thread-objects"&gt;official
documentation&lt;/a&gt;
is quite clear:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from threading import Thread

class Worker(Thread):
    def __init__(self, target, args=None):
        super().__init__()
        self.target = target
        self.args = args

    def run(self):
        self.target(*self.args)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;Worker&lt;/code&gt; class works exactly the same as a &lt;code&gt;Thread&lt;/code&gt;. You can replace
the code to run a measurement like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;meas_1 = Worker(target=ohm.make_measurement, args=(0, 1, 11, 1))
meas_1.start()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And it will behave in the same way as running a normal &lt;code&gt;Thread&lt;/code&gt;.
Remember that the highlighted line is very important in order to inherit
all the functionality from the base class. The main question is why
would you like to have a custom thread instead of using the default.
Imagine that you don't want to raise an error when you trigger a second
measurement, but instead, you want to build a queue of commands to
execute. In that way, you won't find any issues, nor in our simple
example nor when dealing with real devices.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Worker(Thread):
    def __init__(self):
        super().__init__()
        self.queue = []
        self.keep_running = True

    def add_to_queue(self, target, args=None):
        print('Adding to queue')
        self.queue.append((target, args))

    def stop_thread(self):
        self.keep_running = False

    def run(self):
        while self.keep_running:
            if self.queue:
                func, args = self.queue.pop(0)
                func(*args)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;Worker&lt;/code&gt; class has now become a useful tool to run several functions
one after the other. The only thing you need to do is to use the method
&lt;code&gt;add_to_queue&lt;/code&gt; with the appropriate arguments. Let's see step by step.
First, we removed the arguments from the &lt;code&gt;__init__&lt;/code&gt; because we don't
need them. We created two attributes, &lt;code&gt;keep_running&lt;/code&gt; that is going to be
used to stop the execution of the thread. You would use it like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;worker = Worker()
worker.start()
worker.add_to_queue(ohm.make_measurement, args=(0, 1, 11, .1))
worker.add_to_queue(ohm.make_measurement, args=(0, 1, 11, .1))
worker.add_to_queue(ohm.make_measurement, args=(0, 1, 11, .1))
while worker.queue:
    print('Queue length: {}'.format(len(worker.queue)))
    sleep(1)
worker.stop_thread()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We begin by creating the &lt;code&gt;worker&lt;/code&gt; and starting a separate thread. This
is the reason why we have to do &lt;code&gt;start()&lt;/code&gt; after instantiating it. The
&lt;code&gt;run&lt;/code&gt; method is an infinite loop that will look for elements within the
&lt;code&gt;queue&lt;/code&gt;. If there is a new element, it will get it and it will execute
it. The &lt;code&gt;pop&lt;/code&gt; command is very useful because it retrieves the element in
the first position and deletes that element from the list. As soon as
you add an element to the queue, it will be executed. You could add, for
example, a method for generating data, a method for saving the data,
etc. Remember that if you don't stop the &lt;code&gt;worker&lt;/code&gt; with &lt;code&gt;stop_thread()&lt;/code&gt;
the program will never finish, because the &lt;code&gt;worker&lt;/code&gt; is hanging in an
infinite loop.&lt;/p&gt;
&lt;p&gt;You can try different things, for example reimplementing the &lt;code&gt;is_alive&lt;/code&gt;
method. There are no real limits to how much you can bend and improve
built-ins by subclassing them. A very useful method to be sure that the
thread has finished running is &lt;code&gt;join&lt;/code&gt;. If you use &lt;code&gt;worker.join()&lt;/code&gt;, the
program will block there until the thread is effectively finished.&lt;/p&gt;
&lt;h2&gt;Using Locks&lt;/h2&gt;
&lt;p&gt;The example above is already more complicated than what you normally
need to do in the lab. After all, you are in complete control of your
experiment and therefore you know that you shouldn't trigger two
measurements at the same time. However, there are several tools in
threads that at some point may be useful for you and therefore it makes
sense to know, at least, that they exist. One of such tools is &lt;em&gt;locks&lt;/em&gt;.
A lock allows you to prevent the execution of code if another thread is
doing something. Let's see how it works. We start with the simple
version of the &lt;code&gt;worker&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from threading import Thread, Lock

lock = Lock()

class Worker(Thread):
    def __init__(self, target, args=None):
        super().__init__()
        self.target = target
        self.args = args

    def run(self):
        lock.acquire()
        self.target(*self.args)
        lock.release()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We define a &lt;code&gt;lock&lt;/code&gt; outside of the &lt;code&gt;Worker&lt;/code&gt;, because it needs to be
shared between different instances. The idea of a lock is that it is
open by default. When you do &lt;code&gt;lock.acquire()&lt;/code&gt; you are going to close the
lock. Unless it is already closed, in which case the code will halt in
there waiting until the command &lt;code&gt;lock.release()&lt;/code&gt; is executed. We acquire
the lock just before running the function, i.e. when the &lt;code&gt;start()&lt;/code&gt; is
executed and we release it right after. If you try to run two
measurements, the second will halt until the first one is finished. The
code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;meas_1 = Worker(target=ohm.make_measurement, args=(0, 1, 11, 1))
meas_1.start()
meas_2 = Worker(target=ohm.make_measurement, args=(0, 1, 11, 1))
meas_2.start()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Even if not blocking, because everything was delegated to a thread, will
run only one measurement at a time. This is a neat trick that if you
implement correctly can save you a lot of time checking whether a
specific task is already running or not. Remember that a crucial mistake
happens when, for example, an error appears. If the target function
raises an error, the &lt;code&gt;lock.release()&lt;/code&gt; line will never be executed and
the subsequent threads will never run.&lt;/p&gt;
&lt;h2&gt;Advantages and Limitations of Threads&lt;/h2&gt;
&lt;p&gt;Right now, especially if it is your first encounter with threads in
Python, they may look like the solution to all your problems. They are
an amazing tool, relatively easy to implement, there is no argument
against that. One of the main advantages of threads is that the memory
space is shared, and therefore you can use the information stored in the
class &lt;code&gt;OhmLaw&lt;/code&gt; in any thread, even the main thread. This allows you to
monitor the progress, update a plot or even alter the execution of a
method while it is running.&lt;/p&gt;
&lt;p&gt;However, we never discussed what happens when the tasks running on
threads are computationally expensive. So far, the methods that we have
been running inside threads were spending more time in a &lt;code&gt;sleep&lt;/code&gt;
statement than anything else. This is a normal case for slow
experiments, but as soon as you start doing data analysis while you
acquire, or you generate a lot of data, things are going to get more
complicated. Let's first see an easy example. Computing random numbers
is a relatively expensive task (by &lt;em&gt;expensive&lt;/em&gt; I mean computationally).
We can define the following function:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import numpy as np

def calculate_random(number_points):
    for i in range(10, number_points):
        data = np.random.random(i)
        fft = np.fft.fft(data)
    return fft
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is an expensive function. We calculate random arrays of variable
size and compute their Fourier transform.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from time import time
t0 = time()
d = calculate_random(5000)
print('Total time: {:2.2f} seconds'.format(time()-t0))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the code above, most likely you are going to get something in
the order of 10 seconds. Most likely you are working on a multi-core
computer. This means that you have different processors available at the
same time. If you look at the use of them while the above code is
running, you probably will notice that there are only one of the cores
being used at 100%, while the others are quite free.&lt;/p&gt;
&lt;p&gt;If you were to run the code more than once, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;d = calculate_random(5000)
d2 = calculate_random(5000)
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You will notice that the total time is multiplied by the number of calls
to &lt;code&gt;calculate_random&lt;/code&gt;. This is expected because while the first is
running the program is waiting and when it is done, you execute the
other. Let's see what happens if we run the code in two different
threads:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from time import time
from threading import Thread

t0 = time()
t1 = Thread(target=calculate_random, args=(5000,))
t2 = Thread(target=calculate_random, args=(5000,))
t1.start()
t2.start()
t1.join()
t2.join()
print('Total time: {:2.2f} seconds'.format(time()-t0))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Most likely you will see that even if you are running in two different
threads, the time it takes to run is twice as long and if you monitor
the processors, you will still see that only one is being used. This
happens because Python implemented something called the &lt;strong&gt;Global
Interpreter Lock&lt;/strong&gt;, or &lt;strong&gt;GIL&lt;/strong&gt;.&lt;/p&gt;
&lt;h3&gt;The GIL&lt;/h3&gt;
&lt;p&gt;The Global Interpreter Lock is responsible for triggering concurrently
different parts of the code. As we saw earlier, a lock is a tool that
allows you to wait for other processes to finish before you start
something new. In Python, this means that when you are running code,
there is a default daemon that will make sure that no two different
lines are executed at the same time.&lt;/p&gt;
&lt;p&gt;Basically what the GIL is doing is similar to what the operating system
does in single-core CPUs. It runs a task for a short time, switches to
another task runs it for a while, switches, etc. On one hand, this
behavior has a computational cost associated with the switching from one
task to another, on the other, it is not equivalent to two tasks running
simultaneously. When the task is not computationally expensive (such as
&lt;code&gt;sleep&lt;/code&gt;), you will see an increase in efficiency. However, when you
start with more complex scenarios where you need to analyze data or save
to disk, etc., you may start finding bottlenecks hard to debug and you
will see that your computer is far from crashing.&lt;/p&gt;
&lt;p&gt;The GIL is also responsible for preventing the simultaneous access to
the same memory. Imagine that you are updating a value at the same time
that you are deleting it from a different thread. You may face several
corruption problems if you are not very careful about how you implement
your threads.&lt;/p&gt;
&lt;p&gt;The main message, therefore, is that &lt;strong&gt;threading&lt;/strong&gt; doesn't allow you to
run code in parallel, i.e. in different cores, but it allows you to run
tasks in a non-blocking way. The benefits of using Threads are, for
example, that you can share the memory and that you don't need to be too
careful about how you read or write data into variables. Especially when
dealing with normal experiments, threads are going to be more than
enough to improve the behavior of your programs.&lt;/p&gt;
&lt;h2&gt;The Multiprocessing Module&lt;/h2&gt;
&lt;p&gt;It would be somewhat naïve to settle with the &lt;em&gt;threading&lt;/em&gt; module and
limit ourselves to one core per computer. Python provides another module
called &lt;em&gt;multiprocessing&lt;/em&gt;. You can read the details at &lt;a href="https://docs.python.org/3.6/library/multiprocessing.html"&gt;the official
documentation&lt;/a&gt;.
Fortunately, the way to work with this module is very similar to the way
you work with threads. Let's build on the previous example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from multiprocessing import Process

t0 = time()
t1 = Process(target=calculate_random, args=(5000,))
t2 = Process(target=calculate_random, args=(5000,))
t3 = Process(target=calculate_random, args=(5000,))
t1.start()
t2.start()
t3.start()
t1.join()
t2.join()
t3.join()
print('Total time: {:2.2f} seconds'.format(time()-t0))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When you run the code above, you will see that all the processors in
your computer are engaged. The number of processes that you can spawn is
not limited, but normally you shouldn't see an increase in performance
once you have as many processes as cores on your computer.&lt;/p&gt;
&lt;p&gt;Multiprocessing has, however, a limitation that has to be addressed
carefully: the state is not shared. Therefore, each process will have
access to its own resources, but you can't simply exchange them. For
example, in the experiment, if you start the measurement after you have
created the process, the class would have the same value for
&lt;code&gt;self.running&lt;/code&gt;, meaning that the second time you want to run it, nothing
will stop you.&lt;/p&gt;
&lt;h2&gt;Sharing Information with Queues&lt;/h2&gt;
&lt;p&gt;The proper way of exchanging information between processes is to use
Queues. When we developed the worker earlier, we used the word &lt;em&gt;queue&lt;/em&gt;
exactly preparing for this topic. A queue holds information that can be
accessed by any thread in a first-in-first-out base. Let's see a simple
example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from multiprocessing import Process, Queue


def move_from_in_to_out(q_in, q_out):
    while not q_in.empty():
        data = q_in.get()
        q_out.put(data)


q_in = Queue()
q_out = Queue()

for i in range(1000):
    q_in.put(i)

p = Process(target=move_from_in_to_out, args=(q_in, q_out))
p.start()
p.join()

print('Q_in is empty: {}'.format(q_in.empty()))

while not q_out.empty():
    print(q_out.get())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, we define a function that can work with &lt;code&gt;Queues&lt;/code&gt;, &lt;code&gt;q_in&lt;/code&gt; and
&lt;code&gt;q_out&lt;/code&gt;. In the example, we are just grabbing elements from one and
placing them in the other. To grab an element from a queue you use
&lt;code&gt;get()&lt;/code&gt; and you use &lt;code&gt;put&lt;/code&gt; for the opposite. We populate the &lt;code&gt;q_in&lt;/code&gt; with
some initial values and then we start a process. Once it is finished, we
check that the queue is empty and we print all the elements.&lt;/p&gt;
&lt;p&gt;There is nothing really fancy about the example, but it is enough for
getting you started. Of course, different processes can access the same
queue. For example, you could add a second process that does the
opposite, moves from &lt;code&gt;q_out&lt;/code&gt; to &lt;code&gt;q_in&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;p = Process(target=move_from_in_to_out, args=(q_in, q_out))
p2 = Process(target=move_from_in_to_out, args=(q_out, q_in))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since &lt;code&gt;p2&lt;/code&gt; will not run if &lt;code&gt;q_out&lt;/code&gt; is empty, we should populate it
together with &lt;code&gt;q_in&lt;/code&gt;. Moreover, we can add a new process to monitor
which one of the other two is winning.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def print_len_queue(q_in, q_out):
    while not q_in.empty() or not q_out.empty():
        space = int(q_in.qsize() / (q_in.qsize() + q_out.qsize()) * 50)
        output = str(q_in.qsize())+ '||' + space * ' '+ '|' + (50-space) * ' ' + '||' + str(q_out.qsize()) + '\r'
        print(output, end=' ')

p3 = Process(target=print_len_queue, args=(q_in, q_out))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you start all the processes, what you will see on screen is a
vertical bar that moves to the left or to the right, according to which
queue is getting full. This is just a toy example, but that already
shows how powerful queues are.&lt;/p&gt;
&lt;h2&gt;Limitation of Queues&lt;/h2&gt;
&lt;p&gt;Before you get too enthusiastic about &lt;em&gt;queues&lt;/em&gt;, there is a fundamental
limitation that you may encounter if you work intensively with them,
especially when acquiring large volumes of data. I wanted to use queues
in order to acquire images from a CCD and stream them to the hard drive,
in order to increase the total time that could be acquired before
running out of memory. The idea was having a &lt;em&gt;process&lt;/em&gt; that would
continuously fetch images from a camera and put them into a queue. A
second process would fetch them from it and would save them to a file.&lt;/p&gt;
&lt;p&gt;However, it is impossible to know how big a queue can be in Python.
Allocating memory is not trivial since the queue can hold any type of
data. If you monitor the memory available, you will notice that the
larges value that you can store varies from execution to execution and
therefore you won't be able to predict exactly when you are running out
of memory. If you find a solution to this problem, please leave a
comment because I am more than intrigued by it.&lt;/p&gt;
&lt;p&gt;The only solution that I came up with was to manually limit the amount
of memory that the queue can take up based on previous experiences. Once
a threshold is surpassed, the program would stop acquiring images until
the queue is free. It is not very elegant, but at least it doesn't crash
and therefore the data is saved.&lt;/p&gt;
&lt;h2&gt;Threads and Jupyter&lt;/h2&gt;
&lt;p&gt;If you are a Jupyter notebook user, you will be very happy to know that
threads are compatible with it. Imagine that you are analyzing a large
dataset, or that you are performing a measurement from within a cell. It
would be ideal to be able to run other cells simultaneously. If you run
either a Thread or a Process in one cell, you will be able to continue
using your notebook without any problems.&lt;/p&gt;
&lt;p&gt;This is very handy if, for example, you are running a simulation and you
would like to check the intermediate results. The same steps that we
have done at the beginning, with the simulated acquisition of data, can
be performed from within Jupyter. I won't cover the details in this
article because they deserve a separated entry, but please, play around
and leave your experience in &lt;a href="https://github.com/PFTL/pftl_discussions"&gt;the
forum&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;Being able to run code in non-blocking ways is fundamental in many
applications, not only in the lab but also when you are analyzing or
simulating data. When you are running tasks that are not computationally
expensive but that take longer to complete, you can easily implement
threads. In this article, we have covered some of the strategies that
you can implement in order to be able to stop the execution of a thread
and how to define your custom workers.&lt;/p&gt;
&lt;p&gt;When you are trying to increase the efficiency of a computationally
expensive program, &lt;em&gt;threading&lt;/em&gt; is not going to help you because of the
Global Interpreter Lock (GIL). You should, therefore, use the
&lt;em&gt;multiprocessing&lt;/em&gt; module, which implements a very similar API to the
&lt;em&gt;threading&lt;/em&gt; module. This makes your code easy to adapt. The main
limitation is that the memory between different processes is not shared,
and therefore you need to implement extra strategies in order to
exchange data. We have covered Queues, but they are not the only ones.&lt;/p&gt;
&lt;p&gt;When the complexity of your program increases, you should always check
whether the modules you are using are &lt;strong&gt;thread-safe&lt;/strong&gt; or not. Many
developers take into account this factor and develop code that can be
run also within threads. However, many developers may not have taken
into account that their module could be used in this context and
therefore you should test it yourself.&lt;/p&gt;
&lt;p&gt;Threading is a very exciting way of programming and is compatible also
with older Python versions. I find the Threading and the Multiprocessing
syntax very clear and very handy for running tasks such as the ones that
appear when controlling a setup or analyzing data. Since Python 3.4
there is a new library called
&lt;a href="https://docs.python.org/3/library/asyncio.html"&gt;Async&lt;/a&gt; that allows
running code asynchronously. It looks like the future for this kind of
programming, but I found the syntax much harder to understand in order
to propose solutions.&lt;/p&gt;
&lt;p&gt;As always, &lt;a href="https://github.com/PFTL/website/tree/master/example_code/10_threads_processes"&gt;the example code can be found
here&lt;/a&gt;,
as well as &lt;a href="https://github.com/PFTL/website/blob/master/content/blog/10_threads_or_processes.rst.md"&gt;the source code for this
article&lt;/a&gt;.
If you find any mistakes or improvements, you are more than welcome to
submit them as pull requests on Github.&lt;/p&gt;
&lt;p&gt;Header photo by &lt;a href="https://unsplash.com/photos/TYhEoWbbayQ?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText"&gt;frank
mckenna&lt;/a&gt;
on Unsplash&lt;/p&gt;</content><category term="blog"></category><category term="Threads"></category><category term="Processes"></category><category term="Parallel"></category><category term="Speed"></category><category term="Async"></category><category term="Advanced"></category></entry><entry><title>A Primer on Classes in Python</title><link href="https://www.pythonforthelab.com/blog/a-primer-on-classes-in-python" rel="alternate"></link><published>2018-05-22T00:00:00+02:00</published><updated>2018-05-22T00:00:00+02:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2018-05-22:/blog/a-primer-on-classes-in-python</id><summary type="html">&lt;p&gt;Python is an object-oriented programming (OOP) language. Object-oriented
programming is a programming design that allows developers not only to
define the type of data of a variable but also the operations that can
act on that data. For example, a variable can be of type integer, float,
string, etc. We …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Python is an object-oriented programming (OOP) language. Object-oriented
programming is a programming design that allows developers not only to
define the type of data of a variable but also the operations that can
act on that data. For example, a variable can be of type integer, float,
string, etc. We know that we can multiply an integer to another, or
divide a float by another, but that we cannot add an integer to a
string. Objects allow programmers to define operations both between
different objects as with themselves. For example, we can define an
object &lt;code&gt;person&lt;/code&gt;, add a birthday and have a function that returns the
person's age.&lt;/p&gt;
&lt;p&gt;At the beginning it will not be clear why objects are useful, but over
time it becomes impossible not to think with objects in mind. Python
takes the objects ideas one step further, and considers every variable
an object. Even if you didn't realize, it is possible that you have
already encountered some of these ideas when working with numpy arrays,
for example. In this chapter we are going to cover from the very basics
of object design to slightly more advanced topics in which we can define
a custom behavior for most of the common operations.&lt;/p&gt;
&lt;h2&gt;Defining a Class&lt;/h2&gt;
&lt;p&gt;Let's dive straight into how to work with classes in Python. Defining a
class is as simple as doing:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Person:
    pass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When speaking it is very hard not to interchange the words &lt;code&gt;Class&lt;/code&gt; and
&lt;code&gt;Object&lt;/code&gt;. The reality is that the difference between them is very
subtle: an object is an instance of a class. This means that we will use
the word &lt;em&gt;classes&lt;/em&gt; when referring to the type of variable, while we will
use &lt;em&gt;object&lt;/em&gt; to the variable itself. It is going to become clearer later
on.&lt;/p&gt;
&lt;p&gt;In the example above, we've defined a class called &lt;code&gt;Person&lt;/code&gt; that doesn't
do anything, that is why it says &lt;code&gt;pass&lt;/code&gt;. We can add more functionality
to this class by declaring a function that belongs to it. Create a file
called &lt;strong&gt;person.py&lt;/strong&gt; and add the following code to it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Person:
    def echo_name(self, name):
        return name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In Python, the functions that belong to classes are called &lt;strong&gt;methods&lt;/strong&gt;.
For using the class, we have to create a variable of type person. Back
in the Python Interactive Console, you can, for example, do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; from person import Person
&amp;gt;&amp;gt;&amp;gt; me = Person()
&amp;gt;&amp;gt;&amp;gt; me.echo_name(&amp;quot;John Snow&amp;quot;)
John Snow
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first line imports the code into the interactive console. For this
to work, it is important that you trigger python directly from the same
folder where the file &lt;strong&gt;person.py&lt;/strong&gt; is located. When you run the code
above, you should see as output &lt;code&gt;John Snow&lt;/code&gt;. There is also an important
detail that was omitted this far, the presence of &lt;code&gt;self&lt;/code&gt; in the
declaration of the method. All the methods in python take a first input
variable called self, referring to the class itself. For the time being
don't stress yourself about it, but bear in mind that when you define a
new method, you should always include the &lt;code&gt;self&lt;/code&gt;, but when calling the
method you should never include it. You can also write methods that
don't take any input, but still will have the &lt;code&gt;self&lt;/code&gt; in them, for
example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def echo_True(self):
    return &amp;quot;True&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;that can be used by doing:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; me.echo_True()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So far, defining a function within a class has no advantage at all. The
main difference, and the point where methods become handy is because
they have access to all the information stored within the object itself.
The &lt;code&gt;self&lt;/code&gt; argument that we are passing as first argument of the
function is exactly that. For example, we can add the following two
methods to our class Person:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def store_name(self, name):
    self.stored_name = name

def get_name(self):
    return self.stored_name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then we can execute this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; me = Person()
&amp;gt;&amp;gt;&amp;gt; me.store_name('John Snow')
&amp;gt;&amp;gt;&amp;gt; print(me.get_name())
John Snow
&amp;gt;&amp;gt;&amp;gt; print(me.stored_name)
John Snow
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What you can see in this example is that the method &lt;code&gt;store_name&lt;/code&gt; takes
one argument, &lt;code&gt;name&lt;/code&gt; and stores it into the class variable
&lt;code&gt;stored_name&lt;/code&gt;. Variables in the context of classes are called
&lt;strong&gt;attributes&lt;/strong&gt; in the context of a class. The method &lt;code&gt;get_name&lt;/code&gt; just
returns the stored property. What we showed in the last line is that we
can access the property directly, without the need to call the
&lt;code&gt;get_name&lt;/code&gt; method. In the same way, we don't need to use the
&lt;code&gt;store_name&lt;/code&gt; method if we do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; me.stored_name = 'Jane Doe'
&amp;gt;&amp;gt;&amp;gt; print(me.get_name())
Jane Doe
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One of the advantages of the attributes of classes is that they can be
of any type, even other classes. Imagine that you have acquired a time
trace of an analog sensor and you have also recorded the temperature of
the room when the measurement started. You can easily store that
information in an object:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;measurement.temperature = '20 degrees'
measurement.timetrace = np.array([...])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What you have so far is a vague idea of how classes behave, and maybe
you are starting to imagine some places where you can use a class to
make your daily life easier and your code more reusable. However, this
is just the tip of the iceberg. Classes are very powerful tools.&lt;/p&gt;
&lt;h2&gt;Initializing classes&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Instantiating&lt;/strong&gt; a class is the moment in which we call the class and
pass it to a variable. In the previous example, the instantiation of the
class happened at the line reading &lt;code&gt;me = Person()&lt;/code&gt;. You may have noticed
that the property &lt;code&gt;stored_name&lt;/code&gt; does not exist in the object until we
assign a value to it. This can give very serious headaches if someone
calls the method &lt;code&gt;get_name&lt;/code&gt; before actually having a name stored (you
can give it a try to see what happens!) Therefore it is very useful to
run a default method when the class is first called. This method is
called &lt;code&gt;__init__&lt;/code&gt;, and you can use it like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Person():
    def __init__(self):
        self.stored_name = &amp;quot;&amp;quot;

    [...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you go ahead and run the &lt;code&gt;get_name&lt;/code&gt; without actually storing a name
beforehand, now there will be no error, just an empty string being
returned. While initializing you can also force the execution of other
methods, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def __init__(self):
    self.store_name('')

[...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Will have the same final effect. It is however common (and smart)
practice, to declare all the variables of your class at the beginning,
inside your &lt;code&gt;__init__&lt;/code&gt;. In this way you don't depend on specific methods
being called to create the variables.&lt;/p&gt;
&lt;p&gt;As with any other method, you can have an &lt;code&gt;__init__&lt;/code&gt; method with more
arguments than just &lt;code&gt;self&lt;/code&gt;. For example you can define it like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def __init__(self, name):
    self.stored_name = name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now the way you instantiate the class is different, you will have to do
it like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;me = Person('John Snow')
print(me.get_name())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When you do this, your previous code will stop working, because now you
have to set the &lt;code&gt;name&lt;/code&gt; explicitly. If there is any other code that does
&lt;code&gt;Person()&lt;/code&gt;, it will fail. The proper way of altering the functioning of
a method is to add a default value in case no explicit value is passed.
The &lt;code&gt;__init__&lt;/code&gt; would become:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def __init__(self, name=''):
    self.stored_name = name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this modification, if you don't explicitly specify a name when
instantiating the class, it will default to &lt;code&gt;''&lt;/code&gt;, i.e., an empty string.&lt;/p&gt;
&lt;p&gt;Defining default values for parameters in methods has to be handled with
care. They are very useful when you expect people to always use the same
values and only occasionally to change them. Trying to keep backwards
compatibility by declaring default values can make your code look
chaotic, so you have to do it only when it is worth doing, and not all
the time. When developing, it is impossible not to refactor code.&lt;/p&gt;
&lt;h2&gt;Defining class attributes&lt;/h2&gt;
&lt;p&gt;So far, if you wanted to have properties available right after the
instantiation of a class, you had to include them in the &lt;code&gt;__init__&lt;/code&gt;
method. However, this is not the only possibility. You can define
attributes that belong to the class itself. Doing it is as simple as
declaring them before the &lt;code&gt;__init__&lt;/code&gt; method. For example, we could do
this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Person():
    birthday = '2010-10-10'
    def __init__(self, name=''):
        [...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you use the new &lt;code&gt;Person&lt;/code&gt; class, you will have an attribute called
&lt;code&gt;birthday&lt;/code&gt; available, but with some interesting behavior. First, let's
start as always:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; from person import Person
&amp;gt;&amp;gt;&amp;gt; guy = Person('John Snow')
&amp;gt;&amp;gt;&amp;gt; print(guy.birthday)
2010-10-10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What you see above is that it doesn't matter if you define the birthday
within the &lt;code&gt;__init__&lt;/code&gt; method or before, when you instantiate the class,
you access the property in the same way. The main difference is what
happens before instantiating the class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; from person import Person
&amp;gt;&amp;gt;&amp;gt; print(Person.birthday)
2010-10-10
&amp;gt;&amp;gt;&amp;gt; Person.birthday = '2011-11-11'
&amp;gt;&amp;gt;&amp;gt; new_guy = Person('Cersei Lannister')
&amp;gt;&amp;gt;&amp;gt; print(new_guy.birthday)
2011-11-11
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What you see in the code above is that you can access class attributes
before you instantiate anything. That is why they are class and not
object attributes. Subtleties apart, once you change the class
attribute, in the example above, the birthday, next time you create an
object with that class, it will receive the new property. At the
beginning it is hard to understand why it is useful, but one day you
will need it and it will save you a lot of time.&lt;/p&gt;
&lt;h2&gt;Inheritance&lt;/h2&gt;
&lt;p&gt;One of the advantages of working with classes in Python is that it
allows you to use the code from other developers and expand or change
its behavior without modifying the original code. The best idea is to
see it in action. So far we have a class called &lt;code&gt;Person&lt;/code&gt;, which is
general but not too useful. Let's assume we want to define a new class,
called &lt;code&gt;Teacher&lt;/code&gt;, that has the same properties as a &lt;code&gt;Person&lt;/code&gt; (i.e., name
and birthday) plus it is able to teach a class. You can add the
following code to the file &lt;strong&gt;person.py&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Teacher(Person):
    def __init__(self, course):
        self.course = course

    def get_course(self):
        return self.course

    def set_course(self, new_course):
        self.course = new_course
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that in the definition of the new &lt;code&gt;Teacher&lt;/code&gt; class, we have added
the &lt;code&gt;Person&lt;/code&gt; class. In Python jargon, this means that the class
&lt;code&gt;Teacher&lt;/code&gt; is a child of the class &lt;code&gt;Person&lt;/code&gt;, or the opposite, that
&lt;code&gt;Person&lt;/code&gt; is the parent of &lt;code&gt;Teacher&lt;/code&gt;. This is called &lt;strong&gt;inheritance&lt;/strong&gt; and
you will notice that a lot of different projects take advantage of it.
You can use the class &lt;code&gt;Teacher&lt;/code&gt; in the same way as you have used the
class &lt;code&gt;Person&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; from person import Teacher
&amp;gt;&amp;gt;&amp;gt; me = Teacher('math')
&amp;gt;&amp;gt;&amp;gt; print(me.get_course)
math
&amp;gt;&amp;gt;&amp;gt; print(me.birthday)
2010-10-10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, if you try to use the teacher's name it is going to fail:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; print(me.get_name())
[...]
AttributeError: 'Teacher' object has no attribute 'stored_name'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The reason behind this error is that &lt;code&gt;get_name&lt;/code&gt; returns &lt;code&gt;stored_name&lt;/code&gt; in
the class Person. However, the property &lt;code&gt;stored_name&lt;/code&gt; is created when
running the &lt;code&gt;__init__&lt;/code&gt; method of Person, which didn't happen. You could
have changed the code above slightly to make it work:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; from person import Teacher
&amp;gt;&amp;gt;&amp;gt; me = Teacher('math')
&amp;gt;&amp;gt;&amp;gt; me.store_name('J.J.R.T.')
&amp;gt;&amp;gt;&amp;gt; print(me.get_course)
math
&amp;gt;&amp;gt;&amp;gt; print(me.get_name())
J.J.R.T.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, there is also another approach to avoid the error. You could
simply run the &lt;code&gt;__init__&lt;/code&gt; method of the parent class (i.e. the base
class), you need to add the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Teacher(Person):
    def __init__(self, course):
        super().__init__()
        self.course = course
    [...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When you use &lt;code&gt;super()&lt;/code&gt;, you are going to have access directly to the
class from which you are inheriting. In the example above, you
explicitly called the &lt;code&gt;__init__&lt;/code&gt; method of the parent class. If you try
again to run the method &lt;code&gt;me.get_name()&lt;/code&gt;, you will see that no error
appears, but also that nothing is printed to screen. This is because you
triggered the &lt;code&gt;super().__init__()&lt;/code&gt; without any arguments and therefore
the name defaulted to the empty string. You could change the code like
this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Teacher(Person):
    def __init__(self, name, course):
        super().__init__(name)
        self.course = course
    [...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which you would use combining both examples above:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; from person import Teacher
&amp;gt;&amp;gt;&amp;gt; me = Teacher('John', 'math')
&amp;gt;&amp;gt;&amp;gt; print(me.get_name())
John
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is important to note that when importing the class, you only import
the one you want to use, you don't need to import the parent, that is
the responsibility of whoever developed the &lt;code&gt;Teacher&lt;/code&gt; class.&lt;/p&gt;
&lt;h2&gt;Finer details of classes&lt;/h2&gt;
&lt;p&gt;With what you have learned up to here, you can achieve a lot of things,
it is just a matter of thinking how to connect different methods when it
is useful to inherit. Without doubts, it will help you to understand the
code developed by others. There are, however, some details that are
worth mentioning, because you can improve how your classes look and
behave.&lt;/p&gt;
&lt;h3&gt;Printing objects&lt;/h3&gt;
&lt;p&gt;Let's see, for example, what happens if you print an object:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; from person import Person
&amp;gt;&amp;gt;&amp;gt; guy = Person('John Snow')
&amp;gt;&amp;gt;&amp;gt; print(guy)
&amp;lt;__main__.Student object at 0x7f0fcd52c7b8&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of printing &lt;code&gt;guy&lt;/code&gt; is quite ugly and is not particularly
useful. Fortunately, you can control what appears on the screen. You
have to update the &lt;code&gt;Person&lt;/code&gt; class. Add the following method to the end:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def __str__(self):
    return &amp;quot;Person class with name {}&amp;quot;.format(self.stored_name)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the code above, you will get the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; print(guy)
Person class with name John Snow
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can get very creative. It is also important to point out that the
method &lt;code&gt;__str__&lt;/code&gt; will be used also when you want to transform an object
into a string, for example like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; class_str = str(guy)
&amp;gt;&amp;gt;&amp;gt; print(class_str)
Person class with name John Snow
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which also works if you do this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; print('My class is {}.'.format(guy))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Something that is important to point out is that this method is
inherited. Therefore, if you, instead of printing a &lt;code&gt;Person&lt;/code&gt;, print a
&lt;code&gt;Student&lt;/code&gt;, you will see the same output, which may or may not be the
desired behavior.&lt;/p&gt;
&lt;h3&gt;Defining complex properties&lt;/h3&gt;
&lt;p&gt;When you are developing complex classes, sometimes you would like to
alter the behavior of assigning values to an attribute. For example you
would like to change the age of a person when you store the year of
birth:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; person.year_of_birth = 1980
&amp;gt;&amp;gt;&amp;gt; print(person.age)
38
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is a way of doing this in Python which can be easily implemented
even if you don't fully understand the syntax. Working again in the
class &lt;code&gt;Person&lt;/code&gt;, we can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Person():
    def __init__(self, name=None):
        self.stored_name = name
        self._year_of_birth = 0
        self.age = 0

    @property
    def year_of_birth(self):
        return self._year_of_birth

    @year_of_birth.setter
    def year_of_birth(self, year)
        self.age = 2018 - year
        self._year_of_birth = year
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which can be used like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; from people import Person
&amp;gt;&amp;gt;&amp;gt; me = Person('Me')
&amp;gt;&amp;gt;&amp;gt; me.age
0
&amp;gt;&amp;gt;&amp;gt; me.year_of_birth = 1980
&amp;gt;&amp;gt;&amp;gt; me.age
32
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What is happening is that Python gives you control over everything,
including what does the &lt;code&gt;=&lt;/code&gt; do when you assign a value to an attribute
of a class. The first time you create a &lt;code&gt;@property&lt;/code&gt;, you need to specify
a function that returns a value. In the case above, we are returning
&lt;code&gt;self._year_of_birth&lt;/code&gt;. Just doing that will allow you to use
&lt;code&gt;me.year_of_birth&lt;/code&gt; as an attribute, but it will fail if you try to
change its value. This is called a read-only property. If you are
working in the lab, it is useful to define methods as read-only
properties when you can't change the value. For example, a method for
reading the serial number of a device would be read-only.&lt;/p&gt;
&lt;p&gt;If you want to change the value of a property, you have to define a new
method. This method is going to be called a &lt;em&gt;setter&lt;/em&gt;. That is why you
can see the line &lt;code&gt;@year_of_birth.setter&lt;/code&gt;. The method takes an argument
that triggers two actions. On the one hand, it updates the age, on the
other it stores the year in an attribute. It takes a while to get used
to, but it can be very handy.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;This article is a very short primer on how to start working with classes
in Python. You are not supposed to be an expert after such a brief
walk-through, but it should be enough for getting you started with your
own developments, and, more importantly, to be able to read other
developers code and understand what they are doing.&lt;/p&gt;
&lt;p&gt;The series of primer articles are thought as a go-to destination when
you need to refresh a specific concept. If you find anything missing,
you can always leave a comment below and we will expand the article
according to your needs. You can find the text of this article on
&lt;a href="https://github.com/PFTL/website/blob/master/content/blog/08_intro_to_classes.rst.md"&gt;Github&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Header photo by &lt;a href="https://unsplash.com/photos/ZqqlOZyGG7g?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText"&gt;Daniel
Cheung&lt;/a&gt;
on Unsplash&lt;/p&gt;</content><category term="blog"></category><category term="Classes"></category><category term="Object oriented"></category><category term="beginner"></category></entry><entry><title>How to use decorators Part 2</title><link href="https://www.pythonforthelab.com/blog/how-to-use-decorators-part-2" rel="alternate"></link><published>2018-05-18T00:00:00+02:00</published><updated>2018-05-18T00:00:00+02:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2018-05-18:/blog/how-to-use-decorators-part-2</id><summary type="html">&lt;p&gt;Decorators are a very useful programming pattern that allows changing
the behavior of functions with little refactoring. Decorators allow
developers to abstract common options from functions, but mastering
their use in Python can be challenging. In this article, we are going to
go in depth regarding different options when implementing …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Decorators are a very useful programming pattern that allows changing
the behavior of functions with little refactoring. Decorators allow
developers to abstract common options from functions, but mastering
their use in Python can be challenging. In this article, we are going to
go in depth regarding different options when implementing decorators.
The topics covered are:&lt;/p&gt;
&lt;p&gt;In a &lt;a href="https://www.pythonforthelab.com/blog/how-to-use-decorators-to-validate-input"&gt;previous article on the use of decorators to validate user
input&lt;/a&gt;, we have seen just
the very beginning of what decorators are able to provide to the
developer. Let's first recap what we saw earlier. We can define a
decorator as a function that will take as input another function. We can
use it to check the input of the latter, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def check_positive(func):
    def func_wrapper(x, y):
        if x&amp;lt;0 or y&amp;lt;0:
            raise Exception(&amp;quot;Both x and y have to be positive \
            for function {} to work&amp;quot;.format(func.__name__))
        res = func(x,y)
        return res
    return func_wrapper
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function &lt;code&gt;check_positive&lt;/code&gt; checks that the inputs of a function are
all positive before actually calling the function. To use it, we would
do something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;@check_positive
def average(x, y):
    return (x + y)/2

a = average(1,2)
print(a)
b = average(1, -1)
print(b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the first case, the function would work, giving as output &lt;code&gt;1.5&lt;/code&gt;,
while in the second case it would raise an exception because one of the
arguments is not positive. If you can't understand the code above, you
should check the &lt;a href="https://www.pythonforthelab.com/blog/how-to-use-decorators-to-validate-input"&gt;first article published on
decorators&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Docstrings with decorators&lt;/h2&gt;
&lt;p&gt;This example works fine, but it already shows an issue that for larger
projects is very relevant: docstrings, i.e. the documentation of
functions, methods, and classes, stop working when using decorators like
above. Let's add documentation to the function &lt;code&gt;average&lt;/code&gt;, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def average(x, y):
    &amp;quot;&amp;quot;&amp;quot;Calculates the average between two numbers.&amp;quot;&amp;quot;&amp;quot;
    return (x + y)/2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The string right after the definition of the function and starting with
the triple quotes &lt;code&gt;"""&lt;/code&gt; is used for building the documentation of
projects and is also used with the &lt;code&gt;help&lt;/code&gt; command:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; help(average)
average(x, y)
    Calculates the average between two numbers.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is very useful when working with libraries developed by others. It
also allows you to build documentation, such as the one you find for
&lt;a href="https://docs.scipy.org/doc/numpy-1.14.2/user/quickstart.html"&gt;numpy&lt;/a&gt;,
but we will cover this in a later tutorial. However, if we use a
decorator, the behavior changes:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;@check_positive
def average(x, y):
    [...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;[...]&lt;/code&gt; means that there is code being suppressed for brevity. If
again we try to get the help of our function:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; help(average)
func_wrapper(x, y)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, the docstring of the function &lt;code&gt;average&lt;/code&gt; was replaced by
the docstring of the wrapper, which in the example above is empty. What
we can do to avoid this problem is to pass the docstring and the name of
the function to the name and docstring of the decorator. Like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def check_positive(func):
    def func_wrapper(x, y):
        if x &amp;lt; 0 or y &amp;lt; 0:
            raise Exception(&amp;quot;Both x and y have to be positive for function {} to work&amp;quot;.format(func.__name__))
        res = func(x, y)
        return res
    func_wrapper.__name__ = func.__name__
    func_wrapper.__doc__ = func.__doc__
    return func_wrapper
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And if we repeat the steps above, we see that the help command is giving
the expected output. We can also add a docstring to the decorator:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def check_positive(func):
    &amp;quot;&amp;quot;&amp;quot;Decorator to check that the inputs of a function are positive&amp;quot;&amp;quot;&amp;quot;
    [...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As with many things in Python, this is not the only option but is the
one that allows you to see how some of the internals work, such as the
&lt;code&gt;__name__&lt;/code&gt; and &lt;code&gt;__doc__&lt;/code&gt; properties. Another option is to use a built-in
decorator from Python that would allow you to do exactly what we have
done but in one single line:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from functools import wraps

def check_positive(func):
    @wraps(func)
    def func_wrapper(x, y):
        if x &amp;lt; 0 or y &amp;lt; 0:
            raise Exception(&amp;quot;Both x and y have to be positive for function {} to work&amp;quot;.format(func.__name__))
        res = func(x, y)
        return res
    return func_wrapper
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The highlighted lines are the ones that changed compared to the previous
example. Again, the &lt;code&gt;help&lt;/code&gt; command is working as expected. In principle
what the decorator &lt;code&gt;@wraps&lt;/code&gt; does is the same as setting the &lt;code&gt;__name__&lt;/code&gt;
and &lt;code&gt;__doc__&lt;/code&gt; properties. Now you start seeing that the uses of
decorators are virtually endless.&lt;/p&gt;
&lt;h2&gt;Arguments in decorators&lt;/h2&gt;
&lt;p&gt;Imagine that you want to be able to check that both arguments in a
function are higher than a parameter, not necessarily &lt;code&gt;0&lt;/code&gt;. This would
imply that the decorator takes one argument. Let's see first what do we
want to achieve and then how to do it.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;@check_above(2)
def average(x, y):
    return (x + y)/2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We expect the function &lt;code&gt;average&lt;/code&gt; to work only if both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are
larger than 2. This is very useful when you are communicating with a
device, for example, and you want to be sure that you are passing values
which are allowed. However, the decorator that we defined earlier takes
as an argument only the function to be decorated and it will fail if we
add anything else. Solving this is a bit more involved because it
requires a function that returns a decorator. We can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def check_above(threshold):
    def wrap(func):
        @wraps(func)
        def func_wrapper(x, y):
            if x &amp;lt; threshold or y &amp;lt; threshold:
                raise Exception(&amp;quot;Both x and y have to be larger than {} \
                for function {} to work&amp;quot;.format(threshold, func.__name__))
            res = func(x, y)
            return res
        return func_wrapper
    return wrap
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let's see step by step what is going on. The function &lt;code&gt;check_above&lt;/code&gt;
returns the decorator called &lt;code&gt;wrap&lt;/code&gt;. Therefore, technically, the
function will be decorated with &lt;code&gt;wrap&lt;/code&gt; and not with &lt;code&gt;check_above&lt;/code&gt;, but
now we can use the parameter &lt;code&gt;threshold&lt;/code&gt;. We have translated everything
one layer deeper, but the behavior is essentially the same. Note that
now you check that both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are above the &lt;code&gt;threshold&lt;/code&gt;. If you
try to calculate the average like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;average(1, 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;it will raise the exception because one of the values is not above the
specified threshold.&lt;/p&gt;
&lt;h2&gt;When are decorators executed&lt;/h2&gt;
&lt;p&gt;There is something very important to note: both decorators defined
earlier, &lt;code&gt;check_positive&lt;/code&gt; and &lt;code&gt;check_above&lt;/code&gt; are actually executed right
when defining the &lt;code&gt;average&lt;/code&gt; function. You can test it by adding a
&lt;code&gt;print&lt;/code&gt; statement, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def check_positive(func):
    print('Checking if it is positive')
    @wraps(func)
    def func_wrapper(x, y):
        if x &amp;lt; 0 or y &amp;lt; 0:
            raise Exception(&amp;quot;Both x and y have to be positive \
            for function {} to work&amp;quot;.format(func.__name__))
        res = func(x, y)
        return res

    return func_wrapper
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Whenever you import the module that contains the &lt;code&gt;average&lt;/code&gt; function, you
will see:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; from utils import average
Checking if it is positive
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This behavior may not be completely expected nor desired. For example,
imagine that you use a decorator that checks the status of a device
before allowing the user to send a new command to it. If you place the
verification routine outside of the function wrapper, it will be
triggered when you import the function and not when you execute it. This
can give rise to a lot of undesired errors because it is understandable
that a user is importing the needed functions first and then starting
the communication with a device.&lt;/p&gt;
&lt;p&gt;On the other hand, being able to run code before the function is
executed, opens different doors. For example, you could register all the
available functions. Check the following example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# utils.py
from functools import wraps

func_registry = []

def register(func):
    func_registry.append(func.__name__)
    @wraps(func)
    def func_wrapper(*args):
        return func(*args)
    return func_wrapper

@register
def average(x, y):
    return (x + y)/2

@register
def geom_average(x, y):
    return (x*y)**0.5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you can use it in the following way:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; from utils import average
&amp;gt;&amp;gt;&amp;gt; average(1, 2)
1.5
&amp;gt;&amp;gt;&amp;gt; from utils import func_registry
&amp;gt;&amp;gt;&amp;gt; for f in func_registry:
...     print(f)
...
average
geom_average
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this simple code, you already see that not only &lt;code&gt;average&lt;/code&gt;, but also
&lt;code&gt;geom_average&lt;/code&gt; is decorated with &lt;code&gt;@register&lt;/code&gt;. This is very useful if,
for example, you want to have a list of a specific set of functions.
Imagine that you are developing a driver for a device, and some of the
methods are equivalent to buttons, i.e., you trigger an action by
pressing it, but no input is required and no output is generated.
&lt;em&gt;Switch on&lt;/em&gt;, &lt;em&gt;Switch off&lt;/em&gt;, &lt;em&gt;Auto calibrate&lt;/em&gt;, etc. It would be handy to
have a list of all these methods, in order to display them to an
end-user, for example.&lt;/p&gt;
&lt;p&gt;When you start designing decorators, especially if you are planning to
have other developers to use them, you have to be aware that some
behaviors are not always obvious to everybody. Documenting is crucial to
have reliable and maintainable libraries. Mixing the execution of code
with the definition of a function may give a lot of headaches to novice
developers and may become a nightmare to debug later on.&lt;/p&gt;
&lt;h2&gt;Decorators for methods in classes&lt;/h2&gt;
&lt;p&gt;So far we have covered how to use decorators for functions, but more
often than not you will find yourself using decorators for methods in
classes. For example, you would like to use the &lt;code&gt;check_positive&lt;/code&gt; like
this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# operations.py
class Operations:
    @check_positive
    def average(self, x, y):
        return (x + y)/2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I know that a class like that makes no sense at all, but it is only an
example, so please bear with me. If you want to use this class, you will
face an error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; from operations import Operations
[...]
TypeError: func_wrapper() takes 2 positional arguments but 3 were given
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we defined the &lt;code&gt;check_positive&lt;/code&gt; decorator, we explicitly used two
arguments for the &lt;code&gt;func_wrapper&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. However, when we work
with methods, there will be one more argument, the &lt;code&gt;self&lt;/code&gt;. There are
different ways of solving this problem. On one hand, you could adapt the
decorator in order to accommodate for the extra input, but then the
decorator will stop working with normal functions. Of course, you could
define a new decorator just for methods, but you would end up
duplicating the code, and you should try to avoid that.&lt;/p&gt;
&lt;p&gt;One more general solution would be to use a variable number of arguments
for the decorator. This would be the idea:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from functools import wraps

def check_positive(func):
    @wraps(func)
    def func_wrapper(*args):
        for arg in args:
            if type(arg) is int or type(arg) is float:
                if arg &amp;lt; 0:
                    raise Exception(&amp;quot;Method {} takes only positive arguments&amp;quot;.format(func.__name__))
        return func(*args)

    return func_wrapper
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you can see that the decorator became more complex than before.
First, the &lt;code&gt;func_wrapper&lt;/code&gt; takes &lt;code&gt;*args&lt;/code&gt; as the argument, and no longer
explicitly &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. The &lt;code&gt;*args&lt;/code&gt; parameter is a good subject for a
next tutorial, what you should understand by now is that it makes a list
out of all the inputs of the function, regardless of how many they are.
This is what allows us to iterate through them by doing
&lt;code&gt;for arg in args&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For every argument in the function, we have to check whether they are
numbers or not, i.e., if the &lt;code&gt;type&lt;/code&gt; is either &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt;. This
prevents us from checking if &lt;code&gt;self&lt;/code&gt; is positive or not, which would
raise an exception. If the checks pass, we just return the original
function &lt;code&gt;func&lt;/code&gt; with the same arguments &lt;code&gt;*args&lt;/code&gt; which were originally
used. You can go ahead and try this decorator with either a method ìn
the &lt;code&gt;Operations&lt;/code&gt; class or with a function. Moreover, you can now try it
with a function that takes three numbers as input and it will still
work.&lt;/p&gt;
&lt;h2&gt;Classes as decorators&lt;/h2&gt;
&lt;p&gt;So far, we have seen that you can use a function to decorate another
function or method. However, that is not the only option. Classes can be
used as decorators as well, and this opens an entire realm of
possibilities. What we have seen so far is that when you add a callable
with a &lt;code&gt;@&lt;/code&gt; just before another callable (i.e. a method or a function in
our context), that function will be passed as an argument to the
decorator. When constructing classes, you can also pass functions as
arguments. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Decorator:
    def __init__(self, func):
        print('Decorating {}'.format(func.__name__))
        self.func = func

@Decorator
def average(x, y):
    return (x + y)/2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you execute the code above you will see:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;Decorating average
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, if you try to use the average, you will see an error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; average(1, 2)
[...]
TypeError: 'Decorator' object is not callable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is actually expected. What is happening is that the function
&lt;code&gt;average&lt;/code&gt; is actually being turned into a &lt;code&gt;Decorator&lt;/code&gt; class. The code
would be equivalent to doing something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;average = Decorator(average)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, after the class has been instantiated, Python doesn't know what
does it mean to execute it. We need to explicitly add this behavior:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Decorator:
    def __init__(self, func):
        print('Decorating {}'.format(func.__name__))
        self.func = func

    def __call__(self, *args, **kwargs):
        return self.func(*args)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this change, we have instructed Python what does it means to &lt;em&gt;call&lt;/em&gt;
the object, i.e., to do &lt;code&gt;average(...)&lt;/code&gt;. If we run it again, it will
work:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; averge(1, 2)
1.5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Remember that, just as before, the instantiation of the &lt;code&gt;Decorator&lt;/code&gt;
class is happening when defining the &lt;code&gt;average&lt;/code&gt;, and therefore you will
see the line &lt;code&gt;Decorating average&lt;/code&gt; when you &lt;code&gt;import average&lt;/code&gt;. On the
other hand, you have transformed your function into a class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; type(average)
&amp;lt;class '__main__.Decorator'&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;How you can leverage the possibilities of using a class instead of a
function for decorating depends on the work you are trying to achieve.
Remember that the main use of classes is when you need to preserve
state. For example, imagine you would like to store every pair of values
on which you have calculated the average. You can easily turn this idea
into a cache system, avoiding to repeat processes for known arguments.&lt;/p&gt;
&lt;h2&gt;Decorators for classes&lt;/h2&gt;
&lt;p&gt;We have seen that any callable can be a decorator of any other callable.
That is why a function can be a decorator of another function or method.
Also, because a class is a callable, it can be a decorator of a function
or method. The last missing combination is to decorate classes. With
what you know so far, you can already anticipate what is going to
happen. Imagine you want to do this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;@Decorate
class MyClass:
    def __init__(self):
        print('My Class')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What you have to remember is that &lt;code&gt;Decorate&lt;/code&gt; needs to accept &lt;code&gt;MyClass&lt;/code&gt;
as input. Moreover, we need to actually instantiate the class when we
do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;my_class = MyClass()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Putting all the ideas together, the decorator will look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def Decorate(cls):
    print('Decorating {}'.format(cls.__name__))
    def class_wrapper(*args):
        return cls(*args)
    return class_wrapper
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What will happen is that the class will be passed as the argument of
&lt;code&gt;Decorate&lt;/code&gt;. We will print that we are decorating the class, just to show
that it is actually working. The &lt;code&gt;Decorate&lt;/code&gt; function needs to return
another callable object, in the example above is a function called
&lt;code&gt;class_wrapper&lt;/code&gt;. This function will be responsible for instantiating the
class. Remember that when you use decorators, you are actually replacing
what happens when you do &lt;code&gt;MyClass()&lt;/code&gt; by what happens when you do
&lt;code&gt;class_wrapper()&lt;/code&gt;. Therefore, if you decorate the class, you will see
that its type changed:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; type(MyClass)
&amp;lt;class 'function'&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The main point here is that the function will return an object. This
allows you to instantiate the class as always, regardless of it having
or not the decorator:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; my_class = MyClass()
My Class
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Decorating classes is a bit of a corner situation. To be honest, I don't
imagine a lot of scenarios where you would like to decorate a class, but
still, I will give you an example. Imagine that you want to add a new
method to every decorated class. A method that will calculate the
average between two numbers. What you have to do is to alter the &lt;code&gt;cls&lt;/code&gt;
variable within the &lt;code&gt;class_wrapper&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def Decorate(cls):
    def class_wrapper(*args):
        def average(cls, x, y):
            return (x + y) / 2
        setattr(cls, 'average', average)
        return cls(*args)
return class_wrapper
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have defined the function &lt;code&gt;average&lt;/code&gt; that takes three arguments: a
class and two numbers. And then we use &lt;code&gt;setattr&lt;/code&gt; to add the method to
&lt;code&gt;cls&lt;/code&gt; and we call it &lt;code&gt;'average'&lt;/code&gt;. Now, &lt;code&gt;MyClass&lt;/code&gt; will be able to
calculate the average of numbers even if the method was not defined in
it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; my_class = MyClass()
&amp;gt;&amp;gt;&amp;gt; res = my_class.average(1, 2)
&amp;gt;&amp;gt;&amp;gt; print(res)
1.5
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;In this tutorial, we have covered a lot of different options when
working with decorators. Depending on the kind of projects you are
working on, you may not find yourself in the situation of needing to
develop decorators, however, it is always useful to be aware of one
extra possibility. Decorators are very useful tools when a library is
going to be used by other developers.&lt;/p&gt;
&lt;p&gt;Two libraries that make heavy use of decorators are
&lt;a href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt; and
&lt;a href="https://github.com/lantzproject/"&gt;Lantz&lt;/a&gt;. Therefore, even if you don't
develop your own decorators, it is always important to understand how
they work.&lt;/p&gt;
&lt;p&gt;You can find the &lt;a href="https://github.com/PFTL/website/tree/master/example_code/04_how_to_use_decorators_2"&gt;example code for this
tutorial&lt;/a&gt;
on Github, as well as the
&lt;a href="https://github.com/PFTL/website/blob/master/content/blog/04_how_to_use_decorators_2.rst.md"&gt;text&lt;/a&gt;.
If you find any mistakes, don't hesitate to submit a pull request or
open an Issue.&lt;/p&gt;
&lt;p&gt;Header photo by &lt;a href="https://unsplash.com/photos/tOZ-f5kl9BA?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText"&gt;Michael
Browning&lt;/a&gt;
on Unsplash&lt;/p&gt;</content><category term="blog"></category><category term="Decorators"></category><category term="Tricks"></category><category term="Validation"></category><category term="Data"></category><category term="Intermediate"></category></entry><entry><title>How to use HDF5 files in Python</title><link href="https://www.pythonforthelab.com/blog/how-to-use-hdf5-files-in-python" rel="alternate"></link><published>2018-03-19T00:00:00+01:00</published><updated>2018-03-19T00:00:00+01:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2018-03-19:/blog/how-to-use-hdf5-files-in-python</id><summary type="html">&lt;p&gt;When dealing with large amounts of data, either experimental or simulated, saving it to several text files is not very efficient. Sometimes you need to access a specific subset of the dataset, and you don't want to load it all to memory. If you are looking for a solution that …&lt;/p&gt;</summary><content type="html">&lt;p&gt;When dealing with large amounts of data, either experimental or simulated, saving it to several text files is not very efficient. Sometimes you need to access a specific subset of the dataset, and you don't want to load it all to memory. If you are looking for a solution that integrates nicely with numpy and pandas, then the HDF5 format may be the solution you were seeking. &lt;/p&gt;
&lt;p&gt;Each HDF5 file has an internal structure that allows you to search for a specific dataset. You can think of it as a single file with its hierarchical structure, just like a collection of folders and subfolders. By default, the data is stored in binary format, and the library is compatible with different data types. One essential option of the HDF5 format is that it allows attaching metadata to every element in the structure, making it ideal for generating self-explanatory files.&lt;/p&gt;
&lt;p&gt;In Python, there are two libraries that can interface with the HDF5 format: &lt;a href="https://www.pytables.org/index.html"&gt;PyTables&lt;/a&gt; and &lt;a href="https://h5py.readthedocs.io/en/stable/index.html"&gt;h5py&lt;/a&gt;. The first one is the one employed by Pandas under-the-hood, while the second is the one that maps the features of the HDF5 specification to numpy arrays. While PyTables can be thought of as implementing database-like features on top of the HDF5 specification, &lt;strong&gt;h5py&lt;/strong&gt; is the natural choice when dealing with N-dimensional numpy arrays (not just tables). Some of the features are the same with both libraries, but we will focus on &lt;strong&gt;h5py&lt;/strong&gt;. &lt;/p&gt;
&lt;p&gt;One of the most exciting features of the HDF5 format is that data is read from the hard drive only when it is needed. Imagine you have a large array that doesn't fit in the available RAM. A clear example would be a movie, which is a series of 2D arrays. Maybe you would like to look only at a smaller region and not the full-frame. Instead of loading each frame to memory, you could directly access the required data. H5py allows you to work with data on the hard drive just as you would with an array. &lt;/p&gt;
&lt;p&gt;In this article, we will see how you can use &lt;strong&gt;h5py&lt;/strong&gt; to store and retrieve data from files. We will discuss different ways of storing and organizing data and how to optimize the reading process. All the examples that appear in this article are also &lt;a href="https://github.com/PFTL/website_example_code/tree/master/code/02_HDF5"&gt;available on our Github repository&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Installing&lt;/h2&gt;
&lt;p&gt;The HDF5 format is supported by the &lt;a href="https://www.hdfgroup.org/"&gt;HDF Group&lt;/a&gt;, and it is based on open source standards, meaning that your data will always be accessible, even if the group disappears. We can install the &lt;a href="https://www.h5py.org/"&gt;h5py package&lt;/a&gt; through &lt;code&gt;pip&lt;/code&gt;. Remember that you should be using a &lt;a href="https://www.pythonforthelab.com/blog/virtual-environment-is-a-must-have-tool"&gt;virtual environment&lt;/a&gt; to perform tests:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;pip install h5py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;the command will also install numpy, in case you don't have it already in your environment. &lt;/p&gt;
&lt;p&gt;You can also install h5py with &lt;strong&gt;anaconda&lt;/strong&gt;, which has the added benefit of a finer control on the underlying HDF5 library used:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;conda install h5py
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;HDF5 Viewer&lt;/h3&gt;
&lt;p&gt;When working with HDF5 files, it is handy to have a tool that allows you to explore the data graphically. The HDF5 group provides a tool called &lt;a href="https://support.hdfgroup.org/products/java/hdfview/"&gt;HDF5 Viewer&lt;/a&gt;. It is written in Java so it should work on almost any computer. It is relatively basic, but you can see the structures of the files very quickly. &lt;/p&gt;
&lt;h2&gt;Basic Saving and Reading Data&lt;/h2&gt;
&lt;p&gt;The best way to get started is to dive into the use of the HDF5 library. Let's create a new file and save a numpy random array to it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import h5py
import numpy as np

arr = np.random.randn(1000)

with h5py.File('random.hdf5', 'w') as f:
    dset = f.create_dataset(&amp;quot;default&amp;quot;, data=arr)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We import the packages h5py and numpy and create an array with random values. We open a file called &lt;code&gt;random.hdf5&lt;/code&gt; with write permission, &lt;code&gt;w&lt;/code&gt; which means that if there is already a file with the same name, it will be overwritten. If you would like to preserve the file and still write to it, you can open it with the &lt;code&gt;a&lt;/code&gt; attribute instead of &lt;code&gt;w&lt;/code&gt;. We create a dataset called &lt;code&gt;default&lt;/code&gt;, and we set the data as the random array created earlier. Datasets are holders of our data, basically the building blocks of the HDF5 format.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;If you are not familiar with the &lt;code&gt;with&lt;/code&gt; statement, you can check out &lt;a href="https://www.pythonforthelab.com/blog/the-with-command-and-custom-classes"&gt;this tutorial&lt;/a&gt;. In a nutshell, it is a convenient way of opening and closing a file. Even if there is an error within the &lt;code&gt;with&lt;/code&gt;, the file will be closed. If, for some reason, you don't use the &lt;code&gt;with&lt;/code&gt;, never forget to add the command &lt;code&gt;f.close()&lt;/code&gt; at the end. &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;To read the data back, we can do it in a very similar way to when we read a numpy file:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with h5py.File('random.hdf5', 'r') as f:
   data = f['default']
   print(min(data))
   print(max(data))
   print(data[:15])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We open the file with a read attribute, &lt;code&gt;r&lt;/code&gt; and we recover the data by directly addressing the dataset called default. Note that we are using &lt;code&gt;data&lt;/code&gt; as a regular numpy array. Later, we will see that data is pointing to the HDF5 file but is not loaded to memory as a numpy array would. &lt;/p&gt;
&lt;p&gt;Something ubiquitous with HDF5 files is that you don't know how data is structured, what &lt;code&gt;datasets&lt;/code&gt; are available, and how they are called. You can retrieve the datasets in a file:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;for key in f.keys():
   print(key)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the example above, you can see that the HDF5 file behaves similarly to a dictionary, in which each key is a dataset. We have only one dataset called &lt;code&gt;default&lt;/code&gt;, and we can access it by calling &lt;code&gt;f['default']&lt;/code&gt;. These simple examples, however, hyde many things under the hood. We need to discuss further to understand the full potential of HDF5.&lt;/p&gt;
&lt;p&gt;In the example above, you can use &lt;code&gt;data&lt;/code&gt; as an array. For example, you can address the third element by typing &lt;code&gt;data[2]&lt;/code&gt;, or you could get a range of values with &lt;code&gt;data[1:3]&lt;/code&gt;. Note, however, that &lt;code&gt;data&lt;/code&gt; is not an array but a dataset. You can see it by typing &lt;code&gt;print(type(data))&lt;/code&gt;. Datasets work in a completely different way than arrays because their information is stored on the hard drive, and they don't load it to RAM if we don't use them. The following code, for example, will not work:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;f = h5py.File('random.hdf5', 'r')
data = f['default']
f.close()
print(data[1])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The error that appears is a bit lengthy, but the last line is helpful:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-shell"&gt;[...]
ValueError: Not a dataset (not a dataset)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The error means that we are trying to access a dataset, but we no longer have access to it. When we start with HDF5 files, it may seem confusing, but once we understand what is going on, everything makes sense. When we assign &lt;code&gt;f['default']&lt;/code&gt; to the variable &lt;code&gt;data&lt;/code&gt;. We are not reading the data from the file. Instead, we are generating a pointer to where the data is located on the hard drive. On the other hand, this code will work:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;f = h5py.File('random.hdf5', 'r')
data = f['default'][()]
f.close()
print(data[10])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you pay attention, the only difference is that we added &lt;code&gt;[()]&lt;/code&gt; after reading the dataset. Many other guides stop at these sorts of examples without ever showing the full potential of the HDF5 format with the h5py package. The problem is that they don't show the true potential of the format. &lt;/p&gt;
&lt;h2&gt;Selective Reading from HDF5 files&lt;/h2&gt;
&lt;p&gt;So far, we have seen that we are not yet reading data from the disk when we read a dataset. Instead, we are creating a link to a specific
location on the hard drive. We can see what happens if, for example, we
explicitly read the first ten elements of a dataset:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with h5py.File('random.hdf5', 'r') as f:
   data_set = f['default']
   data = data_set[:10]

print(data[1])
print(data_set[1])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We are splitting the code into different lines to make it more explicit,
but you can be more synthetic in your projects. In the lines above, we
first read the file, and we then read the default dataset. We assign the
first ten elements of the dataset to a variable called &lt;code&gt;data&lt;/code&gt;. After the
file closes (when the &lt;code&gt;with&lt;/code&gt; finishes), we can access the values stored
in &lt;code&gt;data&lt;/code&gt;, but &lt;code&gt;data_set&lt;/code&gt; will give an error. Note that we are only
reading from the disk when we explicitly access the first ten elements of
the data set. If you print the type of &lt;code&gt;data&lt;/code&gt; and of &lt;code&gt;data_set&lt;/code&gt;, you will
see that they are actually different. The first is a &lt;strong&gt;numpy array&lt;/strong&gt;
while the second is an &lt;strong&gt;h5py DataSet&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The same behavior works in more complex scenarios. Let's create a new
file, this time with two data sets, and let's select the elements of one
based on the elements of the other. Let's start by creating a new file
and storing data; that part is the easiest one:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import h5py
import numpy as np

arr1 = np.random.randn(10000)
arr2 = np.random.randn(10000)

with h5py.File('complex_read.hdf5', 'w') as f:
    f.create_dataset('array_1', data=arr1)
    f.create_dataset('array_2', data=arr2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have two datasets called &lt;code&gt;array_1&lt;/code&gt; and &lt;code&gt;array_2&lt;/code&gt;; each has a random
numpy array stored in it. We want to read the values of &lt;code&gt;array_2&lt;/code&gt; that
correspond to the elements where the values of &lt;code&gt;array_1&lt;/code&gt; are positive.
We can try to do something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with h5py.File('complex_read.hdf5', 'r') as f:
    d1 = f['array_1']
    d2 = f['array_2']

    data = d2[d1&amp;gt;0]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But it will not work. &lt;code&gt;d1&lt;/code&gt; is a dataset and can't be compared to an
integer. The only way is to actually read the data from the disk and
then compare it. Therefore, we will end up with something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with h5py.File('complex_read.hdf5', 'r') as f:
    d1 = f['array_1']
    d2 = f['array_2']

    data = d2[d1[()]&amp;gt;0]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first dataset, &lt;code&gt;d1&lt;/code&gt; is completely loaded into memory when we do
&lt;code&gt;d1[()]&lt;/code&gt;, but we grab only some elements from the second dataset, &lt;code&gt;d2&lt;/code&gt;. If the &lt;code&gt;d1&lt;/code&gt; dataset had been too large to be loaded into memory all at once, we could have worked inside a loop.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with h5py.File('complex_read.hdf5', 'r') as f:
    d1 = f['array_1']
    d2 = f['array_2']

    data = []

    for i in range(len(d1)):
        if d1[i] &amp;gt; 0:
            data.append(d2[i])

print('The length of data with a for loop: {}'.format(len(data)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course, there are efficiency concerns regarding reading an array
element by element and appending it to a list, but it is a very good
example of one of the greatest advantages of using HDF5 over text or
numpy files. Within the loop, we are loading into memory only one
element. In our example, each element is just a number, but it could
have been anything, from a text to an image or a video.&lt;/p&gt;
&lt;p&gt;As always, depending on your application, you will have to decide if you
want to read the entire array into memory or not. Sometimes you run
simulations on a specific computer with loads of memory, but you don't
have the same specifications in your laptop, and you are forced to read
chunks of your data. Remember that reading from a hard drive is
relatively slow, especially if you are using HDD instead of SDD disks or
even more if you are reading from a network drive.&lt;/p&gt;
&lt;h2&gt;Selective Writing to HDF5 Files&lt;/h2&gt;
&lt;p&gt;In the examples above, we have appended data to a data set as soon as
this was created. For many applications, however, you need to save data
while it is being generated. HDF5 allows you to save data in a very
similar way to how you read it back. Let's see how to create an empty
dataset and add some data to it.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;arr = np.random.randn(100)

with h5py.File('random.hdf5', 'w') as f:
   dset = f.create_dataset(&amp;quot;default&amp;quot;, (1000,))
   dset[10:20] = arr[50:60]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first couple of lines are the same as before, with the exception of
&lt;code&gt;create_dataset&lt;/code&gt;. We don't append data when creating it. We just create an empty dataset able to hold up to 1000 elements. With the same logic as before, when we read specific elements from the dataset, we are
actually writing to disk only when we assign values to specific elements
of the &lt;code&gt;dset&lt;/code&gt; variable. In the example above, we are assigning values
just to a subset of the array, the indexes 10 to 19.&lt;/p&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;It is not entirely true that you write to disk when you assign values to a dataset. The precise moment depends on several factors, including the state of the operating system. If the program closes too early, it may happen that not everything was written. It is very important to always use the &lt;code&gt;close()&lt;/code&gt; method, and in case you write in stages, you can also use &lt;code&gt;flush()&lt;/code&gt; in order to force the writing. Using &lt;code&gt;with&lt;/code&gt; prevents a lot of writing issues.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;If you read the file back and print the first 20 values of the dataset, you will see that they are all zeros except for the indexes 10 to 19. There is a &lt;strong&gt;common mistake&lt;/strong&gt; that can give you a lot of headaches. The following code will not save anything to disk:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;arr = np.random.randn(1000)

with h5py.File('random.hdf5', 'w') as f:
   dset = f.create_dataset(&amp;quot;default&amp;quot;, (1000,))
   dset = arr
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This mistake always gives a lot of issues, because you won't realize
that you are not saving anything until you try to read it back. The
problem here is that you are not specifying where you want to store the
data; you are just overwriting the &lt;code&gt;dset&lt;/code&gt; variable with a numpy array.
Since both the dataset and the array have the same length, you should
have used &lt;code&gt;dset[:] = arr&lt;/code&gt;. This mistake happens more often than you
think, and since it is technically not wrong, you won't see any errors
printed to the terminal, but your data will be just zeros.&lt;/p&gt;
&lt;p&gt;So far we have always worked with 1-dimensional arrays, but we are not
limited to them. For example, let's assume we want to use a 2D array, we
can simply do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;dset = f.create_dataset('default', (500, 1024))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which will allow us to store data in a 500x1024 array. To use the
dataset, we can use the same syntax as before, but taking into account
the second dimension:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;dset[1,2] = 1
dset[200:500, 500:1024] = 123
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Specify Data Types to Optimize Space&lt;/h2&gt;
&lt;p&gt;So far, we have covered only the tip of the iceberg of what HDF5 has to
offer. Besides the length of the data you want to store, you may want to
specify the type of data to optimize the space. The &lt;a href="http://docs.h5py.org/en/latest/faq.html"&gt;h5py
documentation&lt;/a&gt; provides a list
of all the supported types, here we are going to show just a couple of
them. We are going to work with several datasets in the same file at the
same time.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with h5py.File('several_datasets.hdf5', 'w') as f:
   dset_int_1 = f.create_dataset('integers', (10, ), dtype='i1')
   dset_int_8 = f.create_dataset('integers8', (10, ), dtype='i8')
   dset_complex = f.create_dataset('complex', (10, ), dtype='c16')

   dset_int_1[0] = 1200
   dset_int_8[0] = 1200.1
   dset_complex[0] = 3 + 4j
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the example above, we have created three different datasets, each
with a different type. Integers of 1 byte, integers of 8 bytes, and
complex numbers of 16 bytes. We are storing only one number, even if our
datasets can hold up to 10 elements. You can read the values back and
see what was actually stored. The two things to note here are that the
integer of 1 byte should have been rounded to 127 (instead of 1200), and
the integer of 8 bytes should have been rounded to 1200 (instead of
1200.1).&lt;/p&gt;
&lt;p&gt;If you have ever programmed in languages such as C or Fortran, you
probably are aware of what different data types mean. However, if you
have always worked with Python, perhaps you haven't faced any issues by not declaring explicitly the type of data you are working with. The
important thing to remember is that the number of bytes tells you how
many different numbers you can store. If you use 1 byte, you have 8 bits, and therefore you can store 2&lt;strong&gt;8 different numbers. In the example
above, integers are both positive, negative, and 0. When you use
integers of 1 byte, you can store values from -128 to 127. In total, there
are 2&lt;/strong&gt;8 possible numbers. It is equivalent when you use 8 bytes, but
with a larger range of numbers.&lt;/p&gt;
&lt;p&gt;The type of data that you select will have an impact on its size. First,
let's see how this works with a simple example. Let's create three
files, each with one dataset for 100000 elements but with different data
types. We will store the same data to them, and then we can compare their
sizes. We create a random array to assign to each dataset in order to
fill the memory. Remember that data will be converted to the format
specified in the dataset.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;arr = np.random.randn(100000)

f = h5py.File('integer_1.hdf5', 'w')
d = f.create_dataset('dataset', (100000,), dtype='i1')
d[:] = arr
f.close()

f = h5py.File('integer_8.hdf5', 'w')
d = f.create_dataset('dataset', (100000,), dtype='i8')
d[:] = arr
f.close()

f = h5py.File('float.hdf5', 'w')
d = f.create_dataset('dataset', (100000,), dtype='f16')
d[:] = arr
f.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you check the size of each file you will get something like:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;File&lt;/th&gt;
&lt;th&gt;Size (b)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;integer_1&lt;/td&gt;
&lt;td&gt;102144&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;integer_8&lt;/td&gt;
&lt;td&gt;802144&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;1602144&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The relation between size and data type is quite obvious. When you go
from integers of 1 byte to integer of 8 bytes, the file size
increases 8-fold. Similarly, when you go to 16 bytes, it takes
approximately 16 times more space. But space is not the only important
factor to take into account. You should also consider the time it takes
to write the data to disk. The more you have to write, the longer it
will take. Depending on your application, it may be crucial to optimize
the reading and writing of data.&lt;/p&gt;
&lt;p&gt;Note that if you use the wrong data type, you may also lose information.
For example, if you have integers of 8 bytes and you store them as
integers of 1 byte, their values are going to be trimmed. When working
in the lab, it is very common to have devices that produce different
types of data. Some DAQ cards have 16 bits. Some cameras work with 8
bits, but some can work with 24. Paying attention to data types is
important, but is also something that Python developers may not take
into account because you don't have to explicitly declare a type.&lt;/p&gt;
&lt;p&gt;It is also interesting to remember that when you initialize an array
with numpy, it will default to float 8 bytes (64 bits) per element. This
may be a problem if, for example, you initialize an array with zeros to
hold data that is going to be only 2 bytes. The type of the array itself
is not going to change, and if you save the data when creating the
dataset (adding &lt;code&gt;data=my_array&lt;/code&gt;), it will default to the format &lt;code&gt;f8&lt;/code&gt;,
which is the one the array has but not your real data.&lt;/p&gt;
&lt;p&gt;Thinking about data types is not something that happens on a regular
basis if you work with Python on simple applications. However, you
should know that data types are there and the impact they can have on
your results. Perhaps you have large hard drives and you don't care
about storing files a bit larger, but when you care about the speed at
which you save, there is no other workaround but to optimize every
aspect of your code, including the data types.&lt;/p&gt;
&lt;h2&gt;Compressing Data&lt;/h2&gt;
&lt;p&gt;When saving data, you may opt for compressing it using different
algorithms. The package h5py supports a few compression filters such as
GZIP, LZF, and SZIP. When using one of the compression filters, the data
will be processed on its way to the disk and it will be decompressed
when reading it. Therefore, there is no change in how the code works
downstream. We can repeat the same experiment, storing different data
types, but using a compression filter. Our code looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import h5py
import numpy as np

arr = np.random.randn(100000)

with h5py.File('integer_1_compr.hdf5', 'w') as f:
    d = f.create_dataset('dataset', (100000,), dtype='i1', compression=&amp;quot;gzip&amp;quot;, compression_opts=9)
    d[:] = arr

with h5py.File('integer_8_compr.hdf5', 'w') as f:
    d = f.create_dataset('dataset', (100000,), dtype='i8', compression=&amp;quot;gzip&amp;quot;, compression_opts=9)
    d[:] = arr

with h5py.File('float_compr.hdf5', 'w') as f:
    d = f.create_dataset('dataset', (100000,), dtype='f16', compression=&amp;quot;gzip&amp;quot;, compression_opts=9)
    d[:] = arr
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We chose gzip because it is supported in all platforms. The parameters
&lt;code&gt;compression_opts&lt;/code&gt; sets the level of compression. The higher the level,
the less space data takes but the longer the processor has to work. The
default level is 4. We can see the differences in our files based on the
level of compression:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th style="text-align: center;"&gt;No Compression&lt;/th&gt;
&lt;th style="text-align: center;"&gt;Compression 9&lt;/th&gt;
&lt;th style="text-align: right;"&gt;Compression 4&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;integer_1&lt;/td&gt;
&lt;td style="text-align: center;"&gt;102144&lt;/td&gt;
&lt;td style="text-align: center;"&gt;28016&lt;/td&gt;
&lt;td style="text-align: right;"&gt;30463&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;integer_8&lt;/td&gt;
&lt;td style="text-align: center;"&gt;802144&lt;/td&gt;
&lt;td style="text-align: center;"&gt;43329&lt;/td&gt;
&lt;td style="text-align: right;"&gt;57971&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td style="text-align: center;"&gt;1602144&lt;/td&gt;
&lt;td style="text-align: center;"&gt;1469580&lt;/td&gt;
&lt;td style="text-align: right;"&gt;1469868&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The impact of compression on the integer datasets is much more
noticeable than with the float dataset. I leave it up to you to understand why the compressing worked so well in the first two cases and not in the other. As a hint, you should inspect what kind of data you
are saving.&lt;/p&gt;
&lt;p&gt;Reading compressed data doesn't change any of the code discussed above. The underlying HDF5 library will extract the data from the compressed datasets with the appropriate algorithm. Therefore, if you implement compression for saving, you don't need to change the code you use for reading.&lt;/p&gt;
&lt;p&gt;Compressing data is an extra tool that you have to consider, together
with all the other aspects of data handling. You should consider the
extra processor time and the effective compressing rate to see if the
tradeoff between both compensates within your own application. The fact
that it is transparent to downstream code makes it incredibly easy to
test and find the optimum.&lt;/p&gt;
&lt;h2&gt;Resizing Datasets&lt;/h2&gt;
&lt;p&gt;When you are working on an experiment, it may be impossible to know how big your data is going to be. Imagine you are recording a movie, perhaps you stop it after one second, perhaps after an hour. Fortunately, HDF5 allows resizing datasets on the fly and with little computational cost. Datasets can be resized once created up to a maximum size. You specify this maximum size when creating the dataset, via the keyword &lt;code&gt;maxshape&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import h5py
import numpy as np

with h5py.File('resize_dataset.hdf5', 'w') as f:
    d = f.create_dataset('dataset', (100, ),  maxshape=(500, ))
    d[:100] = np.random.randn(100)
    d.resize((200,))
    d[100:200] = np.random.randn(100)

with h5py.File('resize_dataset.hdf5', 'r') as f:
    dset = f['dataset']
    print(dset[99])
    print(dset[199])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, you create a dataset to store 100 values and set a maximum size
of up to 500 values. After you stored the first batch of values, you can
expand the dataset to store the following 100. You can repeat the
procedure up to a dataset with 500 values. The same holds true for
arrays with different shapes, any dimension of an N-dimensional matrix
can be resized. You can check that the data was properly stored by
reading back the file and printing two elements to the command line.&lt;/p&gt;
&lt;p&gt;You can also resize the dataset at a later stage, don't need to do it in
the same session when you created the file. For example, you can do
something it like this (pay attention to the fact that we open the file
with an &lt;code&gt;a&lt;/code&gt; attribute in order not to destroy the previous file):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with h5py.File('resize_dataset.hdf5', 'a') as f:
    dset = f['dataset']
    dset.resize((300,))
    dset[:200] = 0
    dset[200:300] = np.random.randn(100)

with h5py.File('resize_dataset.hdf5', 'r') as f:
    dset = f['dataset']
    print(dset[99])
    print(dset[199])
    print(dset[299])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the example above, you can see that we are opening the dataset,
modifying its first 200 values, and appending new values to the elements
in the position 200 to 299. Reading back the file and printing some
values proves that it worked as expected.&lt;/p&gt;
&lt;p&gt;Imagine you are acquiring a movie, but you don't know how long it will
be. An image is a 2D array, each element being a pixel, and a movie is
nothing more than stacking several 2D arrays. To store movies, we have to define a 3-dimensional array in our HDF file, but we don't want to set a
limit to the duration. To be able to expand the third axis of our
dataset without a fixed maximum, we can do as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with h5py.File('movie_dataset.hdf5', 'w') as f:
   d = f.create_dataset('dataset', (1024, 1024, 1),  maxshape=(1024, 1024, None ))
   d[:,:,0] = first_frame
   d.resize((1024,1024,2))
   d[:,:,1] = second_frame
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The dataset holds square images of 1024x1024 pixels, while the third
dimension gives us the stacking in time. We assume that the images don't
change in shape, but we would like to stack one after the other without
establishing a limit. This is why we set the third dimension's &lt;code&gt;maxshape&lt;/code&gt; to &lt;code&gt;None&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Save Data in Chunks&lt;/h2&gt;
&lt;p&gt;To optimize the data storing, you can opt to do it in chunks. Each
chunk will be contiguous on the hard drive and will be stored as a
block, i.e., the entire chunk will be written at once. When reading a
chunk, the same will happen, entire chunks are going to be loaded. To
create a chunked dataset, the command is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;dset = f.create_dataset(&amp;quot;chunked&amp;quot;, (1000, 1000), chunks=(100, 100))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The command means that all the data in &lt;code&gt;dset[0:100,0:100]&lt;/code&gt; will be
stored together. It is also true for &lt;code&gt;dset[200:300, 200:300]&lt;/code&gt;,
&lt;code&gt;dset[100:200, 400:500]&lt;/code&gt;, etc. According to h5py, there are some
performance implications while using &lt;code&gt;chunks&lt;/code&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Chunking has performance implications. It is recommended to keep the total size of your chunks between 10 KiB and 1 MiB, larger for larger datasets. Also keep in mind that when any element in a chunk is accessed, the entire chunk is read from disk.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;There is also the possibility of enabling auto-chunking, that will take
care of selecting the best size automatically. Auto-chunking is enabled
by default, if you use compression or &lt;code&gt;maxshape&lt;/code&gt;. You enable it
explicitly by doing:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;dset = f.create_dataset(&amp;quot;autochunk&amp;quot;, (1000, 1000), chunks=True)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Organizing Data with Groups&lt;/h2&gt;
&lt;p&gt;We have seen a lot of different ways of storing and reading data. Now we
have to cover one of the last important topics of HDF5 that is how to
organize the information in a file. Datasets can be placed inside
groups, that behave in a similar way to how directories do. We can
create a group first and then add a dataset to it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import numpy as np
import h5py

arr = np.random.randn(1000)

with h5py.File('groups.hdf5', 'w') as f:
    g = f.create_group('Base_Group')
    gg = g.create_group('Sub_Group')

    d = g.create_dataset('default', data=arr)
    dd = gg.create_dataset('default', data=arr)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We create a group called &lt;code&gt;Base_Group&lt;/code&gt; and within it, we create a second
one called &lt;code&gt;Sub_Group&lt;/code&gt;. In each one of the groups, we create a dataset
called &lt;code&gt;default&lt;/code&gt; and save the random array into them. When you read back
the files, you will notice how data is structured:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with h5py.File('groups.hdf5', 'r') as f:
   d = f['Base_Group/default']
   dd = f['Base_Group/Sub_Group/default']
   print(d[1])
   print(dd[1])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, to access a dataset we address it as a folder within the
file: &lt;code&gt;Base_Group/default&lt;/code&gt; or &lt;code&gt;Base_Group/Sub_Group/default&lt;/code&gt;. When you
are reading a file, perhaps you don't know how groups were called and
you need to list them. The easiest way is using &lt;code&gt;keys()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with h5py.File('groups.hdf5', 'r') as f:
    for k in f.keys():
        print(k)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, when you have nested groups, you will also need to start
nesting for-loops. There is a better way of iterating through the tree,
but it is a bit more involved. We need to use the &lt;code&gt;visit()&lt;/code&gt; method, like
this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def get_all(name):
   print(name)

with h5py.File('groups.hdf5', 'r') as f:
   f.visit(get_all)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that we define a function &lt;code&gt;get_all&lt;/code&gt; that takes one argument,
&lt;code&gt;name&lt;/code&gt;. When we use the &lt;code&gt;visit&lt;/code&gt; method, it takes as argument a function like &lt;code&gt;get_all&lt;/code&gt;. &lt;code&gt;visit&lt;/code&gt; will go through each element and while the function doesn't return a value other than &lt;code&gt;None&lt;/code&gt;, it will keep
iterating. For example, imagine we are looking for an element called
&lt;code&gt;Sub_Group&lt;/code&gt; we have to change &lt;code&gt;get_all&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def get_all(name):
    if 'Sub_Group' in name:
        return name

with h5py.File('groups.hdf5', 'r') as f:
    g = f.visit(get_all)
    print(g)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When the method &lt;code&gt;visit&lt;/code&gt; is iterating through every element, as soon as
the function returns something that is not &lt;code&gt;None&lt;/code&gt; it will stop and
return the value that &lt;code&gt;get_all&lt;/code&gt; generated. Since we are looking for the
&lt;code&gt;Sub_Group&lt;/code&gt;, we make the &lt;code&gt;get_all&lt;/code&gt; return the group's name when it finds &lt;code&gt;Sub_Group&lt;/code&gt; as part of the name that is analyzing. Bear in mind
that &lt;code&gt;g&lt;/code&gt; is a string, if you want actually to get the group, you should
do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with h5py.File('groups.hdf5', 'r') as f:
   g_name = f.visit(get_all)
   group = f[g_name]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And you can work as explained earlier with groups. A second approach is
to use a method called &lt;code&gt;visititems&lt;/code&gt; that takes a function with two
arguments: name and object. We can do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def get_objects(name, obj):
   if 'Sub_Group' in name:
      return obj

with h5py.File('groups.hdf5', 'r') as f:
   group = f.visititems(get_objects)
   data = group['default']
   print('First data element: {}'.format(data[0]))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The main difference when using &lt;code&gt;visititems&lt;/code&gt; is that we have accessed the name of the object that is being analyzed and the object
itself. You can see that what the function returns is the object and not
the name. This pattern allows you to achieve more complex filtering. For
example, you may be interested in the empty groups, or that
have a specific type of dataset in them.&lt;/p&gt;
&lt;h2&gt;Storing Metadata in HDF5&lt;/h2&gt;
&lt;p&gt;One of the aspects that are often overlooked in HDF5 is the possibility
to store metadata attached to any group or dataset. Metadata is crucial
in order to understand, for example, where the data came from, what were the parameters used for a measurement or a simulation, etc. Metadata is what makes a file self-descriptive. Imagine you open older data and you find a 200x300x250 matrix. Perhaps you know it is a movie, but you have no idea which dimension is time, nor the timestep between frames.&lt;/p&gt;
&lt;p&gt;Storing metadata into an HDF5 file can be achieved in different ways.
The official one is by adding attributes to groups and datasets.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import time
import numpy as np
import h5py
import os

arr = np.random.randn(1000)

with h5py.File('groups.hdf5', 'w') as f:
    g = f.create_group('Base_Group')
    d = g.create_dataset('default', data=arr)

    g.attrs['Date'] = time.time()
    g.attrs['User'] = 'Me'

    d.attrs['OS'] = os.name

    for k in g.attrs.keys():
        print('{} =&amp;gt; {}'.format(k, g.attrs[k]))

    for j in d.attrs.keys():
      print('{} =&amp;gt; {}'.format(j, d.attrs[j]))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the code above you can see that the &lt;code&gt;attrs&lt;/code&gt; is like a dictionary. In
principle, you shouldn't use attributes to store data, keep them as
small as you can. However, you are not limited to single values, you can
also store arrays. If you happen to have metadata stored in a dictionary
and you want to add it automatically to the attributes, you can use
&lt;code&gt;update&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with h5py.File('groups.hdf5', 'w') as f:
   g = f.create_group('Base_Group')
   d = g.create_dataset('default', data=arr)

   metadata = {'Date': time.time(),
      'User': 'Me',
      'OS': os.name,}

   f.attrs.update(metadata)

   for m in f.attrs.keys():
      print('{} =&amp;gt; {}'.format(m, f.attrs[m]))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Remember that the data types that hdf5 supports are limited. For
example, dictionaries are not supported. If you want to add a dictionary
to an hdf5 file you will need to serialize it. In Python, you can
serialize a dictionary in different ways. In the example below, we are
going to do it with JSON because it is very popular in different fields,
but you are free to use whatever you like, including pickle.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import json

with h5py.File('groups_dict.hdf5', 'w') as f:
    g = f.create_group('Base_Group')
    d = g.create_dataset('default', data=arr)

    metadata = {'Date': time.time(),
                'User': 'Me',
                'OS': os.name,}

    m = g.create_dataset('metadata', data=json.dumps(metadata))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The beginning is the same, we create a group and a dataset. To store the
metadata we define a new dataset, appropriately called metadata. When we
define the data, we use &lt;code&gt;json.dumps&lt;/code&gt; that will transform a dictionary
into a long string. We are actually storing a string and not a
dictionary into HDF5. To load it back we need to read the data set and
transform it back to a dictionary using &lt;code&gt;json.loads&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with h5py.File('groups_dict.hdf5', 'r') as f:
    metadata = json.loads(f['Base_Group/metadata'][()])
    for k in metadata:
        print('{} =&amp;gt; {}'.format(k, metadata[k]))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When you use json to encode your data, you are defining a specific
format. You could have used YAML, XML, etc. Since it may not be obvious
how to load the metadata stored in this way, you could add an attribute
to the &lt;code&gt;attr&lt;/code&gt; of the dataset specifying which way of serializing you
have used.&lt;/p&gt;
&lt;h2&gt;Final thoughts on HDF5&lt;/h2&gt;
&lt;p&gt;In many applications, text files are more than enough and provide a
simple way to store data and share it with other researchers. However,
as soon as the volume of information increases, you need to look for
tools that are better suited than text files. One of the main advantages
of the HDF format is that it is self-contained, meaning that the file
itself has all the information you need to read it, including metadata
information to allow you to reproduce results. Moreover, the HDF format
is supported in different operating systems and programming languages.&lt;/p&gt;
&lt;p&gt;HDF5 files are complex and allow you to store a lot of information in
them. The main advantage over databases is that they are stand-alone
files that can be easily shared. Databases need an entire system to
manage them, they can't be easily shared, etc. If you are used to
working with SQL, you should check &lt;a href="https://www.hdfgroup.org/2016/06/hdfql-new-hdf-tool-speaks-sql/"&gt;the HDFql
project&lt;/a&gt; which allows you to use SQL to parse data from an HDF5 file.&lt;/p&gt;
&lt;p&gt;Storing a lot of data into the same file is susceptible to corruption.
If your file loses its integrity, for example, because of a faulty hard
drive, it is hard to predict how much data is going to be lost. If you
store years of measurements into one single file, you are exposing
yourself to unnecessary risks. Moreover, backing up is going to become
cumbersome because you won't be able to do incremental backups of a
single binary file.&lt;/p&gt;
&lt;p&gt;HDF5 is a format that has a long history and that many researchers use.
It takes a bit of time to get used to, and you will need to experiment
for a while until you find a way in which it can help you store your
data. HDF5 is a good format if you need to establish transversal rules
in your lab on how to store data and metadata.&lt;/p&gt;</content><category term="blog"></category><category term="pyhdf"></category><category term="HDF5"></category><category term="data"></category><category term="file"></category><category term="storing"></category></entry><entry><title>How to Use Decorators to Validate Input</title><link href="https://www.pythonforthelab.com/blog/how-to-use-decorators-to-validate-input" rel="alternate"></link><published>2018-03-12T00:00:00+01:00</published><updated>2018-03-12T00:00:00+01:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2018-03-12:/blog/how-to-use-decorators-to-validate-input</id><summary type="html">&lt;p&gt;Python is rich in resources that can shorten the time it takes to
develop new programs and simplify repetitive tasks. Decorators are one
of such elements but more often than not they are not considered by less
experienced developers. Adding decorators to the syntactic toolbox can
be of great use …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Python is rich in resources that can shorten the time it takes to
develop new programs and simplify repetitive tasks. Decorators are one
of such elements but more often than not they are not considered by less
experienced developers. Adding decorators to the syntactic toolbox can
be of great use in different contexts, and in this article, we are going
to discuss how can they help you when communicating with a device. The
example code can be found in our &lt;a href="https://github.com/PFTL/website_example_code/tree/master/pftl_code/code/01_Decorators"&gt;Github
repository&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Decorators in Python are nothing more than functions that take as
arguments other functions. They appear with an &lt;code&gt;@&lt;/code&gt; in front of them
right above a function (or a method within a class). Let's quickly recap
how functions work in Python and how to use them. Imagine you want to
compute the average of two values. We can develop a function for it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def average(x, y):
   avg = (x+y)/2
   return avg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can use the function directly in our code by writing:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;a = 1
b = 3
result = average(1, 3)
print(result)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What you should see happening is that when you call the function
&lt;code&gt;average&lt;/code&gt; it adds both numbers and returns their mean value. Imagine
that, for some reason, you want to allow only positive numbers as
arguments of your function. You can expand the &lt;code&gt;average&lt;/code&gt; function to
check whether it is true or not.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def average(x, y):
   if x&amp;lt;0 or y&amp;lt;0:
      raise Exception(&amp;quot;Both x and y have to be positive&amp;quot;)

   avg = (x + y)/2
   return avg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Every time someone wants to use the function with a negative argument,
an error will be raised. Later, we are asked to develop a new function
to compute the geometric average of two numbers, and we need them both
to be positive. Our function will look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import math

def geom_average(x, y):
   if x&amp;lt;0 or y&amp;lt;0:
      raise Exception(&amp;quot;Both x and y have to be positive&amp;quot;)

   avg = math.sqrt(x*y)
   return avg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is a general rule of thumb that says that code shouldn't be copied
more than twice. If you are going to copy-paste code for the third time
there is probably a better way of doing it. In the examples above, you
can see that the verification of the input is exactly the same in both
functions. If we were to write a third function, we would meet the
three-copies rule. It would be useful to have an external way of
checking that both inputs are positive, and this is exactly what
decorators are meant to do.&lt;/p&gt;
&lt;h2&gt;Functions as arguments and as outputs of other functions&lt;/h2&gt;
&lt;p&gt;Before we can go into the details of how to use &lt;code&gt;decorators&lt;/code&gt; in Python,
it is important to show how functions work with inputs and outputs that
are other functions. For example, we could define a function that
transforms the output of the averages defined above into integers. It is
a very simplistic example but already shows the pattern that you can
follow to achieve more complex behaviors.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def integer_output(func, x, y):
   res = func(x, y)
   return int(res)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the code above, you can see that &lt;code&gt;integer_output&lt;/code&gt; takes three
arguments, a function &lt;code&gt;func&lt;/code&gt; and two numbers, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; . We use the
function, regardless of what it is, with arguments &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. It then
returns the result of &lt;code&gt;func&lt;/code&gt; converted to an integer value.
&lt;code&gt;integer_output&lt;/code&gt; can be used like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;rounded = integer_output(average, 1, 2)
print(rounded)
geom_rounded = integer_output(geom_average, 4, 5)
print(geom_rounded)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is important to note that the first argument is a function and it
doesn't matter which one. You could use &lt;code&gt;average&lt;/code&gt; or &lt;code&gt;geom_average&lt;/code&gt;. The
next two arguments are going to be passed directly to &lt;code&gt;func&lt;/code&gt; . This is
already quite powerful and most likely you can think a lot of ways in
which you can use it, but Python allows you to do even more interesting
things.&lt;/p&gt;
&lt;p&gt;Functions can also be defined within functions and you can use them
based on your input arguments. For example, let's assume you want to use
&lt;code&gt;average&lt;/code&gt; only if the sum of x and y is even and the &lt;code&gt;geom_average&lt;/code&gt; if
the sum is odd:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def even_odd_average(x, y):
   def average(a, b):
      return (a+b)/2
   def geom_average(a, b):
      return math.sqrt(a*b)

   if (x+y) % 2 == 0:
      return average(x, y)
   else:
      return geom_average(x, y)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function &lt;code&gt;even_odd_average&lt;/code&gt; takes only two arguments on which it is
going to perform the average. Inside we define two functions, exactly as
we did earlier, &lt;code&gt;average&lt;/code&gt; and &lt;code&gt;geom_average&lt;/code&gt;, but this time they are
available only within the &lt;code&gt;even_odd_average&lt;/code&gt; function. Based on the
input from the user, we either calculate the average or the geometric
average as requested earlier and we return the value. We can use this
function as:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;print(even_odd_average(4, 6))
print(even_odd_average(4, 9))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So far, we have seen how to use functions as arguments in other
functions and how to define functions within functions. The only missing
part is to be able to return a function instead of a value. Let's assume
you want to print the time it takes to calculate the average between two
numbers, but you don't want to re-write your original function. We have
to write a function wrapper.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import time

def timing_average(func):
   def wrapper(x, y):
      t0 = time.time()
      res = func(x, y)
      t1 = time.time()
      print(&amp;quot;It took {} seconds to calculate the average&amp;quot;.format(t1-t0))
      return res

   return wrapper
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We start by defining a function that takes as an argument another
function. We also define a new function called &lt;code&gt;wrapper&lt;/code&gt; as we explained
earlier. So far, both steps were done in the previous examples, but now
we are going to use &lt;code&gt;func&lt;/code&gt; within the &lt;code&gt;wrapper&lt;/code&gt;. We start by storing the
current time at the variable &lt;code&gt;t0&lt;/code&gt;. We execute the function &lt;code&gt;func&lt;/code&gt; with
the arguments &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; and store the new time at &lt;code&gt;t1&lt;/code&gt;. We print the
total time it took to run the function and return the output of &lt;code&gt;func&lt;/code&gt;.
The important part here is the very last line. As you can see, we are
not returning the value that &lt;code&gt;func&lt;/code&gt; returns, but we are actually
returning the &lt;code&gt;wrapper&lt;/code&gt;, which is in itself a function. To see this in
action, we can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;new = timing_average(average)
new(2, 4)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What you see in the above code is that we create a function called &lt;code&gt;new&lt;/code&gt;
by using &lt;code&gt;timing_average&lt;/code&gt; with only one argument, the function
&lt;code&gt;average&lt;/code&gt;. &lt;code&gt;New&lt;/code&gt; will take the same inputs that the &lt;code&gt;wrapper&lt;/code&gt; function
takes. If we use &lt;code&gt;new&lt;/code&gt; as a function, with arguments &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt; , you
will see that it prints to screen the total time it took to calculate
the average. &lt;code&gt;new&lt;/code&gt; is nothing more than the function &lt;code&gt;wrapper&lt;/code&gt;, defined
using &lt;code&gt;average&lt;/code&gt;. We could do the same using &lt;code&gt;geom_average&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;new_geom = timing_average(geom_average)
new_geom(4,5)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The syntax above can be hard to understand and forces you to define new
functions to add timing capabilities. When you see that you are
assigning the output of &lt;code&gt;timing_average&lt;/code&gt; to a variable called &lt;code&gt;new&lt;/code&gt; you
don't expect it to actually be a function. If you already have working
code, you need to do a lot of refactoring in order to define and use the
new functions.&lt;/p&gt;
&lt;p&gt;Fortunately, Python offers a very clear and simple way of achieving the
same functionality, without the downsides just said. If you managed to
follow the above examples, you are ready to improve the way the code
looks like by using &lt;em&gt;Python syntactic sugar&lt;/em&gt;.&lt;/p&gt;
&lt;h2&gt;Syntactic Sugar for Decorators&lt;/h2&gt;
&lt;p&gt;You already know almost everything there is to know regarding how to use
decorators, you are just missing the syntactic sugar of Python. With
what you have already done, you can improve the style of your code quite
easily. Assuming you want to add timing capabilities to your average or
geometrical average function, you can simply do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;@timing_average
def average(x, y):
   return (x+y)/2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By simply adding &lt;code&gt;@timing_average&lt;/code&gt; before your function, you are now
able to use &lt;code&gt;average&lt;/code&gt; as always, but printing the time it takes to
calculate it. The obvious advantage of this syntax is that it allows you
to add an interesting new functionality without altering your downstream
code. You don't need to define a new function, you only need to add one
line of code before the definition of your &lt;code&gt;average&lt;/code&gt;. It runs as always:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;avg = average(4, 6)
print('The average between 4 and 6 is {}'.format(avg))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Coming back to the examples of the averages that take only positive
arguments, and building on the example of &lt;code&gt;timing_average&lt;/code&gt;, we can
develop a wrapper function that would check whether the input of our
function is positive or not.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def check_positive(func):
   def func_wrapper(x, y):
      if x&amp;lt;0 or y&amp;lt;0:
         raise Exception(&amp;quot;Both x and y have to be positive for function {} to work&amp;quot;.format(func.__name__))
      res = func(x,y)
      return res
   return func_wrapper
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The structure of &lt;code&gt;check_positive&lt;/code&gt; is very similar to what we have done
for the timing. The only difference is that we check the input arguments
and we raise an &lt;code&gt;Exception&lt;/code&gt; if they are not both positive. Since we are
raising an exception for an unknown function, it becomes handy to
display which function actually gave the error. We achieve that by using
&lt;code&gt;func.__name__&lt;/code&gt;, which will tell us the name of the function. The rest
is exactly the same as with the timing example. We can write our average
functions as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;@check_positive
def average(x, y):
   return (x + y)/2

@check_positive
def geom_average(x, y):
   return math.sqrt(x*y)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both functions, &lt;code&gt;average&lt;/code&gt; and &lt;code&gt;geom_average&lt;/code&gt; don't change their names,
therefore you can use them as always, but they will check for positive
input before computing the average:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;average(2, 4)
average(-2, 4)
geom_average(4, 9)
geom_average(-4, 10)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Decorators can also be combined, you can time a function AND request the
inputs to be positive:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;@timing_average
@check_positive
def average(x, y):
   return (x + y)/2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can play around and see what happens if you change the order of the
decorators. Importantly, if you use &lt;code&gt;func.__name__&lt;/code&gt; to print the name of
the function that raised the &lt;code&gt;Exception&lt;/code&gt; within a decorator, you can see
that the name can change and become the name of the wrapper. In most
cases this is not a desired situation because you won't be able to debug
what is the real function giving troubles, you will just get the name of
the decorator. However, this is a more subtle topic that will be covered
in the future.&lt;/p&gt;
&lt;p&gt;Decorators are very powerful and can help you develop very clean and
useful code. The obvious application of decorators is to validate the
input provided by the user. Decorators are also very useful when you are
writing a library that other developers are going to use. Or when you
want to alter the behavior of a method or function in a systematic way.
For example, you could use some cache in order to avoid running the same
function with the same arguments over and over again.&lt;/p&gt;
&lt;p&gt;One of the advantages of decorators is that even if a developer doesn't
fully understand what it is happening under the hood, it will for sure
understand how to use them and what to expect. If you provide good
examples in your code it will become apparent where and when to include
specific decorators. Now that you have a basic understanding of what the
&lt;code&gt;@&lt;/code&gt; means in Python you can start thinking about many more interesting
applications.&lt;/p&gt;
&lt;p&gt;In this article, we have shown a couple of very basic examples that can
be greatly improved. If you have ever encountered decorators and didn't
understand how to use them, or you are looking for more specific
information, leave your message in the comment section below, and we will
use your feedback to write a follow-up article specifically designed to
answer your questions.&lt;/p&gt;</content><category term="blog"></category><category term="Decorators"></category><category term="Python"></category><category term="Tricks"></category><category term="Validation"></category><category term="Data"></category></entry><entry><title>Virtual Environment is a Must-Have Tool</title><link href="https://www.pythonforthelab.com/blog/virtual-environment-is-a-must-have-tool" rel="alternate"></link><published>2018-03-09T00:00:00+01:00</published><updated>2018-03-09T00:00:00+01:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2018-03-09:/blog/virtual-environment-is-a-must-have-tool</id><summary type="html">&lt;p&gt;When you start developing software, it is of utmost importance to have
an isolated programming environment in which you can control precisely
the packages installed. This will allow you, for example, to use
experimental libraries without overwriting software that other programs
use on your computer. Isolated environments allow you, for …&lt;/p&gt;</summary><content type="html">&lt;p&gt;When you start developing software, it is of utmost importance to have
an isolated programming environment in which you can control precisely
the packages installed. This will allow you, for example, to use
experimental libraries without overwriting software that other programs
use on your computer. Isolated environments allow you, for example, to
update a package only within that specific environment, without altering
the dependencies in every other development you are doing.&lt;/p&gt;
&lt;p&gt;Python provides a very convenient tool called &lt;code&gt;Virtual Environment&lt;/code&gt; that
allows you to do exactly what was described. The instructions are
slightly different depending on the operating system that you use, but
they are easy to adapt from one to the other. To install
&lt;code&gt;Virtual Environment&lt;/code&gt; you can do it with &lt;code&gt;pip&lt;/code&gt;, the package manager of
Python. Remember that sometimes you may have more than one version of
pip in your computer, in the same way, you may have more than one
version of Python. For example, if you are using Python 3, you would
type in the command line:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip3 install virtualenv
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you are on Linux, you may need to add &lt;code&gt;sudo&lt;/code&gt; to the command:
&lt;code&gt;sudo pip3 install virtualenv&lt;/code&gt;, depending on how you have installed
Python. This is the last installation that you do system-wide. From now
on, everything else will happen within a Virtual Environment. It is a
common practice to encapsulate projects in folders that also contain the
virtual environment. You have to be sure, however, that you don't add
your virtual environment folder to version control, or you will end up
having &lt;strong&gt;huge&lt;/strong&gt; repositories.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;mkdir myproject
cd myproject
virtualenv venv -p python3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first line creates the folder for the project and then we move into
it. In the last line, we create the virtual environment within a folder
called &lt;code&gt;venv&lt;/code&gt; and using a specific version of Python, in this case it is
&lt;code&gt;python3&lt;/code&gt;. Now it is time to activate the virtual environment. On Linux
you would do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;source venv/bin/activate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;while on Windows the command would be (pay attention to the &lt;code&gt;.\&lt;/code&gt; at the
beginning):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;.\venv\Scripts\activate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If everything went well, you will see that a &lt;code&gt;(venv)&lt;/code&gt; appears at the
beginning of the command line. Now you are working inside the Virtual
Environment called &lt;code&gt;venv&lt;/code&gt; and all the packages you install are going to
be stored within it. Let's install a package to see how it works.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install Flask==1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The command will install a very specific version of Flask, which is not
the most recent one. One of the useful aspects of virtual environments
is that they allow you to keep track of all the packages that you have
installed, including their versions. If you execute this command:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip freeze
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You will see all the installed packages. You should see that you have
installed not only Flask, but all of its dependencies, each one with a
specific version. It is wise to output the results to a file that you
can use later on for automatically installing all the requirements of
your project:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip freeze &amp;gt; requirements.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you open the file &lt;code&gt;requirements.txt&lt;/code&gt; you will notice that it contains
a list with all the packages from &lt;code&gt;venv&lt;/code&gt;. To see the full potential of
Virtual Environment, let's create a second one. First, we need to
deactivate the one we are working on now by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;deactivate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now we repeat the step above to create a new environment, but with a
different name:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;virtualenv test -p python3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we activate it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;source test/bin/activate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or for Windows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;.\venv\Scripts\activate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we run again &lt;code&gt;pip freeze&lt;/code&gt; you will notice that your environment is
empty. We can install all the packages contained in the
&lt;code&gt;requirements.txt&lt;/code&gt; file by simply running:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install -r requirements.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you check again with &lt;code&gt;pip freeze&lt;/code&gt; you will notice that you have
exactly the same packages than in the &lt;code&gt;venv&lt;/code&gt; environment. You can
upgrade Flask, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install --upgrade Flask
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And if you run again &lt;code&gt;pip freeze&lt;/code&gt; you will notice that the version of
Flask has changed. Repeat the steps mentioned above in order to
deactivate &lt;code&gt;test&lt;/code&gt; and activate &lt;code&gt;venv&lt;/code&gt;. You will see that the version of
Flask stayed at &lt;code&gt;1.0&lt;/code&gt; and was not upgraded.&lt;/p&gt;
&lt;p&gt;Of course, you can run the &lt;code&gt;freeze&lt;/code&gt; command outside of any virtual
environment to see all the packages installed in your computer. It is a
very useful way of keeping track of the packages that may need an
upgrade or that you no longer use.&lt;/p&gt;
&lt;h2&gt;How does the Virtual Environment Work&lt;/h2&gt;
&lt;p&gt;When you run programs from the command line, your operating system needs
to know where to find them. The location of the programs in Windows and
Linux is radically different, but they both are able to understand that
when you type &lt;code&gt;python&lt;/code&gt; in the command line, you want to start the Python
interpreter. In order to achieve this, operating systems know where to
look for programs thanks to the so-called environmental variables. The
&lt;code&gt;PATH&lt;/code&gt; is one of those variables that stores a list of folders where to
look for programs.&lt;/p&gt;
&lt;p&gt;When you work in a virtual environment, all that you do is to replace
the relevant variables. In this way, when you run &lt;code&gt;python&lt;/code&gt; in the
command line, it will first find the one that corresponds to the virtual
environment. For example, imagine that you have two different versions
of Python, let's say &lt;code&gt;python&lt;/code&gt; (for Python 2) and &lt;code&gt;python3&lt;/code&gt; (for Python
3). When you create a virtual environment, you can specify which version
of python to use by adding the option &lt;code&gt;-p&lt;/code&gt; at the end. In the examples
above, we have used &lt;code&gt;python3&lt;/code&gt;, and therefore every time we type &lt;code&gt;python&lt;/code&gt;
in the virtual environment, we will be actually triggering &lt;code&gt;python3&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But that is not all. If you navigate to the folder of the virtual
environment, you will see a folder called &lt;strong&gt;bin&lt;/strong&gt;, where actually the
executables for Python and Pip are located. In this way, you are
isolated from the computer. If the OS decides to upgrade from Python 3.4
to Python 3.6, for example, you will still have the proper version in
your virtual environment. If you navigate to the &lt;strong&gt;lib&lt;/strong&gt; folder and go
inside the python folder, you will find the &lt;strong&gt;site-packages&lt;/strong&gt;, which are
all the packages installed by pip.&lt;/p&gt;
&lt;p&gt;If you have compiled programs that you want to use, in principle you can
put them into the &lt;strong&gt;bin&lt;/strong&gt; folder. If you have Python packages that are
not installed through pip (such as PyQt4), you can install them
system-wide and then just copy the appropriate folder into your virtual
environment.&lt;/p&gt;
&lt;h3&gt;Be careful with name clashes&lt;/h3&gt;
&lt;p&gt;It is common that some python packages also generate &lt;em&gt;entry points&lt;/em&gt;,
i.e. commands that can be triggered directly from the command line. For
example, if you are inside your virtual environment, you can run &lt;code&gt;flask&lt;/code&gt;
directly from the command line. This behavior is very useful, but it can
easily collide with packages installed system-wide.&lt;/p&gt;
&lt;p&gt;Imagine you installed Flask in your system, and then you start working
in a virtual environment that doesn't have Flask installed. If you run
&lt;code&gt;flask&lt;/code&gt; it will work, but it will be using the version from your OS.
This is something very easy to miss when dealing with more complicated
packages such as the Jupyter notebook or sphinx for building
documentation.&lt;/p&gt;
&lt;p&gt;There is no one solution that fits all. It is important for you to be
aware of the different problems that may arise when you run programs
directly from the command line. Especially Linux/Mac users should be
aware that when using the package manager and installing, for instance,
Jupyter, you will also create the proper links in the &lt;strong&gt;bin&lt;/strong&gt; directory,
allowing you to run &lt;code&gt;jupyter notebook&lt;/code&gt; directly. However, if you install
it through pip, there are no entry points. Therefore, if you just type
&lt;code&gt;jupyter notebook&lt;/code&gt;, you will use the system one. To overcome this, you
can use the following command:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;python -m jupyter notebook
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will guarantee that you are going to use the package installed
through Pip and not the one installed by your system.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;It is almost impossible to overestimate how useful the &lt;em&gt;Virtual
Environment&lt;/em&gt; is. It will help you stay organized and out of conflicts
when you develop software, and it will also avoid problems when you are
installing different libraries that you want to test. It doesn't matter
if it is for the lab computer or for analyzing data, if you keep your
programs compartmentalized, you can be sure that they will all run
properly, regardless of their specific needs.&lt;/p&gt;
&lt;p&gt;Remember, every time you are about to start a new project, regardless of
what it is, you should start by creating an appropriate Virtual
Environment for it. In this way, you can be certain of the long-term
prosperity of the code you write, regardless of where it will bring you.&lt;/p&gt;</content><category term="blog"></category><category term="Python"></category><category term="Virtual Environment"></category><category term="Development"></category></entry><entry><title>How to Control a Device Through the Network</title><link href="https://www.pythonforthelab.com/blog/how-to-control-a-device-through-the-network" rel="alternate"></link><published>2018-02-28T00:00:00+01:00</published><updated>2018-02-28T00:00:00+01:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2018-02-28:/blog/how-to-control-a-device-through-the-network</id><summary type="html">&lt;p&gt;In the lab, it is common to find different computers connected to
specific devices. For example,when you keep older PCs which are able to
communicate with very specific hardware. You may also have different
computers when there are mobile instruments that you share among
different users. In these situations …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In the lab, it is common to find different computers connected to
specific devices. For example,when you keep older PCs which are able to
communicate with very specific hardware. You may also have different
computers when there are mobile instruments that you share among
different users. In these situations it becomes very useful to be able
to exchange information between your main computer and a secondary one.&lt;/p&gt;
&lt;p&gt;A computer network utilizes two elements: a server and a client. The
server receives the messages you send, interprets them and returns
values if asked to. The client communicates with the server, sends
commands and receives data. Internet works this way: when you entered
this website, you used a browser, the client, to access content on a
server. Communicating with a device connected to another computer is,
therefore, not different from what we have just described.&lt;/p&gt;
&lt;p&gt;If you look around for Python frameworks to build web applications, you
will find several but two are going to stand out:
&lt;a href="https://www.djangoproject.com/"&gt;Django&lt;/a&gt; and
&lt;a href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt;. Django is a complete package for
developing web applications, but a total overkill for our purposes.
Flask is slightly more barebones, but it provides all the functionality
that we are looking for: to create a server that will take inbound
communication and act accordingly, for example by triggering a
measurement on a device.&lt;/p&gt;
&lt;p&gt;Installing Flask doesn't take much more than a pip command:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;pip install Flask
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After that we can build our first very simple app to see that everything
is working fine:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from flask import Flask
app = Flask(__name__)

@app.route('/')
def index():
   return &amp;quot;The Server is up and running&amp;quot;

app.run()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the file, open a browser, and head to &lt;code&gt;localhost:5000&lt;/code&gt; you
will see a message saying that the server is up and running. A lot of
things are happening that are worth discussing in detail. We start by
importing Flask and creating an &lt;code&gt;app&lt;/code&gt;. Our app is very powerful; one of
the things it allows us to do is to trigger specific functions when we
head to specific locations on the server. These are called &lt;code&gt;routes&lt;/code&gt;;
when we define a route and we add the string &lt;code&gt;'/'&lt;/code&gt; it means that the
function following it will be triggered whenever someone enters to the
root of the server (&lt;code&gt;/&lt;/code&gt;). Our example only returns a message saying that
everything went well.&lt;/p&gt;
&lt;p&gt;The last line runs the app. This is an infinite loop that will open a
port at localhost for us to test our application. If you are familiar
with how PyQt works, you will notice the similarities. Once the app is
running, you can point the browser to the address that appears on your
command line, most likely &lt;code&gt;localhost:5000&lt;/code&gt;. When you enter to that
address, you are triggering the &lt;code&gt;route('/')&lt;/code&gt; and therefore you will get
the message &lt;code&gt;The Server is up and running&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So far, both the server and the client are the same device. We will see
later how to improve on this, but for the time being, you can believe
that everything will work exactly the same, even when communicating
through the network. It is possible to trigger other actions directly on
the server side, not only to return strings. To test it, we can use a
&lt;code&gt;print&lt;/code&gt; statement. Let's re-write the &lt;code&gt;index()&lt;/code&gt; function:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;[...]

def index():
   print('Index Triggered')
   return 'The server is up, running, and printing statements'

[...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the server file again and head your browser to
&lt;code&gt;localhost:5000&lt;/code&gt; you should see not only the string appearing on your
screen, but also a message will appear on the command line where the
server is running. The &lt;code&gt;print&lt;/code&gt; function is being triggered on the
server. We could use more complex functions than &lt;code&gt;print&lt;/code&gt;. For example,
we could trigger a measurement on a device.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;If you are not dealing with instruments but you would like to trigger
computer-intensive tasks on a remote computer, you can use the same
approach explained here. You can then leverage computers with more
memory or better processors, or you can even make a parallel execution
of your code without leaving your Jupyter notebook.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Let's assume you have a device like the one we developed in our earlier
post &lt;a href="https://www.pythonforthelab.com/blog/how-to-write-a-driver-with-lantz"&gt;How to Write a Driver with
Lantz&lt;/a&gt;. The device is an
oscilloscope with several built-in methods, including &lt;code&gt;idn&lt;/code&gt; for getting
its serial number, and &lt;code&gt;datasource&lt;/code&gt; to set and get the channel used for
an acquisition. We would like to trigger some of those methods when we
head to specific addresses on our browser. Later on, we will change the
browser by a custom-made client that will simplify our workflow. We
begin by initializing the device and we make it available to the app:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from flask import Flask
from devices import my_device

dev = my_device.via_usb()

app = Flask(__name__)

@app.route('/idn')
def idn():
   return dev.idn

app.run()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The core is the same as before, but we have added some lines for the
device. We import the needed classes and we initialize the communication
with the device; you should adapt the highlighted lines with your own
device. The new route now establishes that if you head to
&lt;code&gt;localhost:5000/idn&lt;/code&gt;, the serial number of the device is going to be
returned. This action is much more complex than printing on the server
or returning a simple string. What we are actually sending is a command
to a device, waiting for it to return a value and then we are sending it
back to the browser. With this simple example, you can already see that
we are doing virtually everything that a device can handle. Of course,
devices also take inputs, and we should take into account this. Basing
ourselves on the example of an &lt;a href="https://www.pythonforthelab.com/blog/how-to-write-a-driver-with-lantz"&gt;oscilloscope with
Lantz&lt;/a&gt;, we could change the
datasource property of the device like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;[...]
@app.route(&amp;quot;/datasource/&amp;lt;int:source_id&amp;gt;&amp;quot;)
def datasource(source_id):
   dev.datasource = source_id
   return(dev.datasource)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The lines above show a very simple way of sending variables through a
browser. The &lt;code&gt;route&lt;/code&gt; takes more complex structures than plain strings.
&lt;code&gt;&amp;lt;int:source_id&amp;gt;&lt;/code&gt; will take an integer after the &lt;code&gt;datasource/&lt;/code&gt; and it
will pass it as an argument to the function below. The function
&lt;code&gt;datasource&lt;/code&gt; in our server, therefore, should take exactly one argument,
&lt;code&gt;source_id&lt;/code&gt;, and we use it for changing the &lt;code&gt;datasource&lt;/code&gt; of the device.
Now, if you head your browser to &lt;code&gt;localhost:5000/datasource/1&lt;/code&gt; we will
change the source to 1, we can do the same with 2, 3, etc. Bear in mind
that not all values are valid with the device. Check what happens if,
for example, you send a value outside the range of what is possible.&lt;/p&gt;
&lt;p&gt;Communicating with our devices through the browser may not be the most
practical approach. Instead, we can build a special program called
Client that will handle the sending and retrieving of information from
the server. When we have control on both the server and the client side
software, we can easily control the data that is being exchanged. When
we don't have control over one of the two sides, we have to base
ourselves on available standards; for example, the data that a browser
can handle is limited, the instructions a server can receive are few,
etc. We are going to base our client on a common Python library called
&lt;code&gt;requests&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import requests

addr = 'http://localhost:5000'
r = requests.get(addr + &amp;quot;/idn&amp;quot;)

print(r.content)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the script written above (while the server script is running
on a different command line), you will see that what gets printed on
screen is the identification of the device. Basically, what you have
achieved is the exchange of information from a device hooked to a server
with a client not directly bound to that device. You could build a class
around the requests. If you want, for example, a client exclusively for
the oscilloscope, we can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import requests


def ClientOscilloscope():
   def __init__(self, addr):
      self.addr = addr

   def idn(self):
      r = requests.get(self.addr + '/idn')
      return r.content

if __name__ == '__main__':
   c = ClientOscilloscope('http://localhost:5000')
   print(c.idn())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The applications of this approach are multiple and not limited to
communicating over the network. Imagine that you want to share the
information of a device with multiple applications; instead of
initializing the communication with the device in each application (that
will almost certainly lead to issues), you can communicate through a
server, even if on the same computer. You can test this idea if you
access &lt;code&gt;localhost&lt;/code&gt; from two different browsers. You can get the &lt;code&gt;idn&lt;/code&gt; of
your device twice without issues. You can also run the client script
from two different command lines, and you will see that your server can
handle several requests at the same time without issues and without
blocking the device; the communication is initialized only once, at the
beginning of the server script.&lt;/p&gt;
&lt;p&gt;Being able to access the server from a different computer depends on the
configuration of your network. First, you need to know the &lt;code&gt;ip&lt;/code&gt; address
of your computer. Remember that an ip is a unique number that identifies
your connection to a network; if you are connected to the Internet, you
will have two different numbers, the ip of your computer within a local
network, and the public ip that is going to be shared by all the other
computers on the same network.&lt;/p&gt;
&lt;p&gt;Let's assume that you want to control a device within a local network in
your lab. The only thing you need to do is to run the server on the
computer you wish to use; most likely you are going to desire a specific
port number for the inbound communication. You can do so with this
simple command:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;app.run('0.0.0.0', 1234)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which will allow you to run the server on port 1234. You have to check
that the port is not used by other processes; for example, port 80 is
used by HTTP connections. You can aim for higher numbers like 10000 and
above, since those are most likely not used and open within your
network. If you now head the browser of another device to &lt;code&gt;ip:1234/idn&lt;/code&gt;
you should see the identification number of your device. This procedure
is mobile-friendly; you could use your phone to trigger measurements,
without developing any apps, just using your mobile browser.&lt;/p&gt;
&lt;p&gt;Accessing a computer from outside the local network is possible, but it
normally depends on the policy of the institution where you work. The
easiest way is to have port forwarding, for example when you access
&lt;code&gt;public_ip:specific_port&lt;/code&gt;, the connection is forwarded to a specific
computer within the local network. To configure it, you need help from
the administrator of the network and as a general safety rule, they will
never allow such a thing. If you make a mistake, you are giving access
to anyone who finds out which port to use.&lt;/p&gt;
&lt;p&gt;The possibilities are limitless. If you want to see how to configure a
more complex Server/Client strategy that handles any number of devices,
you can check &lt;a href="https://github.com/uetke/UUServer"&gt;Uetke's Instrument
Server&lt;/a&gt;. In this project, the server
is an extension of Flask; we have defined some common routes to
communicate with clients. We have also made use of &lt;code&gt;JSON&lt;/code&gt; as a way of
exchanging structured information between client and server. The
repository also includes a client and a fake instrument to test the
behavior.&lt;/p&gt;
&lt;p&gt;The examples we have shown above are very basic but important to
understand, if you want to achieve more complex functionality. For
example, if you want the server to stay responsive while triggering
tasks that take long to execute on a device, you have to implement
threads. That is a more extensive discussion than what we can have here,
but you can find an implementation example
&lt;a href="https://github.com/uetke/UUServer/blob/master/instserver/server.py"&gt;here&lt;/a&gt;.
There are some other packages that can be used for threading on web
servers. Those packages were created precisely to handle async tasks.
They are aimed at web development but could be useful also for
applications with experiments. You can check for example,
&lt;a href="http://docs.celeryproject.org/en/latest/"&gt;Celery&lt;/a&gt; and
&lt;a href="https://www.rabbitmq.com"&gt;RabbitMQ&lt;/a&gt;, although they are fairly complex,
they can be exactly what you are looking for.&lt;/p&gt;
&lt;p&gt;If you need help developing a code for communicating over the network,
don't hesitate to &lt;a href="https://www.pythonforthelab.com/about"&gt;contact us&lt;/a&gt;. We can
custom build a solution to your problem. If you would like to learn
about network communication and much more, you can also consider our
&lt;a href="https://www.pythonforthelab.com/hire-me"&gt;Advanced Python For The Lab
Course&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Header photo by &lt;a href="https://unsplash.com/photos/l090uFWoPaI?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText"&gt;John
Carlisle&lt;/a&gt;
on Unsplash&lt;/p&gt;</content><category term="blog"></category><category term="Network"></category><category term="Communication"></category><category term="Async"></category><category term="Remote Control"></category><category term="Devices"></category><category term="Drivers"></category><category term="Flask"></category><category term="Internet"></category></entry><entry><title>How to Write a Driver with Lantz</title><link href="https://www.pythonforthelab.com/blog/how-to-write-a-driver-with-lantz" rel="alternate"></link><published>2018-02-23T00:00:00+01:00</published><updated>2018-02-23T00:00:00+01:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2018-02-23:/blog/how-to-write-a-driver-with-lantz</id><summary type="html">&lt;p&gt;Lantz is a package written by several researchers who wanted to have a
framework to build instrumentation on Python. It is open source and
hosted &lt;a href="https://github.com/LabPy/lantz"&gt;on Github&lt;/a&gt;. Their description is
very clear:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Lantz is an automation and instrumentation toolkit with a clean,
well-designed and consistent interface. It provides a core …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;p&gt;Lantz is a package written by several researchers who wanted to have a
framework to build instrumentation on Python. It is open source and
hosted &lt;a href="https://github.com/LabPy/lantz"&gt;on Github&lt;/a&gt;. Their description is
very clear:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Lantz is an automation and instrumentation toolkit with a clean,
well-designed and consistent interface. It provides a core of commonly
used functionalities for building applications that communicate with
scientific instruments allowing rapid application prototyping,
development and testing. Lantz benefits from Python's extensive
library flexibility as a glue language to wrap existing drivers and
DLLs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Lantz was built with one objective in mind: make easier to researchers
the development of drivers for their devices. With time the Lantz group
has built an entire framework that handles different types of
connections, such as GPIB, Serial, Ethernet, etc. and much more. The
values generated are kept in a cache that prevents unnecessary
communications with the devices. Plus, the syntax is simple and allows
to check for limits and units before sending commands to the real
device.&lt;/p&gt;
&lt;p&gt;Let's see step by step how to build a driver for a common device, for
instance, a &lt;a href="https://www.tek.com/oscilloscope/tds1000-manual"&gt;Tektronics
Oscilloscope&lt;/a&gt;. The
first thing we need to do is to import the needed modules from Lantz.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from lantz.feat import Feat
from lantz.action import Action
from lantz.messagebased import MessageBasedDriver
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We will see how to use each one of them. We first define the class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class TDS1012(MessageBasedDriver):

MANUFACTURER_ID = '0x699'
DEFAULTS = {'USB': {'write_termination': '\n',
                        'read_termination': '\n',
                        'timeout': 5000,
                        'encoding': 'ascii'
            }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We inherit from the general &lt;code&gt;MessageBasedDriver&lt;/code&gt; because the
Oscilloscope communicates through an exchange of text commands. We
define the Manufacturer Id because it is one of the easiest ways of
identifying USB devices. Beware that if there were two different
Tektronix devices connected, the program will not be able to
differentiate between them, you should provide more information as I
will show below.&lt;/p&gt;
&lt;p&gt;The second important step is to define the defaults for the
communications. In this case, we are setting the defaults for a USB
communication. The write and read terminations are the new line
character and we set the encoding to ascii; all this information can be
found in the manual. We set the timeout to 5 seconds; if a command takes
longer than that to execute it will stop it.&lt;/p&gt;
&lt;p&gt;Now we are ready to start developing some more interesting code for our
driver. Normally, one of the first commands we can exchange with a
device is to ask for its identification. We can achieve it like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;@Feat()
def idn(self):
   return self.query('*IDN?')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we see the use of the first decorator, called &lt;code&gt;Feat&lt;/code&gt;. Decorators in
Python are complex, but they can be described mainly as functions that
take as arguments other functions. When we use the &lt;code&gt;Feat&lt;/code&gt; decorator a
lot of things are going to happen internally in Lantz, but we shouldn't
worry too much for the time being. What you should remember is that
Features are all those elements in a device that will return a value or
that can be set to a value. The identification of the oscilloscope is
one of such features. Now we can already use the class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with TDS1012.via_usb() as osc:
   print(os.idn)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now we see the magic of Lantz happening. First, the fact that we can
use the &lt;code&gt;with&lt;/code&gt; statement means that some methods were defined for us
under the hood; these methods are in charge of initializing and
finalizing the communication with the device, in order to free the
resource right after the statement finishes. The second important thing
to notice is that we initialize the device with the &lt;code&gt;via_usb()&lt;/code&gt; method.
Of course, it could have been &lt;code&gt;via_serial()&lt;/code&gt;, for example, but let's
keep with the USB for now.&lt;/p&gt;
&lt;p&gt;The second important thing to note is that the method &lt;code&gt;idn&lt;/code&gt; is treated
as a property of the device itself. This is achieved through the &lt;code&gt;Feat&lt;/code&gt;
decorator. If you are an experienced Python programmer you probably know
how to achieve this behavior for your own classes; in Lantz, you
shouldn't worry too much about understanding it, but you have to learn
just how to use them.&lt;/p&gt;
&lt;p&gt;Now, imagine you want to trigger the device; that doesn't count as a
Feature because you are not setting a specific value nor getting a
value. That is the situation where you would use an &lt;code&gt;Action&lt;/code&gt; decorator:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;@Action()
def trigger(self):
   self.write('*TRG')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case, we are only writing to the oscilloscope and therefore we
are not awaiting any output value after the action. &lt;code&gt;Action&lt;/code&gt; decorators
don't have much magic behind; they can be thought as the buttons on a
device; a button is pressed and an action is triggered.&lt;/p&gt;
&lt;p&gt;We have so far only discussed a passive &lt;code&gt;Feat&lt;/code&gt;, or better called, a
&lt;em&gt;read-only&lt;/em&gt; only feature. But what happens when we have a feature that
actually accepts values; the oscilloscope, for example, can be set to
acquire one of two different channels. First, we define the &lt;em&gt;feature&lt;/em&gt; to
read which channel is going to be read, in exactly the same way than for
the &lt;code&gt;idn&lt;/code&gt; feature.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;@Feat(limits=(1,2))
def datasource(self):
   return self.query('DAT:SOU?')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first difference to note here is that we have added limits to the
feature, in this case, the value it will output will be in the range
from 1 to 2 (1 and 2 included). While reading from a device it is not
important to know the limits, but when we write, it becomes crucial. The
way of setting the value of the data source is like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;@datasource.setter
def datasource(self,value):
   self.write('DAT:SOU CH{}'.format(value))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, if you have ever worked with properties of classes the syntax may
result familiar, but if you haven't don't worry too much. Once we have
defined the method &lt;code&gt;datasource&lt;/code&gt; as a &lt;code&gt;Feat&lt;/code&gt;, we can change its value by
defining a &lt;code&gt;setter&lt;/code&gt;. Now, pay attention here, the decorator we use is
&lt;code&gt;@datasource.setter&lt;/code&gt;, because the function that comes after is exactly
that, instructions on how to set the &lt;code&gt;datasource&lt;/code&gt; feature. The method
defined right after is the function that is going to be called when we
do something like:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;dev.datasource = 1
print(dev.datasource)
dev.datasource = 2
print(dev.datasource)
dev.datasource = 3 # This will raise an Exception
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that it takes one argument, value. The value will be first checked
against the limits we established in the &lt;code&gt;Feat&lt;/code&gt; declaration, i.e. it
should be between 1 and 2. That is why if you try to assign the value 3
to it, it will fail. Because of how we did things, if you send the value
1.5 to the datasource, it won't fail, but it is not a valid command.&lt;/p&gt;
&lt;h2&gt;Using Units&lt;/h2&gt;
&lt;p&gt;One of the most useful utilities of Lantz is the built-in units. The
oscilloscope doesn't provide a lot of good opportunities to work with
units but trust me when you are working with other devices they are
going to be very handy. When you are reviewing old code it is always
hard to remember if the values should be set in nanometers, centimeters
and sometimes you don't want to dig up the manual from an obscure
website or cupboard in your lab. Let's imagine we have a tunable laser,
and we want to set the output wavelength to it. Our code would become:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;@Feat(units='nm', limits=(1480, 1640, 0.0001))
def wavelength(self):
   return self.query('WA')

@wavelength.setter
def wavelength(self, value):
   self.query('WA%.4f' % value)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We begin by declaring a feature, with units nanometers and some limits.
Importantly, we set the step at which we can change the wavelength:
0.1pm. Now, the wavelength setter looks exactly the same as with the
oscilloscope. All the magic is going to happen thanks to the &lt;code&gt;Feat&lt;/code&gt;
decorator at the beginning, converting to the proper units before
actually sending the command to the device. To use it, you can just do:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from lantz import Q_

wl = Q_('1500nm')
dev.wavelength = wl
print(dev.wavelength)
wl = 1510
dev.wavelength = wl
print(dev.wavelength)
um = Q_('um')
wl = 1.520*um
dev.wavelength = wl
print(dev.wavelength)
wrong = Q_('1500V')
dev.wavelength = wrong
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first thing we have to do is to import the module Quantity directly
from Lantz, which is basically the unit registry from Pint; if this is
the first time you hear about Pint, I really suggest that you check out
&lt;a href="http://pint.readthedocs.io/en/latest/"&gt;that project&lt;/a&gt;. We then define a
variable &lt;code&gt;wl&lt;/code&gt; as a 1500nm quantity and set the laser wavelength to it.
The rest of the commands are just to test the different scenarios; for
example, when you don't specify units, Lantz will automatically assume
the default units (the ones you set in the &lt;code&gt;@Feat&lt;/code&gt;). You can, of course,
use other units; I've chosen micrometers, but anything that is
distance-related would have just worked fine. You could have even used
inches. Of course, the program will raise an Exception if you try to
pass the wrong units to the wavelength.&lt;/p&gt;
&lt;p&gt;The advantage of using units so early in the code (at driver
development) is that it will make it clear for the rest of our programs
what units are we supposed to use. We don't need to worry about a user
(or even ourselves) confusing nanometers with micrometers, the
conversion will happen under the hood. In my experience, however, few
people are used to the Pint package and get slightly confused when they
have to work with a new type of variable that has both a number and a
unit. Anyways, a bit of practice doesn't heart.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;Lantz has seen a rollercoaster of development cycles, from very active
to almost abandoned. Lately, it has been hibernating, as you can see by
the number of merge requests and issues open that no one has replied to.
In any case, the package works reasonably well, but what is more
important is that you can learn a lot from their ideas. The use of
decorators for communicating with devices, for example, is a great way
of simplifying a lot of actions, like checking the limits and the units.&lt;/p&gt;
&lt;p&gt;I try to implement the new drivers that I write in Lantz, but I am also
realistic and know that for some devices it is better not to depend on
it, especially when dealing with very complex systems such as cameras.
If you want to explore more I suggest you check also:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://instrumental-lib.readthedocs.io/en/stable/"&gt;Instrumental, from Mabuchi
    Lab&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/ZhuangLab/storm-control"&gt;Storm Control, from Zhuang
    Lab&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/aquilesC/experimentor"&gt;Experimentor, by
    Aquiles Carattino&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Header photo by &lt;a href="https://unsplash.com/@pjswinburn"&gt;Philip Swinburn&lt;/a&gt; on
Unsplash&lt;/p&gt;</content><category term="blog"></category><category term="Lantz"></category><category term="Beginner"></category><category term="Drivers"></category><category term="Devices"></category></entry><entry><title>Controlling a National Instruments Card with Python</title><link href="https://www.pythonforthelab.com/blog/controlling-a-national-instruments-card-with-python" rel="alternate"></link><published>2018-02-21T00:00:00+01:00</published><updated>2018-02-21T00:00:00+01:00</updated><author><name>Aquiles Carattino</name></author><id>tag:www.pythonforthelab.com,2018-02-21:/blog/controlling-a-national-instruments-card-with-python</id><summary type="html">&lt;p&gt;One of the most common devices in a lab is a National Instruments
acquisition card, also called a DAQ. As you probably know by now, the
default programming environment for such cards is Lab View, but what you
may not be aware is that there are libraries for interfacing with …&lt;/p&gt;</summary><content type="html">&lt;p&gt;One of the most common devices in a lab is a National Instruments
acquisition card, also called a DAQ. As you probably know by now, the
default programming environment for such cards is Lab View, but what you
may not be aware is that there are libraries for interfacing with other
languages. NI provides a common driver to all of their devices called
&lt;em&gt;NI-DAQmx&lt;/em&gt; and how to use their hardware through the C programming
language is &lt;a href="http://zone.ni.com/reference/en-XX/help/370471AA-01/"&gt;well
documented&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Once there is good documentation for one programming language, there are
no limits for developers to expand the toolbox into other languages. For
National Instruments devices, there is a project called
&lt;a href="https://pythonhosted.org/PyDAQmx/"&gt;PyDAQmx&lt;/a&gt; that ported all the
functions to be Python compatible. Since it is a port of the C code,
what you should always bear in mind is that you have to check the
&lt;a href="http://zone.ni.com/reference/en-XX/help/370471AA-01/"&gt;National Instruments
documentation&lt;/a&gt; and
adapt the code to Python.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;Since the writing of this article, a new Python package supporting
NI-DAQmx was released by National Instruments itself. You can see the
&lt;a href="https://nidaqmx-python.readthedocs.io/en/latest/"&gt;documentation here&lt;/a&gt;.
I didn't have time to test it yet, but looks very promising. Keep an eye
on the &lt;a href="https://github.com/ni/nidaqmx-python/issues"&gt;bugs and issues&lt;/a&gt;
because they may be a good source of information.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Let's see how to get started. Remember that each card has different
specifications and therefore some of the options may not be present in
your current configuration. Let's assume we want to read an analog input
from our device; you need to know the number that was assigned to your
card in order to communicate with it; normally you should have National
Instruments software that allows you to configure the number of your
card.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import PyDAQmx as nidaq


t = nidaq.Task()
t.CreateAIVoltageChan(&amp;quot;Dev1/ai0&amp;quot;, None, nidaq.DAQmx_Val_Diff, 0, 10, nidaq.DAQmx_Val_Volts, None)
t.CfgSampClkTiming(&amp;quot;&amp;quot;, 1000, nidaq.DAQmx_Val_Rising, nidaq.DAQmx_Val_FiniteSamps, 5000)
t.StartTask()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In these few lines of code we have created a new Task and called it &lt;code&gt;t&lt;/code&gt;;
we have defined an analog input channel for &lt;code&gt;Dev1&lt;/code&gt; and port number
&lt;code&gt;ai0&lt;/code&gt;. We also configured the timing to be internal, with 1000 samples
per second and in total, we want to acquire 5000 samples. We finally
trigger the task to start acquiring samples. It is interesting to
compare our code to what is documented, so you can learn how to adapt
the code to Python.&lt;/p&gt;
&lt;p&gt;We first go to the documentation of the method
&lt;a href="http://zone.ni.com/reference/en-XX/help/370471AA-01/daqmxcfunc/daqmxcreateaivoltagechan/"&gt;CreateAIVoltageChan&lt;/a&gt;
and the first thing you should notice is that the name is actually
different; it is &lt;strong&gt;DAQmxCreateAIVoltageChan&lt;/strong&gt;. The first thing to note
is that the &lt;em&gt;DAQmx&lt;/em&gt; prefix is dropped in PyDAQmx. Then we can see the
arguments that the function takes:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;int32 DAQmxCreateAIVoltageChan (
   TaskHandle taskHandle,
   const char physicalChannel[],
   const char nameToAssignToChannel[],
   int32 terminalConfig,
   float64 minVal,
   float64 maxVal,
   int32 units,
   const char customScaleName[]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since we are using the task as Python object, we drop the first argument
of the function; PyDAQmx takes care of it (notice that we are using the
syntax &lt;code&gt;t.CreateAIVoltageChan&lt;/code&gt;. Then we have to pass all the other
arguments, paying attention to their types. So, where it says &lt;code&gt;char&lt;/code&gt; we
should pass a &lt;code&gt;String&lt;/code&gt;; that is what we do for the channel. In this
example, we don't assign a name to the channel and therefore we leave it
as &lt;code&gt;None&lt;/code&gt;. Next, we have to define the &lt;code&gt;terminalConfig&lt;/code&gt;; if you look at
the documentation, you will see that there are different options, for
example &lt;code&gt;DAQmx_Val_RSE&lt;/code&gt;, &lt;code&gt;DAQmx_Val_Diff&lt;/code&gt;, etc. PyDAQmx has all these
configurations already defined and we can use them directly as in the
example above: &lt;code&gt;nidaq.DAQmx_Val_Diff&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Then it asks for the limits of our analog input; remember that the DAQmx
works with units that can be different from volts and that will be
defined later on; the limits that we establish here are in those
specific units. Setting the limits allows the DAQ card to automatically
set a gain to our measurement, therefore increasing the effective
resolution of the measurement. The values are automatically converted to
the requested type, provided that they are numbers.&lt;/p&gt;
&lt;p&gt;When performing a measurement with an NI Card we have to explicitly set
its units; it may very well be that you have a thermocouple connected to
the analog input and therefore you want to measure Kelvins instead of
Volts, or that you have any other transducer plugged. Defining custom
scales is an entire chapter and therefore it is much easier to leave
them here as volts and do the transformation directly in our code. We
use again a built-in option of DAQmx, the &lt;code&gt;nidaq.DAQmx_Val_Volts&lt;/code&gt; and
the last option is left to &lt;code&gt;None&lt;/code&gt; because it is what the documentation
asks for in case we set the scale to Volts.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;Converting variable types from Python to C or the other way around is
handled in different ways by different libraries. PyDAQmx is doing all
the work under to hood and that is why we can use an integer instead of
a float, for example. But be aware that it will not always be the same;
some libraries require to define very specific types.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;The other method,
&lt;a href="http://zone.ni.com/reference/en-XX/help/370471AA-01/daqmxcfunc/daqmxcfgsampclktiming/"&gt;CfgSampClkTiming&lt;/a&gt;
is used for configuring the clock used to acquire the samples. I leave
it up to you to check the documentation and to understand what each
argument of the function is doing. In short, I set it to use an internal
clock at a rate of 1000 samples per second for a total of 5000 samples
(i.e. 5 seconds total acquisition time). The last line simply triggers
the task.&lt;/p&gt;
&lt;p&gt;The next step is to read the data that was acquired. Remember that it
takes 5 seconds for the acquisition to complete; the DAQmx functions are
non-blocking, meaning that the execution of your program will not halt
at each execution. For reading from the card we will use another method
defined within the Task object; you will also need to use numpy for this
example to work.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import numpy as np

[...]

data = np.zeros((5000,), dtype=np.float64)
read = nidaq.int32()
t.ReadAnalogF64(5000, 5, nidaq.DAQmx_Val_GroupByChannel,
   data, len(data), nidaq.byref(read), None)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Reading from the NI DAQ has a structure more similar to how proper C
code looks like and is quite different from how Python code works. The
first thing to note is that there is no return; we are not doing
anything like &lt;code&gt;data = t.ReadAnalogF64()&lt;/code&gt;. Let's see it step by step. The
&lt;a href="http://zone.ni.com/reference/en-XX/help/370471AA-01/daqmxcfunc/daqmxreadanalogf64/"&gt;documentation&lt;/a&gt;
is useful but doesn't explain how the actual syntax works. Again, we
skip the first argument, the &lt;code&gt;task handler&lt;/code&gt; because we are using the
object-oriented-style.&lt;/p&gt;
&lt;p&gt;We define how many data points &lt;em&gt;per channel&lt;/em&gt; we want to read; if we were
acquiring more than one channel, it is important to notice that it is
not the total number of points. We set the timeout in seconds, in order
for the function to stop waiting in case there are not enough data
points available. Then we set how to group the values in case we are
reading from more than one channel. Remember that each channel is read
sequentially, so it would be Chan1_1 -&amp;gt; Chan2_1 -&amp;gt; Chan3_1
-&amp;gt; Chan1_2 -&amp;gt; Chan2_2 -&amp;gt; Chan3_2 -&amp;gt; Chan1_3 -&amp;gt; etc.
If we group them by channel, they will be returned as all the
measurements from Chan1, all the measurements from Chan2, etc. I prefer
it this way because it works well with numpy's reshape.&lt;/p&gt;
&lt;p&gt;Now, the interesting part; we pass as an argument &lt;code&gt;data&lt;/code&gt;, which was
defined few lines before as an empty numpy array. In the documentation,
it is defined as The array to read samples into. This is a very common
way of working with functions in C; we first create the memory structure
that will hold the output of the function, in this case, a numpy array
with 5000 elements. Whatever is present in the array will be overwritten
by the read function. The next argument is the
actual number of samples read from each channel; in other words, the
length of the data array.&lt;/p&gt;
&lt;p&gt;The final argument is the &lt;code&gt;read&lt;/code&gt; integer, that was also defined few
lines before. It will hold the total number of data points read per
channel. Note that we are not simply passing the read integer as an
argument to the function, but we are using a method called &lt;code&gt;byref&lt;/code&gt;. This
is typical when working with external libraries written in C. It
basically means that you are passing the reference to an object and not
the object itself; you are letting the function know where in the memory
is located that specific variable. In the end, the effect is the same:
the variable will hold the information you need.&lt;/p&gt;
&lt;p&gt;Now you can plot your &lt;code&gt;data&lt;/code&gt;, save it or do whatever you like with it.
The read function has a lot of options that I haven't fully covered, but
that you can easily check the documentation. The complexity arises
because the function covers a lot of different scenarios with few
inputs. For example, when you are continuously acquiring and you wish to
download as many data points as there are available but you cannot know
beforehand how many. It can also take care when you use an external
trigger and you don't know how long it will take to complete an
acquisition.&lt;/p&gt;
&lt;p&gt;Even though National Instruments cards were not designed to be used with
Python, there can still be used in a variety of projects without many
complications. The use of a common API for all the cards makes them
ideal because exchanging them doesn't require a single change in the
code. However, each card can have very different capabilities, for
example, the acquisition rate or the number of simultaneous tasks that
it can handle.&lt;/p&gt;
&lt;p&gt;More Information: &lt;a href="https://pythonhosted.org/PyDAQmx/usage.html"&gt;PyDAQmx
Tutorial&lt;/a&gt;, &lt;a href="http://zone.ni.com/reference/en-XX/help/370471AA-01/"&gt;NI-DAQmx C
Reference Help&lt;/a&gt;&lt;/p&gt;</content><category term="blog"></category><category term="National Instruments"></category><category term="DAQ"></category><category term="Control"></category><category term="NI DAQ"></category><category term="PyDAQmx"></category></entry></feed>